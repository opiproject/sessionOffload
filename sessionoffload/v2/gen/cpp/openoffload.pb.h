// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: openoffload.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_openoffload_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_openoffload_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/timestamp.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_openoffload_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_openoffload_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[9]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_openoffload_2eproto;
namespace openoffload {
namespace v2 {
class ActionParameters;
struct ActionParametersDefaultTypeInternal;
extern ActionParametersDefaultTypeInternal _ActionParameters_default_instance_;
class AddSessionResponse;
struct AddSessionResponseDefaultTypeInternal;
extern AddSessionResponseDefaultTypeInternal _AddSessionResponse_default_instance_;
class SessionId;
struct SessionIdDefaultTypeInternal;
extern SessionIdDefaultTypeInternal _SessionId_default_instance_;
class SessionRequest;
struct SessionRequestDefaultTypeInternal;
extern SessionRequestDefaultTypeInternal _SessionRequest_default_instance_;
class SessionRequestArgs;
struct SessionRequestArgsDefaultTypeInternal;
extern SessionRequestArgsDefaultTypeInternal _SessionRequestArgs_default_instance_;
class SessionResponse;
struct SessionResponseDefaultTypeInternal;
extern SessionResponseDefaultTypeInternal _SessionResponse_default_instance_;
class SessionResponseError;
struct SessionResponseErrorDefaultTypeInternal;
extern SessionResponseErrorDefaultTypeInternal _SessionResponseError_default_instance_;
class SessionResponses;
struct SessionResponsesDefaultTypeInternal;
extern SessionResponsesDefaultTypeInternal _SessionResponses_default_instance_;
class Uuid;
struct UuidDefaultTypeInternal;
extern UuidDefaultTypeInternal _Uuid_default_instance_;
}  // namespace v2
}  // namespace openoffload
PROTOBUF_NAMESPACE_OPEN
template<> ::openoffload::v2::ActionParameters* Arena::CreateMaybeMessage<::openoffload::v2::ActionParameters>(Arena*);
template<> ::openoffload::v2::AddSessionResponse* Arena::CreateMaybeMessage<::openoffload::v2::AddSessionResponse>(Arena*);
template<> ::openoffload::v2::SessionId* Arena::CreateMaybeMessage<::openoffload::v2::SessionId>(Arena*);
template<> ::openoffload::v2::SessionRequest* Arena::CreateMaybeMessage<::openoffload::v2::SessionRequest>(Arena*);
template<> ::openoffload::v2::SessionRequestArgs* Arena::CreateMaybeMessage<::openoffload::v2::SessionRequestArgs>(Arena*);
template<> ::openoffload::v2::SessionResponse* Arena::CreateMaybeMessage<::openoffload::v2::SessionResponse>(Arena*);
template<> ::openoffload::v2::SessionResponseError* Arena::CreateMaybeMessage<::openoffload::v2::SessionResponseError>(Arena*);
template<> ::openoffload::v2::SessionResponses* Arena::CreateMaybeMessage<::openoffload::v2::SessionResponses>(Arena*);
template<> ::openoffload::v2::Uuid* Arena::CreateMaybeMessage<::openoffload::v2::Uuid>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace openoffload {
namespace v2 {

enum IpVersion : int {
  _IPV4 = 0,
  _IPV6 = 1,
  IpVersion_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  IpVersion_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool IpVersion_IsValid(int value);
constexpr IpVersion IpVersion_MIN = _IPV4;
constexpr IpVersion IpVersion_MAX = _IPV6;
constexpr int IpVersion_ARRAYSIZE = IpVersion_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* IpVersion_descriptor();
template<typename T>
inline const std::string& IpVersion_Name(T enum_t_value) {
  static_assert(::std::is_same<T, IpVersion>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function IpVersion_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    IpVersion_descriptor(), enum_t_value);
}
inline bool IpVersion_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, IpVersion* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<IpVersion>(
    IpVersion_descriptor(), name, value);
}
enum ProtocolId : int {
  _HOPOPT = 0,
  _TCP = 6,
  _UDP = 17,
  ProtocolId_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ProtocolId_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ProtocolId_IsValid(int value);
constexpr ProtocolId ProtocolId_MIN = _HOPOPT;
constexpr ProtocolId ProtocolId_MAX = _UDP;
constexpr int ProtocolId_ARRAYSIZE = ProtocolId_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ProtocolId_descriptor();
template<typename T>
inline const std::string& ProtocolId_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ProtocolId>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ProtocolId_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ProtocolId_descriptor(), enum_t_value);
}
inline bool ProtocolId_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ProtocolId* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ProtocolId>(
    ProtocolId_descriptor(), name, value);
}
enum SessionState : int {
  _ESTABLISHED = 0,
  _CLOSING_1 = 1,
  _CLOSING_2 = 2,
  _CLOSED = 3,
  _UNKNOWN_STATE = 4,
  SessionState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SessionState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SessionState_IsValid(int value);
constexpr SessionState SessionState_MIN = _ESTABLISHED;
constexpr SessionState SessionState_MAX = _UNKNOWN_STATE;
constexpr int SessionState_ARRAYSIZE = SessionState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SessionState_descriptor();
template<typename T>
inline const std::string& SessionState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SessionState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SessionState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SessionState_descriptor(), enum_t_value);
}
inline bool SessionState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SessionState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SessionState>(
    SessionState_descriptor(), name, value);
}
enum SessionCloseCode : int {
  _NOT_CLOSED = 0,
  _FINACK = 1,
  _RST = 2,
  _TIMEOUT = 3,
  _UNKNOWN_CLOSE_CODE = 4,
  SessionCloseCode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SessionCloseCode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SessionCloseCode_IsValid(int value);
constexpr SessionCloseCode SessionCloseCode_MIN = _NOT_CLOSED;
constexpr SessionCloseCode SessionCloseCode_MAX = _UNKNOWN_CLOSE_CODE;
constexpr int SessionCloseCode_ARRAYSIZE = SessionCloseCode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SessionCloseCode_descriptor();
template<typename T>
inline const std::string& SessionCloseCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SessionCloseCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SessionCloseCode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SessionCloseCode_descriptor(), enum_t_value);
}
inline bool SessionCloseCode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SessionCloseCode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SessionCloseCode>(
    SessionCloseCode_descriptor(), name, value);
}
enum AddSessionStatus : int {
  _SESSION_ACCEPTED = 0,
  _SESSION_REJECTED = 1,
  _SESSION_TABLE_FULL = 2,
  _SESSION_TABLE_UNAVAILABLE = 3,
  _SESSION_ALREADY_EXISTS = 4,
  AddSessionStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  AddSessionStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool AddSessionStatus_IsValid(int value);
constexpr AddSessionStatus AddSessionStatus_MIN = _SESSION_ACCEPTED;
constexpr AddSessionStatus AddSessionStatus_MAX = _SESSION_ALREADY_EXISTS;
constexpr int AddSessionStatus_ARRAYSIZE = AddSessionStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AddSessionStatus_descriptor();
template<typename T>
inline const std::string& AddSessionStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AddSessionStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AddSessionStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AddSessionStatus_descriptor(), enum_t_value);
}
inline bool AddSessionStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AddSessionStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AddSessionStatus>(
    AddSessionStatus_descriptor(), name, value);
}
enum RequestStatus : int {
  _ACCEPTED = 0,
  _REJECTED = 1,
  _REJECTED_SESSION_NONEXISTENT = 2,
  _REJECTED_SESSION_TABLE_FULL = 3,
  _REJECTED_SESSION_ALREADY_EXISTS = 4,
  _NO_CLOSED_SESSIONS = 5,
  _REJECTED_INTERNAL_ERROR = 6,
  RequestStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  RequestStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool RequestStatus_IsValid(int value);
constexpr RequestStatus RequestStatus_MIN = _ACCEPTED;
constexpr RequestStatus RequestStatus_MAX = _REJECTED_INTERNAL_ERROR;
constexpr int RequestStatus_ARRAYSIZE = RequestStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RequestStatus_descriptor();
template<typename T>
inline const std::string& RequestStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RequestStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RequestStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RequestStatus_descriptor(), enum_t_value);
}
inline bool RequestStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RequestStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RequestStatus>(
    RequestStatus_descriptor(), name, value);
}
enum ActionType : int {
  _DROP = 0,
  _FORWARD = 1,
  _MIRROR = 2,
  _SNOOP = 3,
  ActionType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ActionType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ActionType_IsValid(int value);
constexpr ActionType ActionType_MIN = _DROP;
constexpr ActionType ActionType_MAX = _SNOOP;
constexpr int ActionType_ARRAYSIZE = ActionType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ActionType_descriptor();
template<typename T>
inline const std::string& ActionType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ActionType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ActionType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ActionType_descriptor(), enum_t_value);
}
inline bool ActionType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ActionType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ActionType>(
    ActionType_descriptor(), name, value);
}
// ===================================================================

class Uuid final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openoffload.v2.Uuid) */ {
 public:
  inline Uuid() : Uuid(nullptr) {}
  ~Uuid() override;
  explicit constexpr Uuid(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Uuid(const Uuid& from);
  Uuid(Uuid&& from) noexcept
    : Uuid() {
    *this = ::std::move(from);
  }

  inline Uuid& operator=(const Uuid& from) {
    CopyFrom(from);
    return *this;
  }
  inline Uuid& operator=(Uuid&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Uuid& default_instance() {
    return *internal_default_instance();
  }
  static inline const Uuid* internal_default_instance() {
    return reinterpret_cast<const Uuid*>(
               &_Uuid_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Uuid& a, Uuid& b) {
    a.Swap(&b);
  }
  inline void Swap(Uuid* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Uuid* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Uuid* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Uuid>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Uuid& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Uuid& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Uuid* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openoffload.v2.Uuid";
  }
  protected:
  explicit Uuid(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // string value = 1;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // @@protoc_insertion_point(class_scope:openoffload.v2.Uuid)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_openoffload_2eproto;
};
// -------------------------------------------------------------------

class SessionId final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openoffload.v2.SessionId) */ {
 public:
  inline SessionId() : SessionId(nullptr) {}
  ~SessionId() override;
  explicit constexpr SessionId(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SessionId(const SessionId& from);
  SessionId(SessionId&& from) noexcept
    : SessionId() {
    *this = ::std::move(from);
  }

  inline SessionId& operator=(const SessionId& from) {
    CopyFrom(from);
    return *this;
  }
  inline SessionId& operator=(SessionId&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SessionId& default_instance() {
    return *internal_default_instance();
  }
  static inline const SessionId* internal_default_instance() {
    return reinterpret_cast<const SessionId*>(
               &_SessionId_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(SessionId& a, SessionId& b) {
    a.Swap(&b);
  }
  inline void Swap(SessionId* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SessionId* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SessionId* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SessionId>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SessionId& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SessionId& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SessionId* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openoffload.v2.SessionId";
  }
  protected:
  explicit SessionId(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionIdFieldNumber = 1,
  };
  // uint64 session_id = 1;
  void clear_session_id();
  uint64_t session_id() const;
  void set_session_id(uint64_t value);
  private:
  uint64_t _internal_session_id() const;
  void _internal_set_session_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:openoffload.v2.SessionId)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint64_t session_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_openoffload_2eproto;
};
// -------------------------------------------------------------------

class ActionParameters final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openoffload.v2.ActionParameters) */ {
 public:
  inline ActionParameters() : ActionParameters(nullptr) {}
  ~ActionParameters() override;
  explicit constexpr ActionParameters(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ActionParameters(const ActionParameters& from);
  ActionParameters(ActionParameters&& from) noexcept
    : ActionParameters() {
    *this = ::std::move(from);
  }

  inline ActionParameters& operator=(const ActionParameters& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActionParameters& operator=(ActionParameters&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ActionParameters& default_instance() {
    return *internal_default_instance();
  }
  static inline const ActionParameters* internal_default_instance() {
    return reinterpret_cast<const ActionParameters*>(
               &_ActionParameters_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ActionParameters& a, ActionParameters& b) {
    a.Swap(&b);
  }
  inline void Swap(ActionParameters* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActionParameters* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ActionParameters* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ActionParameters>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ActionParameters& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ActionParameters& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActionParameters* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openoffload.v2.ActionParameters";
  }
  protected:
  explicit ActionParameters(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kActionNextHopV6FieldNumber = 3,
    kActionTypeFieldNumber = 1,
    kActionNextHopFieldNumber = 2,
  };
  // bytes action_next_hop_v6 = 3;
  void clear_action_next_hop_v6();
  const std::string& action_next_hop_v6() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_action_next_hop_v6(ArgT0&& arg0, ArgT... args);
  std::string* mutable_action_next_hop_v6();
  PROTOBUF_NODISCARD std::string* release_action_next_hop_v6();
  void set_allocated_action_next_hop_v6(std::string* action_next_hop_v6);
  private:
  const std::string& _internal_action_next_hop_v6() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_action_next_hop_v6(const std::string& value);
  std::string* _internal_mutable_action_next_hop_v6();
  public:

  // .openoffload.v2.ActionType action_type = 1;
  void clear_action_type();
  ::openoffload::v2::ActionType action_type() const;
  void set_action_type(::openoffload::v2::ActionType value);
  private:
  ::openoffload::v2::ActionType _internal_action_type() const;
  void _internal_set_action_type(::openoffload::v2::ActionType value);
  public:

  // uint32 action_next_hop = 2;
  void clear_action_next_hop();
  uint32_t action_next_hop() const;
  void set_action_next_hop(uint32_t value);
  private:
  uint32_t _internal_action_next_hop() const;
  void _internal_set_action_next_hop(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:openoffload.v2.ActionParameters)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr action_next_hop_v6_;
  int action_type_;
  uint32_t action_next_hop_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_openoffload_2eproto;
};
// -------------------------------------------------------------------

class SessionRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openoffload.v2.SessionRequest) */ {
 public:
  inline SessionRequest() : SessionRequest(nullptr) {}
  ~SessionRequest() override;
  explicit constexpr SessionRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SessionRequest(const SessionRequest& from);
  SessionRequest(SessionRequest&& from) noexcept
    : SessionRequest() {
    *this = ::std::move(from);
  }

  inline SessionRequest& operator=(const SessionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SessionRequest& operator=(SessionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SessionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SessionRequest* internal_default_instance() {
    return reinterpret_cast<const SessionRequest*>(
               &_SessionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(SessionRequest& a, SessionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SessionRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SessionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SessionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SessionRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SessionRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SessionRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SessionRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openoffload.v2.SessionRequest";
  }
  protected:
  explicit SessionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSourceIpv6FieldNumber = 6,
    kDestinationIpv6FieldNumber = 9,
    kActionFieldNumber = 12,
    kSessionIdFieldNumber = 1,
    kInLifFieldNumber = 2,
    kOutLifFieldNumber = 3,
    kIpVersionFieldNumber = 4,
    kSourceIpFieldNumber = 5,
    kSourcePortFieldNumber = 7,
    kDestinationIpFieldNumber = 8,
    kDestinationPortFieldNumber = 10,
    kProtocolIdFieldNumber = 11,
    kCacheTimeoutFieldNumber = 13,
  };
  // bytes source_ipv6 = 6;
  void clear_source_ipv6();
  const std::string& source_ipv6() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_source_ipv6(ArgT0&& arg0, ArgT... args);
  std::string* mutable_source_ipv6();
  PROTOBUF_NODISCARD std::string* release_source_ipv6();
  void set_allocated_source_ipv6(std::string* source_ipv6);
  private:
  const std::string& _internal_source_ipv6() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_source_ipv6(const std::string& value);
  std::string* _internal_mutable_source_ipv6();
  public:

  // bytes destination_ipv6 = 9;
  void clear_destination_ipv6();
  const std::string& destination_ipv6() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_destination_ipv6(ArgT0&& arg0, ArgT... args);
  std::string* mutable_destination_ipv6();
  PROTOBUF_NODISCARD std::string* release_destination_ipv6();
  void set_allocated_destination_ipv6(std::string* destination_ipv6);
  private:
  const std::string& _internal_destination_ipv6() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_destination_ipv6(const std::string& value);
  std::string* _internal_mutable_destination_ipv6();
  public:

  // .openoffload.v2.ActionParameters action = 12;
  bool has_action() const;
  private:
  bool _internal_has_action() const;
  public:
  void clear_action();
  const ::openoffload::v2::ActionParameters& action() const;
  PROTOBUF_NODISCARD ::openoffload::v2::ActionParameters* release_action();
  ::openoffload::v2::ActionParameters* mutable_action();
  void set_allocated_action(::openoffload::v2::ActionParameters* action);
  private:
  const ::openoffload::v2::ActionParameters& _internal_action() const;
  ::openoffload::v2::ActionParameters* _internal_mutable_action();
  public:
  void unsafe_arena_set_allocated_action(
      ::openoffload::v2::ActionParameters* action);
  ::openoffload::v2::ActionParameters* unsafe_arena_release_action();

  // uint64 session_id = 1;
  void clear_session_id();
  uint64_t session_id() const;
  void set_session_id(uint64_t value);
  private:
  uint64_t _internal_session_id() const;
  void _internal_set_session_id(uint64_t value);
  public:

  // int32 in_lif = 2;
  void clear_in_lif();
  int32_t in_lif() const;
  void set_in_lif(int32_t value);
  private:
  int32_t _internal_in_lif() const;
  void _internal_set_in_lif(int32_t value);
  public:

  // int32 out_lif = 3;
  void clear_out_lif();
  int32_t out_lif() const;
  void set_out_lif(int32_t value);
  private:
  int32_t _internal_out_lif() const;
  void _internal_set_out_lif(int32_t value);
  public:

  // .openoffload.v2.IpVersion ip_version = 4;
  void clear_ip_version();
  ::openoffload::v2::IpVersion ip_version() const;
  void set_ip_version(::openoffload::v2::IpVersion value);
  private:
  ::openoffload::v2::IpVersion _internal_ip_version() const;
  void _internal_set_ip_version(::openoffload::v2::IpVersion value);
  public:

  // uint32 source_ip = 5;
  void clear_source_ip();
  uint32_t source_ip() const;
  void set_source_ip(uint32_t value);
  private:
  uint32_t _internal_source_ip() const;
  void _internal_set_source_ip(uint32_t value);
  public:

  // uint32 source_port = 7;
  void clear_source_port();
  uint32_t source_port() const;
  void set_source_port(uint32_t value);
  private:
  uint32_t _internal_source_port() const;
  void _internal_set_source_port(uint32_t value);
  public:

  // uint32 destination_ip = 8;
  void clear_destination_ip();
  uint32_t destination_ip() const;
  void set_destination_ip(uint32_t value);
  private:
  uint32_t _internal_destination_ip() const;
  void _internal_set_destination_ip(uint32_t value);
  public:

  // uint32 destination_port = 10;
  void clear_destination_port();
  uint32_t destination_port() const;
  void set_destination_port(uint32_t value);
  private:
  uint32_t _internal_destination_port() const;
  void _internal_set_destination_port(uint32_t value);
  public:

  // .openoffload.v2.ProtocolId protocol_id = 11;
  void clear_protocol_id();
  ::openoffload::v2::ProtocolId protocol_id() const;
  void set_protocol_id(::openoffload::v2::ProtocolId value);
  private:
  ::openoffload::v2::ProtocolId _internal_protocol_id() const;
  void _internal_set_protocol_id(::openoffload::v2::ProtocolId value);
  public:

  // uint32 cache_timeout = 13;
  void clear_cache_timeout();
  uint32_t cache_timeout() const;
  void set_cache_timeout(uint32_t value);
  private:
  uint32_t _internal_cache_timeout() const;
  void _internal_set_cache_timeout(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:openoffload.v2.SessionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr source_ipv6_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr destination_ipv6_;
  ::openoffload::v2::ActionParameters* action_;
  uint64_t session_id_;
  int32_t in_lif_;
  int32_t out_lif_;
  int ip_version_;
  uint32_t source_ip_;
  uint32_t source_port_;
  uint32_t destination_ip_;
  uint32_t destination_port_;
  int protocol_id_;
  uint32_t cache_timeout_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_openoffload_2eproto;
};
// -------------------------------------------------------------------

class SessionResponseError final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openoffload.v2.SessionResponseError) */ {
 public:
  inline SessionResponseError() : SessionResponseError(nullptr) {}
  ~SessionResponseError() override;
  explicit constexpr SessionResponseError(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SessionResponseError(const SessionResponseError& from);
  SessionResponseError(SessionResponseError&& from) noexcept
    : SessionResponseError() {
    *this = ::std::move(from);
  }

  inline SessionResponseError& operator=(const SessionResponseError& from) {
    CopyFrom(from);
    return *this;
  }
  inline SessionResponseError& operator=(SessionResponseError&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SessionResponseError& default_instance() {
    return *internal_default_instance();
  }
  static inline const SessionResponseError* internal_default_instance() {
    return reinterpret_cast<const SessionResponseError*>(
               &_SessionResponseError_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(SessionResponseError& a, SessionResponseError& b) {
    a.Swap(&b);
  }
  inline void Swap(SessionResponseError* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SessionResponseError* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SessionResponseError* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SessionResponseError>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SessionResponseError& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SessionResponseError& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SessionResponseError* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openoffload.v2.SessionResponseError";
  }
  protected:
  explicit SessionResponseError(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionIdFieldNumber = 1,
    kErrorStatusFieldNumber = 2,
  };
  // uint64 session_id = 1;
  void clear_session_id();
  uint64_t session_id() const;
  void set_session_id(uint64_t value);
  private:
  uint64_t _internal_session_id() const;
  void _internal_set_session_id(uint64_t value);
  public:

  // int32 error_status = 2;
  void clear_error_status();
  int32_t error_status() const;
  void set_error_status(int32_t value);
  private:
  int32_t _internal_error_status() const;
  void _internal_set_error_status(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:openoffload.v2.SessionResponseError)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint64_t session_id_;
  int32_t error_status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_openoffload_2eproto;
};
// -------------------------------------------------------------------

class SessionResponses final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openoffload.v2.SessionResponses) */ {
 public:
  inline SessionResponses() : SessionResponses(nullptr) {}
  ~SessionResponses() override;
  explicit constexpr SessionResponses(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SessionResponses(const SessionResponses& from);
  SessionResponses(SessionResponses&& from) noexcept
    : SessionResponses() {
    *this = ::std::move(from);
  }

  inline SessionResponses& operator=(const SessionResponses& from) {
    CopyFrom(from);
    return *this;
  }
  inline SessionResponses& operator=(SessionResponses&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SessionResponses& default_instance() {
    return *internal_default_instance();
  }
  static inline const SessionResponses* internal_default_instance() {
    return reinterpret_cast<const SessionResponses*>(
               &_SessionResponses_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(SessionResponses& a, SessionResponses& b) {
    a.Swap(&b);
  }
  inline void Swap(SessionResponses* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SessionResponses* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SessionResponses* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SessionResponses>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SessionResponses& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SessionResponses& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SessionResponses* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openoffload.v2.SessionResponses";
  }
  protected:
  explicit SessionResponses(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionInfoFieldNumber = 1,
    kNextKeyFieldNumber = 2,
  };
  // repeated .openoffload.v2.SessionResponse session_info = 1;
  int session_info_size() const;
  private:
  int _internal_session_info_size() const;
  public:
  void clear_session_info();
  ::openoffload::v2::SessionResponse* mutable_session_info(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openoffload::v2::SessionResponse >*
      mutable_session_info();
  private:
  const ::openoffload::v2::SessionResponse& _internal_session_info(int index) const;
  ::openoffload::v2::SessionResponse* _internal_add_session_info();
  public:
  const ::openoffload::v2::SessionResponse& session_info(int index) const;
  ::openoffload::v2::SessionResponse* add_session_info();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openoffload::v2::SessionResponse >&
      session_info() const;

  // uint64 next_key = 2;
  void clear_next_key();
  uint64_t next_key() const;
  void set_next_key(uint64_t value);
  private:
  uint64_t _internal_next_key() const;
  void _internal_set_next_key(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:openoffload.v2.SessionResponses)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openoffload::v2::SessionResponse > session_info_;
  uint64_t next_key_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_openoffload_2eproto;
};
// -------------------------------------------------------------------

class AddSessionResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openoffload.v2.AddSessionResponse) */ {
 public:
  inline AddSessionResponse() : AddSessionResponse(nullptr) {}
  ~AddSessionResponse() override;
  explicit constexpr AddSessionResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddSessionResponse(const AddSessionResponse& from);
  AddSessionResponse(AddSessionResponse&& from) noexcept
    : AddSessionResponse() {
    *this = ::std::move(from);
  }

  inline AddSessionResponse& operator=(const AddSessionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddSessionResponse& operator=(AddSessionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddSessionResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddSessionResponse* internal_default_instance() {
    return reinterpret_cast<const AddSessionResponse*>(
               &_AddSessionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(AddSessionResponse& a, AddSessionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AddSessionResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddSessionResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddSessionResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddSessionResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AddSessionResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AddSessionResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddSessionResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openoffload.v2.AddSessionResponse";
  }
  protected:
  explicit AddSessionResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponseErrorFieldNumber = 4,
    kStartTimeFieldNumber = 3,
    kErrorStatusFieldNumber = 2,
    kRequestStatusFieldNumber = 1,
  };
  // repeated .openoffload.v2.SessionResponseError response_error = 4;
  int response_error_size() const;
  private:
  int _internal_response_error_size() const;
  public:
  void clear_response_error();
  ::openoffload::v2::SessionResponseError* mutable_response_error(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openoffload::v2::SessionResponseError >*
      mutable_response_error();
  private:
  const ::openoffload::v2::SessionResponseError& _internal_response_error(int index) const;
  ::openoffload::v2::SessionResponseError* _internal_add_response_error();
  public:
  const ::openoffload::v2::SessionResponseError& response_error(int index) const;
  ::openoffload::v2::SessionResponseError* add_response_error();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openoffload::v2::SessionResponseError >&
      response_error() const;

  // .google.protobuf.Timestamp start_time = 3;
  bool has_start_time() const;
  private:
  bool _internal_has_start_time() const;
  public:
  void clear_start_time();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& start_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_start_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_start_time();
  void set_allocated_start_time(::PROTOBUF_NAMESPACE_ID::Timestamp* start_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_start_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_start_time();
  public:
  void unsafe_arena_set_allocated_start_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* start_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_start_time();

  // uint64 error_status = 2;
  void clear_error_status();
  uint64_t error_status() const;
  void set_error_status(uint64_t value);
  private:
  uint64_t _internal_error_status() const;
  void _internal_set_error_status(uint64_t value);
  public:

  // .openoffload.v2.AddSessionStatus request_status = 1;
  void clear_request_status();
  ::openoffload::v2::AddSessionStatus request_status() const;
  void set_request_status(::openoffload::v2::AddSessionStatus value);
  private:
  ::openoffload::v2::AddSessionStatus _internal_request_status() const;
  void _internal_set_request_status(::openoffload::v2::AddSessionStatus value);
  public:

  // @@protoc_insertion_point(class_scope:openoffload.v2.AddSessionResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openoffload::v2::SessionResponseError > response_error_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* start_time_;
  uint64_t error_status_;
  int request_status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_openoffload_2eproto;
};
// -------------------------------------------------------------------

class SessionResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openoffload.v2.SessionResponse) */ {
 public:
  inline SessionResponse() : SessionResponse(nullptr) {}
  ~SessionResponse() override;
  explicit constexpr SessionResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SessionResponse(const SessionResponse& from);
  SessionResponse(SessionResponse&& from) noexcept
    : SessionResponse() {
    *this = ::std::move(from);
  }

  inline SessionResponse& operator=(const SessionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SessionResponse& operator=(SessionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SessionResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SessionResponse* internal_default_instance() {
    return reinterpret_cast<const SessionResponse*>(
               &_SessionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(SessionResponse& a, SessionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SessionResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SessionResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SessionResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SessionResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SessionResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SessionResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SessionResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openoffload.v2.SessionResponse";
  }
  protected:
  explicit SessionResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartTimeFieldNumber = 9,
    kEndTimeFieldNumber = 10,
    kSessionIdFieldNumber = 1,
    kInPacketsFieldNumber = 2,
    kOutPacketsFieldNumber = 3,
    kInBytesFieldNumber = 4,
    kOutBytesFieldNumber = 5,
    kSessionStateFieldNumber = 6,
    kSessionCloseCodeFieldNumber = 7,
    kRequestStatusFieldNumber = 8,
  };
  // .google.protobuf.Timestamp start_time = 9;
  bool has_start_time() const;
  private:
  bool _internal_has_start_time() const;
  public:
  void clear_start_time();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& start_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_start_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_start_time();
  void set_allocated_start_time(::PROTOBUF_NAMESPACE_ID::Timestamp* start_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_start_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_start_time();
  public:
  void unsafe_arena_set_allocated_start_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* start_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_start_time();

  // .google.protobuf.Timestamp end_time = 10;
  bool has_end_time() const;
  private:
  bool _internal_has_end_time() const;
  public:
  void clear_end_time();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& end_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_end_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_end_time();
  void set_allocated_end_time(::PROTOBUF_NAMESPACE_ID::Timestamp* end_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_end_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_end_time();
  public:
  void unsafe_arena_set_allocated_end_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* end_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_end_time();

  // uint64 session_id = 1;
  void clear_session_id();
  uint64_t session_id() const;
  void set_session_id(uint64_t value);
  private:
  uint64_t _internal_session_id() const;
  void _internal_set_session_id(uint64_t value);
  public:

  // uint64 in_packets = 2;
  void clear_in_packets();
  uint64_t in_packets() const;
  void set_in_packets(uint64_t value);
  private:
  uint64_t _internal_in_packets() const;
  void _internal_set_in_packets(uint64_t value);
  public:

  // uint64 out_packets = 3;
  void clear_out_packets();
  uint64_t out_packets() const;
  void set_out_packets(uint64_t value);
  private:
  uint64_t _internal_out_packets() const;
  void _internal_set_out_packets(uint64_t value);
  public:

  // uint64 in_bytes = 4;
  void clear_in_bytes();
  uint64_t in_bytes() const;
  void set_in_bytes(uint64_t value);
  private:
  uint64_t _internal_in_bytes() const;
  void _internal_set_in_bytes(uint64_t value);
  public:

  // uint64 out_bytes = 5;
  void clear_out_bytes();
  uint64_t out_bytes() const;
  void set_out_bytes(uint64_t value);
  private:
  uint64_t _internal_out_bytes() const;
  void _internal_set_out_bytes(uint64_t value);
  public:

  // .openoffload.v2.SessionState session_state = 6;
  void clear_session_state();
  ::openoffload::v2::SessionState session_state() const;
  void set_session_state(::openoffload::v2::SessionState value);
  private:
  ::openoffload::v2::SessionState _internal_session_state() const;
  void _internal_set_session_state(::openoffload::v2::SessionState value);
  public:

  // .openoffload.v2.SessionCloseCode session_close_code = 7;
  void clear_session_close_code();
  ::openoffload::v2::SessionCloseCode session_close_code() const;
  void set_session_close_code(::openoffload::v2::SessionCloseCode value);
  private:
  ::openoffload::v2::SessionCloseCode _internal_session_close_code() const;
  void _internal_set_session_close_code(::openoffload::v2::SessionCloseCode value);
  public:

  // .openoffload.v2.RequestStatus request_status = 8;
  void clear_request_status();
  ::openoffload::v2::RequestStatus request_status() const;
  void set_request_status(::openoffload::v2::RequestStatus value);
  private:
  ::openoffload::v2::RequestStatus _internal_request_status() const;
  void _internal_set_request_status(::openoffload::v2::RequestStatus value);
  public:

  // @@protoc_insertion_point(class_scope:openoffload.v2.SessionResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* start_time_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* end_time_;
  uint64_t session_id_;
  uint64_t in_packets_;
  uint64_t out_packets_;
  uint64_t in_bytes_;
  uint64_t out_bytes_;
  int session_state_;
  int session_close_code_;
  int request_status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_openoffload_2eproto;
};
// -------------------------------------------------------------------

class SessionRequestArgs final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openoffload.v2.SessionRequestArgs) */ {
 public:
  inline SessionRequestArgs() : SessionRequestArgs(nullptr) {}
  ~SessionRequestArgs() override;
  explicit constexpr SessionRequestArgs(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SessionRequestArgs(const SessionRequestArgs& from);
  SessionRequestArgs(SessionRequestArgs&& from) noexcept
    : SessionRequestArgs() {
    *this = ::std::move(from);
  }

  inline SessionRequestArgs& operator=(const SessionRequestArgs& from) {
    CopyFrom(from);
    return *this;
  }
  inline SessionRequestArgs& operator=(SessionRequestArgs&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SessionRequestArgs& default_instance() {
    return *internal_default_instance();
  }
  static inline const SessionRequestArgs* internal_default_instance() {
    return reinterpret_cast<const SessionRequestArgs*>(
               &_SessionRequestArgs_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(SessionRequestArgs& a, SessionRequestArgs& b) {
    a.Swap(&b);
  }
  inline void Swap(SessionRequestArgs* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SessionRequestArgs* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SessionRequestArgs* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SessionRequestArgs>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SessionRequestArgs& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SessionRequestArgs& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SessionRequestArgs* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openoffload.v2.SessionRequestArgs";
  }
  protected:
  explicit SessionRequestArgs(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPageSizeFieldNumber = 1,
    kPageFieldNumber = 2,
    kStartSessionFieldNumber = 3,
  };
  // uint32 page_size = 1;
  void clear_page_size();
  uint32_t page_size() const;
  void set_page_size(uint32_t value);
  private:
  uint32_t _internal_page_size() const;
  void _internal_set_page_size(uint32_t value);
  public:

  // uint32 page = 2;
  void clear_page();
  uint32_t page() const;
  void set_page(uint32_t value);
  private:
  uint32_t _internal_page() const;
  void _internal_set_page(uint32_t value);
  public:

  // uint64 start_session = 3;
  void clear_start_session();
  uint64_t start_session() const;
  void set_start_session(uint64_t value);
  private:
  uint64_t _internal_start_session() const;
  void _internal_set_start_session(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:openoffload.v2.SessionRequestArgs)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t page_size_;
  uint32_t page_;
  uint64_t start_session_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_openoffload_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Uuid

// string value = 1;
inline void Uuid::clear_value() {
  value_.ClearToEmpty();
}
inline const std::string& Uuid::value() const {
  // @@protoc_insertion_point(field_get:openoffload.v2.Uuid.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Uuid::set_value(ArgT0&& arg0, ArgT... args) {
 
 value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openoffload.v2.Uuid.value)
}
inline std::string* Uuid::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:openoffload.v2.Uuid.value)
  return _s;
}
inline const std::string& Uuid::_internal_value() const {
  return value_.Get();
}
inline void Uuid::_internal_set_value(const std::string& value) {
  
  value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Uuid::_internal_mutable_value() {
  
  return value_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Uuid::release_value() {
  // @@protoc_insertion_point(field_release:openoffload.v2.Uuid.value)
  return value_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Uuid::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (value_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openoffload.v2.Uuid.value)
}

// -------------------------------------------------------------------

// SessionId

// uint64 session_id = 1;
inline void SessionId::clear_session_id() {
  session_id_ = uint64_t{0u};
}
inline uint64_t SessionId::_internal_session_id() const {
  return session_id_;
}
inline uint64_t SessionId::session_id() const {
  // @@protoc_insertion_point(field_get:openoffload.v2.SessionId.session_id)
  return _internal_session_id();
}
inline void SessionId::_internal_set_session_id(uint64_t value) {
  
  session_id_ = value;
}
inline void SessionId::set_session_id(uint64_t value) {
  _internal_set_session_id(value);
  // @@protoc_insertion_point(field_set:openoffload.v2.SessionId.session_id)
}

// -------------------------------------------------------------------

// ActionParameters

// .openoffload.v2.ActionType action_type = 1;
inline void ActionParameters::clear_action_type() {
  action_type_ = 0;
}
inline ::openoffload::v2::ActionType ActionParameters::_internal_action_type() const {
  return static_cast< ::openoffload::v2::ActionType >(action_type_);
}
inline ::openoffload::v2::ActionType ActionParameters::action_type() const {
  // @@protoc_insertion_point(field_get:openoffload.v2.ActionParameters.action_type)
  return _internal_action_type();
}
inline void ActionParameters::_internal_set_action_type(::openoffload::v2::ActionType value) {
  
  action_type_ = value;
}
inline void ActionParameters::set_action_type(::openoffload::v2::ActionType value) {
  _internal_set_action_type(value);
  // @@protoc_insertion_point(field_set:openoffload.v2.ActionParameters.action_type)
}

// uint32 action_next_hop = 2;
inline void ActionParameters::clear_action_next_hop() {
  action_next_hop_ = 0u;
}
inline uint32_t ActionParameters::_internal_action_next_hop() const {
  return action_next_hop_;
}
inline uint32_t ActionParameters::action_next_hop() const {
  // @@protoc_insertion_point(field_get:openoffload.v2.ActionParameters.action_next_hop)
  return _internal_action_next_hop();
}
inline void ActionParameters::_internal_set_action_next_hop(uint32_t value) {
  
  action_next_hop_ = value;
}
inline void ActionParameters::set_action_next_hop(uint32_t value) {
  _internal_set_action_next_hop(value);
  // @@protoc_insertion_point(field_set:openoffload.v2.ActionParameters.action_next_hop)
}

// bytes action_next_hop_v6 = 3;
inline void ActionParameters::clear_action_next_hop_v6() {
  action_next_hop_v6_.ClearToEmpty();
}
inline const std::string& ActionParameters::action_next_hop_v6() const {
  // @@protoc_insertion_point(field_get:openoffload.v2.ActionParameters.action_next_hop_v6)
  return _internal_action_next_hop_v6();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ActionParameters::set_action_next_hop_v6(ArgT0&& arg0, ArgT... args) {
 
 action_next_hop_v6_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openoffload.v2.ActionParameters.action_next_hop_v6)
}
inline std::string* ActionParameters::mutable_action_next_hop_v6() {
  std::string* _s = _internal_mutable_action_next_hop_v6();
  // @@protoc_insertion_point(field_mutable:openoffload.v2.ActionParameters.action_next_hop_v6)
  return _s;
}
inline const std::string& ActionParameters::_internal_action_next_hop_v6() const {
  return action_next_hop_v6_.Get();
}
inline void ActionParameters::_internal_set_action_next_hop_v6(const std::string& value) {
  
  action_next_hop_v6_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ActionParameters::_internal_mutable_action_next_hop_v6() {
  
  return action_next_hop_v6_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ActionParameters::release_action_next_hop_v6() {
  // @@protoc_insertion_point(field_release:openoffload.v2.ActionParameters.action_next_hop_v6)
  return action_next_hop_v6_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ActionParameters::set_allocated_action_next_hop_v6(std::string* action_next_hop_v6) {
  if (action_next_hop_v6 != nullptr) {
    
  } else {
    
  }
  action_next_hop_v6_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), action_next_hop_v6,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (action_next_hop_v6_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    action_next_hop_v6_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openoffload.v2.ActionParameters.action_next_hop_v6)
}

// -------------------------------------------------------------------

// SessionRequest

// uint64 session_id = 1;
inline void SessionRequest::clear_session_id() {
  session_id_ = uint64_t{0u};
}
inline uint64_t SessionRequest::_internal_session_id() const {
  return session_id_;
}
inline uint64_t SessionRequest::session_id() const {
  // @@protoc_insertion_point(field_get:openoffload.v2.SessionRequest.session_id)
  return _internal_session_id();
}
inline void SessionRequest::_internal_set_session_id(uint64_t value) {
  
  session_id_ = value;
}
inline void SessionRequest::set_session_id(uint64_t value) {
  _internal_set_session_id(value);
  // @@protoc_insertion_point(field_set:openoffload.v2.SessionRequest.session_id)
}

// int32 in_lif = 2;
inline void SessionRequest::clear_in_lif() {
  in_lif_ = 0;
}
inline int32_t SessionRequest::_internal_in_lif() const {
  return in_lif_;
}
inline int32_t SessionRequest::in_lif() const {
  // @@protoc_insertion_point(field_get:openoffload.v2.SessionRequest.in_lif)
  return _internal_in_lif();
}
inline void SessionRequest::_internal_set_in_lif(int32_t value) {
  
  in_lif_ = value;
}
inline void SessionRequest::set_in_lif(int32_t value) {
  _internal_set_in_lif(value);
  // @@protoc_insertion_point(field_set:openoffload.v2.SessionRequest.in_lif)
}

// int32 out_lif = 3;
inline void SessionRequest::clear_out_lif() {
  out_lif_ = 0;
}
inline int32_t SessionRequest::_internal_out_lif() const {
  return out_lif_;
}
inline int32_t SessionRequest::out_lif() const {
  // @@protoc_insertion_point(field_get:openoffload.v2.SessionRequest.out_lif)
  return _internal_out_lif();
}
inline void SessionRequest::_internal_set_out_lif(int32_t value) {
  
  out_lif_ = value;
}
inline void SessionRequest::set_out_lif(int32_t value) {
  _internal_set_out_lif(value);
  // @@protoc_insertion_point(field_set:openoffload.v2.SessionRequest.out_lif)
}

// .openoffload.v2.IpVersion ip_version = 4;
inline void SessionRequest::clear_ip_version() {
  ip_version_ = 0;
}
inline ::openoffload::v2::IpVersion SessionRequest::_internal_ip_version() const {
  return static_cast< ::openoffload::v2::IpVersion >(ip_version_);
}
inline ::openoffload::v2::IpVersion SessionRequest::ip_version() const {
  // @@protoc_insertion_point(field_get:openoffload.v2.SessionRequest.ip_version)
  return _internal_ip_version();
}
inline void SessionRequest::_internal_set_ip_version(::openoffload::v2::IpVersion value) {
  
  ip_version_ = value;
}
inline void SessionRequest::set_ip_version(::openoffload::v2::IpVersion value) {
  _internal_set_ip_version(value);
  // @@protoc_insertion_point(field_set:openoffload.v2.SessionRequest.ip_version)
}

// uint32 source_ip = 5;
inline void SessionRequest::clear_source_ip() {
  source_ip_ = 0u;
}
inline uint32_t SessionRequest::_internal_source_ip() const {
  return source_ip_;
}
inline uint32_t SessionRequest::source_ip() const {
  // @@protoc_insertion_point(field_get:openoffload.v2.SessionRequest.source_ip)
  return _internal_source_ip();
}
inline void SessionRequest::_internal_set_source_ip(uint32_t value) {
  
  source_ip_ = value;
}
inline void SessionRequest::set_source_ip(uint32_t value) {
  _internal_set_source_ip(value);
  // @@protoc_insertion_point(field_set:openoffload.v2.SessionRequest.source_ip)
}

// bytes source_ipv6 = 6;
inline void SessionRequest::clear_source_ipv6() {
  source_ipv6_.ClearToEmpty();
}
inline const std::string& SessionRequest::source_ipv6() const {
  // @@protoc_insertion_point(field_get:openoffload.v2.SessionRequest.source_ipv6)
  return _internal_source_ipv6();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SessionRequest::set_source_ipv6(ArgT0&& arg0, ArgT... args) {
 
 source_ipv6_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openoffload.v2.SessionRequest.source_ipv6)
}
inline std::string* SessionRequest::mutable_source_ipv6() {
  std::string* _s = _internal_mutable_source_ipv6();
  // @@protoc_insertion_point(field_mutable:openoffload.v2.SessionRequest.source_ipv6)
  return _s;
}
inline const std::string& SessionRequest::_internal_source_ipv6() const {
  return source_ipv6_.Get();
}
inline void SessionRequest::_internal_set_source_ipv6(const std::string& value) {
  
  source_ipv6_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SessionRequest::_internal_mutable_source_ipv6() {
  
  return source_ipv6_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SessionRequest::release_source_ipv6() {
  // @@protoc_insertion_point(field_release:openoffload.v2.SessionRequest.source_ipv6)
  return source_ipv6_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SessionRequest::set_allocated_source_ipv6(std::string* source_ipv6) {
  if (source_ipv6 != nullptr) {
    
  } else {
    
  }
  source_ipv6_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), source_ipv6,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (source_ipv6_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    source_ipv6_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openoffload.v2.SessionRequest.source_ipv6)
}

// uint32 source_port = 7;
inline void SessionRequest::clear_source_port() {
  source_port_ = 0u;
}
inline uint32_t SessionRequest::_internal_source_port() const {
  return source_port_;
}
inline uint32_t SessionRequest::source_port() const {
  // @@protoc_insertion_point(field_get:openoffload.v2.SessionRequest.source_port)
  return _internal_source_port();
}
inline void SessionRequest::_internal_set_source_port(uint32_t value) {
  
  source_port_ = value;
}
inline void SessionRequest::set_source_port(uint32_t value) {
  _internal_set_source_port(value);
  // @@protoc_insertion_point(field_set:openoffload.v2.SessionRequest.source_port)
}

// uint32 destination_ip = 8;
inline void SessionRequest::clear_destination_ip() {
  destination_ip_ = 0u;
}
inline uint32_t SessionRequest::_internal_destination_ip() const {
  return destination_ip_;
}
inline uint32_t SessionRequest::destination_ip() const {
  // @@protoc_insertion_point(field_get:openoffload.v2.SessionRequest.destination_ip)
  return _internal_destination_ip();
}
inline void SessionRequest::_internal_set_destination_ip(uint32_t value) {
  
  destination_ip_ = value;
}
inline void SessionRequest::set_destination_ip(uint32_t value) {
  _internal_set_destination_ip(value);
  // @@protoc_insertion_point(field_set:openoffload.v2.SessionRequest.destination_ip)
}

// bytes destination_ipv6 = 9;
inline void SessionRequest::clear_destination_ipv6() {
  destination_ipv6_.ClearToEmpty();
}
inline const std::string& SessionRequest::destination_ipv6() const {
  // @@protoc_insertion_point(field_get:openoffload.v2.SessionRequest.destination_ipv6)
  return _internal_destination_ipv6();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SessionRequest::set_destination_ipv6(ArgT0&& arg0, ArgT... args) {
 
 destination_ipv6_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openoffload.v2.SessionRequest.destination_ipv6)
}
inline std::string* SessionRequest::mutable_destination_ipv6() {
  std::string* _s = _internal_mutable_destination_ipv6();
  // @@protoc_insertion_point(field_mutable:openoffload.v2.SessionRequest.destination_ipv6)
  return _s;
}
inline const std::string& SessionRequest::_internal_destination_ipv6() const {
  return destination_ipv6_.Get();
}
inline void SessionRequest::_internal_set_destination_ipv6(const std::string& value) {
  
  destination_ipv6_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SessionRequest::_internal_mutable_destination_ipv6() {
  
  return destination_ipv6_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SessionRequest::release_destination_ipv6() {
  // @@protoc_insertion_point(field_release:openoffload.v2.SessionRequest.destination_ipv6)
  return destination_ipv6_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SessionRequest::set_allocated_destination_ipv6(std::string* destination_ipv6) {
  if (destination_ipv6 != nullptr) {
    
  } else {
    
  }
  destination_ipv6_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), destination_ipv6,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (destination_ipv6_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    destination_ipv6_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openoffload.v2.SessionRequest.destination_ipv6)
}

// uint32 destination_port = 10;
inline void SessionRequest::clear_destination_port() {
  destination_port_ = 0u;
}
inline uint32_t SessionRequest::_internal_destination_port() const {
  return destination_port_;
}
inline uint32_t SessionRequest::destination_port() const {
  // @@protoc_insertion_point(field_get:openoffload.v2.SessionRequest.destination_port)
  return _internal_destination_port();
}
inline void SessionRequest::_internal_set_destination_port(uint32_t value) {
  
  destination_port_ = value;
}
inline void SessionRequest::set_destination_port(uint32_t value) {
  _internal_set_destination_port(value);
  // @@protoc_insertion_point(field_set:openoffload.v2.SessionRequest.destination_port)
}

// .openoffload.v2.ProtocolId protocol_id = 11;
inline void SessionRequest::clear_protocol_id() {
  protocol_id_ = 0;
}
inline ::openoffload::v2::ProtocolId SessionRequest::_internal_protocol_id() const {
  return static_cast< ::openoffload::v2::ProtocolId >(protocol_id_);
}
inline ::openoffload::v2::ProtocolId SessionRequest::protocol_id() const {
  // @@protoc_insertion_point(field_get:openoffload.v2.SessionRequest.protocol_id)
  return _internal_protocol_id();
}
inline void SessionRequest::_internal_set_protocol_id(::openoffload::v2::ProtocolId value) {
  
  protocol_id_ = value;
}
inline void SessionRequest::set_protocol_id(::openoffload::v2::ProtocolId value) {
  _internal_set_protocol_id(value);
  // @@protoc_insertion_point(field_set:openoffload.v2.SessionRequest.protocol_id)
}

// .openoffload.v2.ActionParameters action = 12;
inline bool SessionRequest::_internal_has_action() const {
  return this != internal_default_instance() && action_ != nullptr;
}
inline bool SessionRequest::has_action() const {
  return _internal_has_action();
}
inline void SessionRequest::clear_action() {
  if (GetArenaForAllocation() == nullptr && action_ != nullptr) {
    delete action_;
  }
  action_ = nullptr;
}
inline const ::openoffload::v2::ActionParameters& SessionRequest::_internal_action() const {
  const ::openoffload::v2::ActionParameters* p = action_;
  return p != nullptr ? *p : reinterpret_cast<const ::openoffload::v2::ActionParameters&>(
      ::openoffload::v2::_ActionParameters_default_instance_);
}
inline const ::openoffload::v2::ActionParameters& SessionRequest::action() const {
  // @@protoc_insertion_point(field_get:openoffload.v2.SessionRequest.action)
  return _internal_action();
}
inline void SessionRequest::unsafe_arena_set_allocated_action(
    ::openoffload::v2::ActionParameters* action) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(action_);
  }
  action_ = action;
  if (action) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openoffload.v2.SessionRequest.action)
}
inline ::openoffload::v2::ActionParameters* SessionRequest::release_action() {
  
  ::openoffload::v2::ActionParameters* temp = action_;
  action_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::openoffload::v2::ActionParameters* SessionRequest::unsafe_arena_release_action() {
  // @@protoc_insertion_point(field_release:openoffload.v2.SessionRequest.action)
  
  ::openoffload::v2::ActionParameters* temp = action_;
  action_ = nullptr;
  return temp;
}
inline ::openoffload::v2::ActionParameters* SessionRequest::_internal_mutable_action() {
  
  if (action_ == nullptr) {
    auto* p = CreateMaybeMessage<::openoffload::v2::ActionParameters>(GetArenaForAllocation());
    action_ = p;
  }
  return action_;
}
inline ::openoffload::v2::ActionParameters* SessionRequest::mutable_action() {
  ::openoffload::v2::ActionParameters* _msg = _internal_mutable_action();
  // @@protoc_insertion_point(field_mutable:openoffload.v2.SessionRequest.action)
  return _msg;
}
inline void SessionRequest::set_allocated_action(::openoffload::v2::ActionParameters* action) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete action_;
  }
  if (action) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::openoffload::v2::ActionParameters>::GetOwningArena(action);
    if (message_arena != submessage_arena) {
      action = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, action, submessage_arena);
    }
    
  } else {
    
  }
  action_ = action;
  // @@protoc_insertion_point(field_set_allocated:openoffload.v2.SessionRequest.action)
}

// uint32 cache_timeout = 13;
inline void SessionRequest::clear_cache_timeout() {
  cache_timeout_ = 0u;
}
inline uint32_t SessionRequest::_internal_cache_timeout() const {
  return cache_timeout_;
}
inline uint32_t SessionRequest::cache_timeout() const {
  // @@protoc_insertion_point(field_get:openoffload.v2.SessionRequest.cache_timeout)
  return _internal_cache_timeout();
}
inline void SessionRequest::_internal_set_cache_timeout(uint32_t value) {
  
  cache_timeout_ = value;
}
inline void SessionRequest::set_cache_timeout(uint32_t value) {
  _internal_set_cache_timeout(value);
  // @@protoc_insertion_point(field_set:openoffload.v2.SessionRequest.cache_timeout)
}

// -------------------------------------------------------------------

// SessionResponseError

// uint64 session_id = 1;
inline void SessionResponseError::clear_session_id() {
  session_id_ = uint64_t{0u};
}
inline uint64_t SessionResponseError::_internal_session_id() const {
  return session_id_;
}
inline uint64_t SessionResponseError::session_id() const {
  // @@protoc_insertion_point(field_get:openoffload.v2.SessionResponseError.session_id)
  return _internal_session_id();
}
inline void SessionResponseError::_internal_set_session_id(uint64_t value) {
  
  session_id_ = value;
}
inline void SessionResponseError::set_session_id(uint64_t value) {
  _internal_set_session_id(value);
  // @@protoc_insertion_point(field_set:openoffload.v2.SessionResponseError.session_id)
}

// int32 error_status = 2;
inline void SessionResponseError::clear_error_status() {
  error_status_ = 0;
}
inline int32_t SessionResponseError::_internal_error_status() const {
  return error_status_;
}
inline int32_t SessionResponseError::error_status() const {
  // @@protoc_insertion_point(field_get:openoffload.v2.SessionResponseError.error_status)
  return _internal_error_status();
}
inline void SessionResponseError::_internal_set_error_status(int32_t value) {
  
  error_status_ = value;
}
inline void SessionResponseError::set_error_status(int32_t value) {
  _internal_set_error_status(value);
  // @@protoc_insertion_point(field_set:openoffload.v2.SessionResponseError.error_status)
}

// -------------------------------------------------------------------

// SessionResponses

// repeated .openoffload.v2.SessionResponse session_info = 1;
inline int SessionResponses::_internal_session_info_size() const {
  return session_info_.size();
}
inline int SessionResponses::session_info_size() const {
  return _internal_session_info_size();
}
inline void SessionResponses::clear_session_info() {
  session_info_.Clear();
}
inline ::openoffload::v2::SessionResponse* SessionResponses::mutable_session_info(int index) {
  // @@protoc_insertion_point(field_mutable:openoffload.v2.SessionResponses.session_info)
  return session_info_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openoffload::v2::SessionResponse >*
SessionResponses::mutable_session_info() {
  // @@protoc_insertion_point(field_mutable_list:openoffload.v2.SessionResponses.session_info)
  return &session_info_;
}
inline const ::openoffload::v2::SessionResponse& SessionResponses::_internal_session_info(int index) const {
  return session_info_.Get(index);
}
inline const ::openoffload::v2::SessionResponse& SessionResponses::session_info(int index) const {
  // @@protoc_insertion_point(field_get:openoffload.v2.SessionResponses.session_info)
  return _internal_session_info(index);
}
inline ::openoffload::v2::SessionResponse* SessionResponses::_internal_add_session_info() {
  return session_info_.Add();
}
inline ::openoffload::v2::SessionResponse* SessionResponses::add_session_info() {
  ::openoffload::v2::SessionResponse* _add = _internal_add_session_info();
  // @@protoc_insertion_point(field_add:openoffload.v2.SessionResponses.session_info)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openoffload::v2::SessionResponse >&
SessionResponses::session_info() const {
  // @@protoc_insertion_point(field_list:openoffload.v2.SessionResponses.session_info)
  return session_info_;
}

// uint64 next_key = 2;
inline void SessionResponses::clear_next_key() {
  next_key_ = uint64_t{0u};
}
inline uint64_t SessionResponses::_internal_next_key() const {
  return next_key_;
}
inline uint64_t SessionResponses::next_key() const {
  // @@protoc_insertion_point(field_get:openoffload.v2.SessionResponses.next_key)
  return _internal_next_key();
}
inline void SessionResponses::_internal_set_next_key(uint64_t value) {
  
  next_key_ = value;
}
inline void SessionResponses::set_next_key(uint64_t value) {
  _internal_set_next_key(value);
  // @@protoc_insertion_point(field_set:openoffload.v2.SessionResponses.next_key)
}

// -------------------------------------------------------------------

// AddSessionResponse

// .openoffload.v2.AddSessionStatus request_status = 1;
inline void AddSessionResponse::clear_request_status() {
  request_status_ = 0;
}
inline ::openoffload::v2::AddSessionStatus AddSessionResponse::_internal_request_status() const {
  return static_cast< ::openoffload::v2::AddSessionStatus >(request_status_);
}
inline ::openoffload::v2::AddSessionStatus AddSessionResponse::request_status() const {
  // @@protoc_insertion_point(field_get:openoffload.v2.AddSessionResponse.request_status)
  return _internal_request_status();
}
inline void AddSessionResponse::_internal_set_request_status(::openoffload::v2::AddSessionStatus value) {
  
  request_status_ = value;
}
inline void AddSessionResponse::set_request_status(::openoffload::v2::AddSessionStatus value) {
  _internal_set_request_status(value);
  // @@protoc_insertion_point(field_set:openoffload.v2.AddSessionResponse.request_status)
}

// uint64 error_status = 2;
inline void AddSessionResponse::clear_error_status() {
  error_status_ = uint64_t{0u};
}
inline uint64_t AddSessionResponse::_internal_error_status() const {
  return error_status_;
}
inline uint64_t AddSessionResponse::error_status() const {
  // @@protoc_insertion_point(field_get:openoffload.v2.AddSessionResponse.error_status)
  return _internal_error_status();
}
inline void AddSessionResponse::_internal_set_error_status(uint64_t value) {
  
  error_status_ = value;
}
inline void AddSessionResponse::set_error_status(uint64_t value) {
  _internal_set_error_status(value);
  // @@protoc_insertion_point(field_set:openoffload.v2.AddSessionResponse.error_status)
}

// .google.protobuf.Timestamp start_time = 3;
inline bool AddSessionResponse::_internal_has_start_time() const {
  return this != internal_default_instance() && start_time_ != nullptr;
}
inline bool AddSessionResponse::has_start_time() const {
  return _internal_has_start_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& AddSessionResponse::_internal_start_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = start_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& AddSessionResponse::start_time() const {
  // @@protoc_insertion_point(field_get:openoffload.v2.AddSessionResponse.start_time)
  return _internal_start_time();
}
inline void AddSessionResponse::unsafe_arena_set_allocated_start_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* start_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(start_time_);
  }
  start_time_ = start_time;
  if (start_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openoffload.v2.AddSessionResponse.start_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* AddSessionResponse::release_start_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = start_time_;
  start_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* AddSessionResponse::unsafe_arena_release_start_time() {
  // @@protoc_insertion_point(field_release:openoffload.v2.AddSessionResponse.start_time)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = start_time_;
  start_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* AddSessionResponse::_internal_mutable_start_time() {
  
  if (start_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    start_time_ = p;
  }
  return start_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* AddSessionResponse::mutable_start_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_start_time();
  // @@protoc_insertion_point(field_mutable:openoffload.v2.AddSessionResponse.start_time)
  return _msg;
}
inline void AddSessionResponse::set_allocated_start_time(::PROTOBUF_NAMESPACE_ID::Timestamp* start_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(start_time_);
  }
  if (start_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(start_time));
    if (message_arena != submessage_arena) {
      start_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, start_time, submessage_arena);
    }
    
  } else {
    
  }
  start_time_ = start_time;
  // @@protoc_insertion_point(field_set_allocated:openoffload.v2.AddSessionResponse.start_time)
}

// repeated .openoffload.v2.SessionResponseError response_error = 4;
inline int AddSessionResponse::_internal_response_error_size() const {
  return response_error_.size();
}
inline int AddSessionResponse::response_error_size() const {
  return _internal_response_error_size();
}
inline void AddSessionResponse::clear_response_error() {
  response_error_.Clear();
}
inline ::openoffload::v2::SessionResponseError* AddSessionResponse::mutable_response_error(int index) {
  // @@protoc_insertion_point(field_mutable:openoffload.v2.AddSessionResponse.response_error)
  return response_error_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openoffload::v2::SessionResponseError >*
AddSessionResponse::mutable_response_error() {
  // @@protoc_insertion_point(field_mutable_list:openoffload.v2.AddSessionResponse.response_error)
  return &response_error_;
}
inline const ::openoffload::v2::SessionResponseError& AddSessionResponse::_internal_response_error(int index) const {
  return response_error_.Get(index);
}
inline const ::openoffload::v2::SessionResponseError& AddSessionResponse::response_error(int index) const {
  // @@protoc_insertion_point(field_get:openoffload.v2.AddSessionResponse.response_error)
  return _internal_response_error(index);
}
inline ::openoffload::v2::SessionResponseError* AddSessionResponse::_internal_add_response_error() {
  return response_error_.Add();
}
inline ::openoffload::v2::SessionResponseError* AddSessionResponse::add_response_error() {
  ::openoffload::v2::SessionResponseError* _add = _internal_add_response_error();
  // @@protoc_insertion_point(field_add:openoffload.v2.AddSessionResponse.response_error)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openoffload::v2::SessionResponseError >&
AddSessionResponse::response_error() const {
  // @@protoc_insertion_point(field_list:openoffload.v2.AddSessionResponse.response_error)
  return response_error_;
}

// -------------------------------------------------------------------

// SessionResponse

// uint64 session_id = 1;
inline void SessionResponse::clear_session_id() {
  session_id_ = uint64_t{0u};
}
inline uint64_t SessionResponse::_internal_session_id() const {
  return session_id_;
}
inline uint64_t SessionResponse::session_id() const {
  // @@protoc_insertion_point(field_get:openoffload.v2.SessionResponse.session_id)
  return _internal_session_id();
}
inline void SessionResponse::_internal_set_session_id(uint64_t value) {
  
  session_id_ = value;
}
inline void SessionResponse::set_session_id(uint64_t value) {
  _internal_set_session_id(value);
  // @@protoc_insertion_point(field_set:openoffload.v2.SessionResponse.session_id)
}

// uint64 in_packets = 2;
inline void SessionResponse::clear_in_packets() {
  in_packets_ = uint64_t{0u};
}
inline uint64_t SessionResponse::_internal_in_packets() const {
  return in_packets_;
}
inline uint64_t SessionResponse::in_packets() const {
  // @@protoc_insertion_point(field_get:openoffload.v2.SessionResponse.in_packets)
  return _internal_in_packets();
}
inline void SessionResponse::_internal_set_in_packets(uint64_t value) {
  
  in_packets_ = value;
}
inline void SessionResponse::set_in_packets(uint64_t value) {
  _internal_set_in_packets(value);
  // @@protoc_insertion_point(field_set:openoffload.v2.SessionResponse.in_packets)
}

// uint64 out_packets = 3;
inline void SessionResponse::clear_out_packets() {
  out_packets_ = uint64_t{0u};
}
inline uint64_t SessionResponse::_internal_out_packets() const {
  return out_packets_;
}
inline uint64_t SessionResponse::out_packets() const {
  // @@protoc_insertion_point(field_get:openoffload.v2.SessionResponse.out_packets)
  return _internal_out_packets();
}
inline void SessionResponse::_internal_set_out_packets(uint64_t value) {
  
  out_packets_ = value;
}
inline void SessionResponse::set_out_packets(uint64_t value) {
  _internal_set_out_packets(value);
  // @@protoc_insertion_point(field_set:openoffload.v2.SessionResponse.out_packets)
}

// uint64 in_bytes = 4;
inline void SessionResponse::clear_in_bytes() {
  in_bytes_ = uint64_t{0u};
}
inline uint64_t SessionResponse::_internal_in_bytes() const {
  return in_bytes_;
}
inline uint64_t SessionResponse::in_bytes() const {
  // @@protoc_insertion_point(field_get:openoffload.v2.SessionResponse.in_bytes)
  return _internal_in_bytes();
}
inline void SessionResponse::_internal_set_in_bytes(uint64_t value) {
  
  in_bytes_ = value;
}
inline void SessionResponse::set_in_bytes(uint64_t value) {
  _internal_set_in_bytes(value);
  // @@protoc_insertion_point(field_set:openoffload.v2.SessionResponse.in_bytes)
}

// uint64 out_bytes = 5;
inline void SessionResponse::clear_out_bytes() {
  out_bytes_ = uint64_t{0u};
}
inline uint64_t SessionResponse::_internal_out_bytes() const {
  return out_bytes_;
}
inline uint64_t SessionResponse::out_bytes() const {
  // @@protoc_insertion_point(field_get:openoffload.v2.SessionResponse.out_bytes)
  return _internal_out_bytes();
}
inline void SessionResponse::_internal_set_out_bytes(uint64_t value) {
  
  out_bytes_ = value;
}
inline void SessionResponse::set_out_bytes(uint64_t value) {
  _internal_set_out_bytes(value);
  // @@protoc_insertion_point(field_set:openoffload.v2.SessionResponse.out_bytes)
}

// .openoffload.v2.SessionState session_state = 6;
inline void SessionResponse::clear_session_state() {
  session_state_ = 0;
}
inline ::openoffload::v2::SessionState SessionResponse::_internal_session_state() const {
  return static_cast< ::openoffload::v2::SessionState >(session_state_);
}
inline ::openoffload::v2::SessionState SessionResponse::session_state() const {
  // @@protoc_insertion_point(field_get:openoffload.v2.SessionResponse.session_state)
  return _internal_session_state();
}
inline void SessionResponse::_internal_set_session_state(::openoffload::v2::SessionState value) {
  
  session_state_ = value;
}
inline void SessionResponse::set_session_state(::openoffload::v2::SessionState value) {
  _internal_set_session_state(value);
  // @@protoc_insertion_point(field_set:openoffload.v2.SessionResponse.session_state)
}

// .openoffload.v2.SessionCloseCode session_close_code = 7;
inline void SessionResponse::clear_session_close_code() {
  session_close_code_ = 0;
}
inline ::openoffload::v2::SessionCloseCode SessionResponse::_internal_session_close_code() const {
  return static_cast< ::openoffload::v2::SessionCloseCode >(session_close_code_);
}
inline ::openoffload::v2::SessionCloseCode SessionResponse::session_close_code() const {
  // @@protoc_insertion_point(field_get:openoffload.v2.SessionResponse.session_close_code)
  return _internal_session_close_code();
}
inline void SessionResponse::_internal_set_session_close_code(::openoffload::v2::SessionCloseCode value) {
  
  session_close_code_ = value;
}
inline void SessionResponse::set_session_close_code(::openoffload::v2::SessionCloseCode value) {
  _internal_set_session_close_code(value);
  // @@protoc_insertion_point(field_set:openoffload.v2.SessionResponse.session_close_code)
}

// .openoffload.v2.RequestStatus request_status = 8;
inline void SessionResponse::clear_request_status() {
  request_status_ = 0;
}
inline ::openoffload::v2::RequestStatus SessionResponse::_internal_request_status() const {
  return static_cast< ::openoffload::v2::RequestStatus >(request_status_);
}
inline ::openoffload::v2::RequestStatus SessionResponse::request_status() const {
  // @@protoc_insertion_point(field_get:openoffload.v2.SessionResponse.request_status)
  return _internal_request_status();
}
inline void SessionResponse::_internal_set_request_status(::openoffload::v2::RequestStatus value) {
  
  request_status_ = value;
}
inline void SessionResponse::set_request_status(::openoffload::v2::RequestStatus value) {
  _internal_set_request_status(value);
  // @@protoc_insertion_point(field_set:openoffload.v2.SessionResponse.request_status)
}

// .google.protobuf.Timestamp start_time = 9;
inline bool SessionResponse::_internal_has_start_time() const {
  return this != internal_default_instance() && start_time_ != nullptr;
}
inline bool SessionResponse::has_start_time() const {
  return _internal_has_start_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& SessionResponse::_internal_start_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = start_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& SessionResponse::start_time() const {
  // @@protoc_insertion_point(field_get:openoffload.v2.SessionResponse.start_time)
  return _internal_start_time();
}
inline void SessionResponse::unsafe_arena_set_allocated_start_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* start_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(start_time_);
  }
  start_time_ = start_time;
  if (start_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openoffload.v2.SessionResponse.start_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SessionResponse::release_start_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = start_time_;
  start_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SessionResponse::unsafe_arena_release_start_time() {
  // @@protoc_insertion_point(field_release:openoffload.v2.SessionResponse.start_time)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = start_time_;
  start_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SessionResponse::_internal_mutable_start_time() {
  
  if (start_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    start_time_ = p;
  }
  return start_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SessionResponse::mutable_start_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_start_time();
  // @@protoc_insertion_point(field_mutable:openoffload.v2.SessionResponse.start_time)
  return _msg;
}
inline void SessionResponse::set_allocated_start_time(::PROTOBUF_NAMESPACE_ID::Timestamp* start_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(start_time_);
  }
  if (start_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(start_time));
    if (message_arena != submessage_arena) {
      start_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, start_time, submessage_arena);
    }
    
  } else {
    
  }
  start_time_ = start_time;
  // @@protoc_insertion_point(field_set_allocated:openoffload.v2.SessionResponse.start_time)
}

// .google.protobuf.Timestamp end_time = 10;
inline bool SessionResponse::_internal_has_end_time() const {
  return this != internal_default_instance() && end_time_ != nullptr;
}
inline bool SessionResponse::has_end_time() const {
  return _internal_has_end_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& SessionResponse::_internal_end_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = end_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& SessionResponse::end_time() const {
  // @@protoc_insertion_point(field_get:openoffload.v2.SessionResponse.end_time)
  return _internal_end_time();
}
inline void SessionResponse::unsafe_arena_set_allocated_end_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* end_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(end_time_);
  }
  end_time_ = end_time;
  if (end_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openoffload.v2.SessionResponse.end_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SessionResponse::release_end_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = end_time_;
  end_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SessionResponse::unsafe_arena_release_end_time() {
  // @@protoc_insertion_point(field_release:openoffload.v2.SessionResponse.end_time)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = end_time_;
  end_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SessionResponse::_internal_mutable_end_time() {
  
  if (end_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    end_time_ = p;
  }
  return end_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SessionResponse::mutable_end_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_end_time();
  // @@protoc_insertion_point(field_mutable:openoffload.v2.SessionResponse.end_time)
  return _msg;
}
inline void SessionResponse::set_allocated_end_time(::PROTOBUF_NAMESPACE_ID::Timestamp* end_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(end_time_);
  }
  if (end_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(end_time));
    if (message_arena != submessage_arena) {
      end_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, end_time, submessage_arena);
    }
    
  } else {
    
  }
  end_time_ = end_time;
  // @@protoc_insertion_point(field_set_allocated:openoffload.v2.SessionResponse.end_time)
}

// -------------------------------------------------------------------

// SessionRequestArgs

// uint32 page_size = 1;
inline void SessionRequestArgs::clear_page_size() {
  page_size_ = 0u;
}
inline uint32_t SessionRequestArgs::_internal_page_size() const {
  return page_size_;
}
inline uint32_t SessionRequestArgs::page_size() const {
  // @@protoc_insertion_point(field_get:openoffload.v2.SessionRequestArgs.page_size)
  return _internal_page_size();
}
inline void SessionRequestArgs::_internal_set_page_size(uint32_t value) {
  
  page_size_ = value;
}
inline void SessionRequestArgs::set_page_size(uint32_t value) {
  _internal_set_page_size(value);
  // @@protoc_insertion_point(field_set:openoffload.v2.SessionRequestArgs.page_size)
}

// uint32 page = 2;
inline void SessionRequestArgs::clear_page() {
  page_ = 0u;
}
inline uint32_t SessionRequestArgs::_internal_page() const {
  return page_;
}
inline uint32_t SessionRequestArgs::page() const {
  // @@protoc_insertion_point(field_get:openoffload.v2.SessionRequestArgs.page)
  return _internal_page();
}
inline void SessionRequestArgs::_internal_set_page(uint32_t value) {
  
  page_ = value;
}
inline void SessionRequestArgs::set_page(uint32_t value) {
  _internal_set_page(value);
  // @@protoc_insertion_point(field_set:openoffload.v2.SessionRequestArgs.page)
}

// uint64 start_session = 3;
inline void SessionRequestArgs::clear_start_session() {
  start_session_ = uint64_t{0u};
}
inline uint64_t SessionRequestArgs::_internal_start_session() const {
  return start_session_;
}
inline uint64_t SessionRequestArgs::start_session() const {
  // @@protoc_insertion_point(field_get:openoffload.v2.SessionRequestArgs.start_session)
  return _internal_start_session();
}
inline void SessionRequestArgs::_internal_set_start_session(uint64_t value) {
  
  start_session_ = value;
}
inline void SessionRequestArgs::set_start_session(uint64_t value) {
  _internal_set_start_session(value);
  // @@protoc_insertion_point(field_set:openoffload.v2.SessionRequestArgs.start_session)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v2
}  // namespace openoffload

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::openoffload::v2::IpVersion> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::openoffload::v2::IpVersion>() {
  return ::openoffload::v2::IpVersion_descriptor();
}
template <> struct is_proto_enum< ::openoffload::v2::ProtocolId> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::openoffload::v2::ProtocolId>() {
  return ::openoffload::v2::ProtocolId_descriptor();
}
template <> struct is_proto_enum< ::openoffload::v2::SessionState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::openoffload::v2::SessionState>() {
  return ::openoffload::v2::SessionState_descriptor();
}
template <> struct is_proto_enum< ::openoffload::v2::SessionCloseCode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::openoffload::v2::SessionCloseCode>() {
  return ::openoffload::v2::SessionCloseCode_descriptor();
}
template <> struct is_proto_enum< ::openoffload::v2::AddSessionStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::openoffload::v2::AddSessionStatus>() {
  return ::openoffload::v2::AddSessionStatus_descriptor();
}
template <> struct is_proto_enum< ::openoffload::v2::RequestStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::openoffload::v2::RequestStatus>() {
  return ::openoffload::v2::RequestStatus_descriptor();
}
template <> struct is_proto_enum< ::openoffload::v2::ActionType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::openoffload::v2::ActionType>() {
  return ::openoffload::v2::ActionType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_openoffload_2eproto
