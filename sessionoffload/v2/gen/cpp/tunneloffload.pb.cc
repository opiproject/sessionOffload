// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tunneloffload.proto

#include "tunneloffload.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG
namespace tunneloffload {
namespace v1alpha1 {
constexpr CapabilityRequest::CapabilityRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct CapabilityRequestDefaultTypeInternal {
  constexpr CapabilityRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CapabilityRequestDefaultTypeInternal() {}
  union {
    CapabilityRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CapabilityRequestDefaultTypeInternal _CapabilityRequest_default_instance_;
constexpr CapabilityResponse_MatchCapabilities::CapabilityResponse_MatchCapabilities(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : ingress_interface_matching_(false)
  , vxlan_matching_(false)
  , geneve_matching_(false)
  , tunnel_matching_(false)
  , spi_matching_(false){}
struct CapabilityResponse_MatchCapabilitiesDefaultTypeInternal {
  constexpr CapabilityResponse_MatchCapabilitiesDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CapabilityResponse_MatchCapabilitiesDefaultTypeInternal() {}
  union {
    CapabilityResponse_MatchCapabilities _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CapabilityResponse_MatchCapabilitiesDefaultTypeInternal _CapabilityResponse_MatchCapabilities_default_instance_;
constexpr CapabilityResponse_IPSecCapabilities::CapabilityResponse_IPSecCapabilities(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : tunnel_type_supported_()
  , _tunnel_type_supported_cached_byte_size_(0)
  , encryption_supported_()
  , _encryption_supported_cached_byte_size_(0){}
struct CapabilityResponse_IPSecCapabilitiesDefaultTypeInternal {
  constexpr CapabilityResponse_IPSecCapabilitiesDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CapabilityResponse_IPSecCapabilitiesDefaultTypeInternal() {}
  union {
    CapabilityResponse_IPSecCapabilities _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CapabilityResponse_IPSecCapabilitiesDefaultTypeInternal _CapabilityResponse_IPSecCapabilities_default_instance_;
constexpr CapabilityResponse_GeneveCapabilities::CapabilityResponse_GeneveCapabilities(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : number_geneve_options_supported_(0u){}
struct CapabilityResponse_GeneveCapabilitiesDefaultTypeInternal {
  constexpr CapabilityResponse_GeneveCapabilitiesDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CapabilityResponse_GeneveCapabilitiesDefaultTypeInternal() {}
  union {
    CapabilityResponse_GeneveCapabilities _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CapabilityResponse_GeneveCapabilitiesDefaultTypeInternal _CapabilityResponse_GeneveCapabilities_default_instance_;
constexpr CapabilityResponse::CapabilityResponse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : match_capabilities_(nullptr)
  , ipsec_capabilities_(nullptr)
  , geneve_capabilities_(nullptr){}
struct CapabilityResponseDefaultTypeInternal {
  constexpr CapabilityResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CapabilityResponseDefaultTypeInternal() {}
  union {
    CapabilityResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CapabilityResponseDefaultTypeInternal _CapabilityResponse_default_instance_;
constexpr TunnelAdditionError::TunnelAdditionError(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : match_error_(0)

  , tunnel_error_(0)

  , ipsec_error_(0)

  , geneve_error_(0)
{}
struct TunnelAdditionErrorDefaultTypeInternal {
  constexpr TunnelAdditionErrorDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~TunnelAdditionErrorDefaultTypeInternal() {}
  union {
    TunnelAdditionError _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT TunnelAdditionErrorDefaultTypeInternal _TunnelAdditionError_default_instance_;
constexpr MatchCriteria_IPSecMatch::MatchCriteria_IPSecMatch(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : spi_(0u)
  , sn_(0u){}
struct MatchCriteria_IPSecMatchDefaultTypeInternal {
  constexpr MatchCriteria_IPSecMatchDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~MatchCriteria_IPSecMatchDefaultTypeInternal() {}
  union {
    MatchCriteria_IPSecMatch _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT MatchCriteria_IPSecMatchDefaultTypeInternal _MatchCriteria_IPSecMatch_default_instance_;
constexpr MatchCriteria_GeneveMatch::MatchCriteria_GeneveMatch(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : mac_match_(nullptr)
  , vni_(0u)
  , protocol_type_(0u)
  , _oneof_case_{}{}
struct MatchCriteria_GeneveMatchDefaultTypeInternal {
  constexpr MatchCriteria_GeneveMatchDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~MatchCriteria_GeneveMatchDefaultTypeInternal() {}
  union {
    MatchCriteria_GeneveMatch _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT MatchCriteria_GeneveMatchDefaultTypeInternal _MatchCriteria_GeneveMatch_default_instance_;
constexpr MatchCriteria_VXLanMatch::MatchCriteria_VXLanMatch(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : mac_match_(nullptr)
  , vni_(0u)
  , _oneof_case_{}{}
struct MatchCriteria_VXLanMatchDefaultTypeInternal {
  constexpr MatchCriteria_VXLanMatchDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~MatchCriteria_VXLanMatchDefaultTypeInternal() {}
  union {
    MatchCriteria_VXLanMatch _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT MatchCriteria_VXLanMatchDefaultTypeInternal _MatchCriteria_VXLanMatch_default_instance_;
constexpr MatchCriteria::MatchCriteria(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : ingress_interface_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , mac_match_(nullptr)
  , tunnel_id_(uint64_t{0u})
  , _oneof_case_{}{}
struct MatchCriteriaDefaultTypeInternal {
  constexpr MatchCriteriaDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~MatchCriteriaDefaultTypeInternal() {}
  union {
    MatchCriteria _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT MatchCriteriaDefaultTypeInternal _MatchCriteria_default_instance_;
constexpr IpTunnelRequest::IpTunnelRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : match_criteria_(nullptr)
  , tunnel_id_(uint64_t{0u})
  , operation_(0)

  , next_action_(0)

  , _oneof_case_{}{}
struct IpTunnelRequestDefaultTypeInternal {
  constexpr IpTunnelRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~IpTunnelRequestDefaultTypeInternal() {}
  union {
    IpTunnelRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT IpTunnelRequestDefaultTypeInternal _IpTunnelRequest_default_instance_;
constexpr Geneve::Geneve(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : _oneof_case_{}{}
struct GeneveDefaultTypeInternal {
  constexpr GeneveDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~GeneveDefaultTypeInternal() {}
  union {
    Geneve _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT GeneveDefaultTypeInternal _Geneve_default_instance_;
constexpr GeneveOption::GeneveOption(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : data_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , option_class_(0u)
  , type_(0u)
  , length_(0u){}
struct GeneveOptionDefaultTypeInternal {
  constexpr GeneveOptionDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~GeneveOptionDefaultTypeInternal() {}
  union {
    GeneveOption _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT GeneveOptionDefaultTypeInternal _GeneveOption_default_instance_;
constexpr GeneveEncap::GeneveEncap(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : geneve_option_()
  , inner_mac_pair_(nullptr)
  , option_length_(0u)
  , control_packet_(false)
  , critical_option_present_(false)
  , vni_(0u)
  , protocol_type_(0u)
  , _oneof_case_{}{}
struct GeneveEncapDefaultTypeInternal {
  constexpr GeneveEncapDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~GeneveEncapDefaultTypeInternal() {}
  union {
    GeneveEncap _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT GeneveEncapDefaultTypeInternal _GeneveEncap_default_instance_;
constexpr GeneveDecap::GeneveDecap(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct GeneveDecapDefaultTypeInternal {
  constexpr GeneveDecapDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~GeneveDecapDefaultTypeInternal() {}
  union {
    GeneveDecap _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT GeneveDecapDefaultTypeInternal _GeneveDecap_default_instance_;
constexpr MacPair::MacPair(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : destination_mac_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , source_mac_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct MacPairDefaultTypeInternal {
  constexpr MacPairDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~MacPairDefaultTypeInternal() {}
  union {
    MacPair _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT MacPairDefaultTypeInternal _MacPair_default_instance_;
constexpr IPV4Pair::IPV4Pair(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : source_ip_(0u)
  , destination_ip_(0u){}
struct IPV4PairDefaultTypeInternal {
  constexpr IPV4PairDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~IPV4PairDefaultTypeInternal() {}
  union {
    IPV4Pair _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT IPV4PairDefaultTypeInternal _IPV4Pair_default_instance_;
constexpr IPV6Pair::IPV6Pair(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : source_ip_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , destination_ip_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct IPV6PairDefaultTypeInternal {
  constexpr IPV6PairDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~IPV6PairDefaultTypeInternal() {}
  union {
    IPV6Pair _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT IPV6PairDefaultTypeInternal _IPV6Pair_default_instance_;
constexpr IPV4Match::IPV4Match(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : source_ip_(0u)
  , source_ip_prefix_(0u)
  , destination_ip_(0u)
  , destination_ip_prefix_(0u){}
struct IPV4MatchDefaultTypeInternal {
  constexpr IPV4MatchDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~IPV4MatchDefaultTypeInternal() {}
  union {
    IPV4Match _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT IPV4MatchDefaultTypeInternal _IPV4Match_default_instance_;
constexpr IPV6Match::IPV6Match(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : source_ip_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , destination_ip_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , source_ip_prefix_(0u)
  , destination_ip_prefix_(0u){}
struct IPV6MatchDefaultTypeInternal {
  constexpr IPV6MatchDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~IPV6MatchDefaultTypeInternal() {}
  union {
    IPV6Match _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT IPV6MatchDefaultTypeInternal _IPV6Match_default_instance_;
constexpr Nat::Nat(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : source_ip_(0u){}
struct NatDefaultTypeInternal {
  constexpr NatDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~NatDefaultTypeInternal() {}
  union {
    Nat _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT NatDefaultTypeInternal _Nat_default_instance_;
constexpr IPSecEnc::IPSecEnc(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : ipsec_sa_(nullptr)
  , tunnel_type_(0)

  , encryption_type_(0)

  , _oneof_case_{}{}
struct IPSecEncDefaultTypeInternal {
  constexpr IPSecEncDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~IPSecEncDefaultTypeInternal() {}
  union {
    IPSecEnc _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT IPSecEncDefaultTypeInternal _IPSecEnc_default_instance_;
constexpr IPSecDec::IPSecDec(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : ipsec_sas_()
  , tunnel_type_(0)

  , encryption_type_(0)
{}
struct IPSecDecDefaultTypeInternal {
  constexpr IPSecDecDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~IPSecDecDefaultTypeInternal() {}
  union {
    IPSecDec _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT IPSecDecDefaultTypeInternal _IPSecDec_default_instance_;
constexpr IPSecSAParams::IPSecSAParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : encryption_key_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , spi_(0u)
  , operation_(0)
{}
struct IPSecSAParamsDefaultTypeInternal {
  constexpr IPSecSAParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~IPSecSAParamsDefaultTypeInternal() {}
  union {
    IPSecSAParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT IPSecSAParamsDefaultTypeInternal _IPSecSAParams_default_instance_;
constexpr IPSecTunnel::IPSecTunnel(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : _oneof_case_{}{}
struct IPSecTunnelDefaultTypeInternal {
  constexpr IPSecTunnelDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~IPSecTunnelDefaultTypeInternal() {}
  union {
    IPSecTunnel _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT IPSecTunnelDefaultTypeInternal _IPSecTunnel_default_instance_;
constexpr TunnelId::TunnelId(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : tunnel_id_(uint64_t{0u}){}
struct TunnelIdDefaultTypeInternal {
  constexpr TunnelIdDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~TunnelIdDefaultTypeInternal() {}
  union {
    TunnelId _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT TunnelIdDefaultTypeInternal _TunnelId_default_instance_;
constexpr Counters::Counters(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : in_packets_(uint64_t{0u})
  , out_packets_(uint64_t{0u})
  , in_bytes_(uint64_t{0u})
  , out_bytes_(uint64_t{0u})
  , in_packets_drops_(uint64_t{0u})
  , out_packets_drops_(uint64_t{0u})
  , in_bytes_drops_(uint64_t{0u})
  , out_bytes_drops_(uint64_t{0u}){}
struct CountersDefaultTypeInternal {
  constexpr CountersDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CountersDefaultTypeInternal() {}
  union {
    Counters _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CountersDefaultTypeInternal _Counters_default_instance_;
constexpr CreateIpTunnelResponses::CreateIpTunnelResponses(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : responses_()
  , error_status_(uint64_t{0u})
  , request_status_(0)
{}
struct CreateIpTunnelResponsesDefaultTypeInternal {
  constexpr CreateIpTunnelResponsesDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CreateIpTunnelResponsesDefaultTypeInternal() {}
  union {
    CreateIpTunnelResponses _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CreateIpTunnelResponsesDefaultTypeInternal _CreateIpTunnelResponses_default_instance_;
constexpr CreateIpTunnelResponse::CreateIpTunnelResponse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : error_(nullptr)
  , tunnel_id_(uint64_t{0u}){}
struct CreateIpTunnelResponseDefaultTypeInternal {
  constexpr CreateIpTunnelResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CreateIpTunnelResponseDefaultTypeInternal() {}
  union {
    CreateIpTunnelResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CreateIpTunnelResponseDefaultTypeInternal _CreateIpTunnelResponse_default_instance_;
constexpr Error::Error(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : error_string_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , error_message_(nullptr){}
struct ErrorDefaultTypeInternal {
  constexpr ErrorDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ErrorDefaultTypeInternal() {}
  union {
    Error _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ErrorDefaultTypeInternal _Error_default_instance_;
constexpr IpTunnelResponses::IpTunnelResponses(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : responses_(){}
struct IpTunnelResponsesDefaultTypeInternal {
  constexpr IpTunnelResponsesDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~IpTunnelResponsesDefaultTypeInternal() {}
  union {
    IpTunnelResponses _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT IpTunnelResponsesDefaultTypeInternal _IpTunnelResponses_default_instance_;
constexpr IpTunnelResponse::IpTunnelResponse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : ip_tunnel_(nullptr)
  , tunnel_counters_(nullptr)
  , error_(nullptr)
  , tunnel_id_(uint64_t{0u}){}
struct IpTunnelResponseDefaultTypeInternal {
  constexpr IpTunnelResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~IpTunnelResponseDefaultTypeInternal() {}
  union {
    IpTunnelResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT IpTunnelResponseDefaultTypeInternal _IpTunnelResponse_default_instance_;
constexpr IpTunnelStatsResponses::IpTunnelStatsResponses(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : responses_(){}
struct IpTunnelStatsResponsesDefaultTypeInternal {
  constexpr IpTunnelStatsResponsesDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~IpTunnelStatsResponsesDefaultTypeInternal() {}
  union {
    IpTunnelStatsResponses _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT IpTunnelStatsResponsesDefaultTypeInternal _IpTunnelStatsResponses_default_instance_;
constexpr IpTunnelStatsResponse::IpTunnelStatsResponse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : tunnel_counters_(nullptr)
  , error_(nullptr)
  , tunnel_id_(uint64_t{0u}){}
struct IpTunnelStatsResponseDefaultTypeInternal {
  constexpr IpTunnelStatsResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~IpTunnelStatsResponseDefaultTypeInternal() {}
  union {
    IpTunnelStatsResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT IpTunnelStatsResponseDefaultTypeInternal _IpTunnelStatsResponse_default_instance_;
constexpr TunnelRequestArgs::TunnelRequestArgs(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : tunnels_per_request_(0u){}
struct TunnelRequestArgsDefaultTypeInternal {
  constexpr TunnelRequestArgsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~TunnelRequestArgsDefaultTypeInternal() {}
  union {
    TunnelRequestArgs _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT TunnelRequestArgsDefaultTypeInternal _TunnelRequestArgs_default_instance_;
}  // namespace v1alpha1
}  // namespace tunneloffload
static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_tunneloffload_2eproto[35];
static const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* file_level_enum_descriptors_tunneloffload_2eproto[9];
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_tunneloffload_2eproto = nullptr;

const uint32_t TableStruct_tunneloffload_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::CapabilityRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::CapabilityResponse_MatchCapabilities, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::CapabilityResponse_MatchCapabilities, ingress_interface_matching_),
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::CapabilityResponse_MatchCapabilities, vxlan_matching_),
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::CapabilityResponse_MatchCapabilities, geneve_matching_),
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::CapabilityResponse_MatchCapabilities, tunnel_matching_),
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::CapabilityResponse_MatchCapabilities, spi_matching_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::CapabilityResponse_IPSecCapabilities, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::CapabilityResponse_IPSecCapabilities, tunnel_type_supported_),
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::CapabilityResponse_IPSecCapabilities, encryption_supported_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::CapabilityResponse_GeneveCapabilities, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::CapabilityResponse_GeneveCapabilities, number_geneve_options_supported_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::CapabilityResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::CapabilityResponse, match_capabilities_),
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::CapabilityResponse, ipsec_capabilities_),
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::CapabilityResponse, geneve_capabilities_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::TunnelAdditionError, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::TunnelAdditionError, match_error_),
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::TunnelAdditionError, tunnel_error_),
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::TunnelAdditionError, ipsec_error_),
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::TunnelAdditionError, geneve_error_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::MatchCriteria_IPSecMatch, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::MatchCriteria_IPSecMatch, spi_),
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::MatchCriteria_IPSecMatch, sn_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::MatchCriteria_GeneveMatch, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::MatchCriteria_GeneveMatch, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::MatchCriteria_GeneveMatch, vni_),
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::MatchCriteria_GeneveMatch, mac_match_),
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::MatchCriteria_GeneveMatch, protocol_type_),
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::MatchCriteria_GeneveMatch, ip_match_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::MatchCriteria_VXLanMatch, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::MatchCriteria_VXLanMatch, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::MatchCriteria_VXLanMatch, vni_),
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::MatchCriteria_VXLanMatch, mac_match_),
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::MatchCriteria_VXLanMatch, ip_match_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::MatchCriteria, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::MatchCriteria, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::MatchCriteria, ingress_interface_),
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::MatchCriteria, mac_match_),
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::MatchCriteria, tunnel_id_),
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::MatchCriteria, ip_match_),
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::MatchCriteria, match_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::IpTunnelRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::IpTunnelRequest, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::IpTunnelRequest, tunnel_id_),
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::IpTunnelRequest, operation_),
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::IpTunnelRequest, match_criteria_),
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::IpTunnelRequest, next_action_),
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::IpTunnelRequest, tunnel_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::Geneve, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::Geneve, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::Geneve, encap_decap_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::GeneveOption, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::GeneveOption, option_class_),
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::GeneveOption, type_),
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::GeneveOption, length_),
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::GeneveOption, data_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::GeneveEncap, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::GeneveEncap, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::GeneveEncap, inner_mac_pair_),
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::GeneveEncap, option_length_),
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::GeneveEncap, control_packet_),
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::GeneveEncap, critical_option_present_),
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::GeneveEncap, vni_),
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::GeneveEncap, protocol_type_),
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::GeneveEncap, geneve_option_),
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::GeneveEncap, ip_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::GeneveDecap, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::MacPair, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::MacPair, destination_mac_),
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::MacPair, source_mac_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::IPV4Pair, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::IPV4Pair, source_ip_),
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::IPV4Pair, destination_ip_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::IPV6Pair, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::IPV6Pair, source_ip_),
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::IPV6Pair, destination_ip_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::IPV4Match, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::IPV4Match, source_ip_),
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::IPV4Match, source_ip_prefix_),
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::IPV4Match, destination_ip_),
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::IPV4Match, destination_ip_prefix_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::IPV6Match, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::IPV6Match, source_ip_),
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::IPV6Match, source_ip_prefix_),
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::IPV6Match, destination_ip_),
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::IPV6Match, destination_ip_prefix_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::Nat, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::Nat, source_ip_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::IPSecEnc, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::IPSecEnc, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::IPSecEnc, tunnel_type_),
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::IPSecEnc, encryption_type_),
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::IPSecEnc, ipsec_sa_),
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::IPSecEnc, tunnelIps_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::IPSecDec, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::IPSecDec, tunnel_type_),
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::IPSecDec, encryption_type_),
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::IPSecDec, ipsec_sas_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::IPSecSAParams, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::IPSecSAParams, spi_),
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::IPSecSAParams, encryption_key_),
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::IPSecSAParams, operation_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::IPSecTunnel, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::IPSecTunnel, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::IPSecTunnel, ipsec_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::TunnelId, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::TunnelId, tunnel_id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::Counters, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::Counters, in_packets_),
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::Counters, out_packets_),
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::Counters, in_bytes_),
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::Counters, out_bytes_),
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::Counters, in_packets_drops_),
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::Counters, out_packets_drops_),
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::Counters, in_bytes_drops_),
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::Counters, out_bytes_drops_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::CreateIpTunnelResponses, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::CreateIpTunnelResponses, request_status_),
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::CreateIpTunnelResponses, error_status_),
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::CreateIpTunnelResponses, responses_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::CreateIpTunnelResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::CreateIpTunnelResponse, tunnel_id_),
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::CreateIpTunnelResponse, error_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::Error, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::Error, error_message_),
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::Error, error_string_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::IpTunnelResponses, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::IpTunnelResponses, responses_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::IpTunnelResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::IpTunnelResponse, tunnel_id_),
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::IpTunnelResponse, ip_tunnel_),
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::IpTunnelResponse, tunnel_counters_),
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::IpTunnelResponse, error_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::IpTunnelStatsResponses, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::IpTunnelStatsResponses, responses_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::IpTunnelStatsResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::IpTunnelStatsResponse, tunnel_id_),
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::IpTunnelStatsResponse, tunnel_counters_),
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::IpTunnelStatsResponse, error_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::TunnelRequestArgs, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::tunneloffload::v1alpha1::TunnelRequestArgs, tunnels_per_request_),
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::tunneloffload::v1alpha1::CapabilityRequest)},
  { 6, -1, -1, sizeof(::tunneloffload::v1alpha1::CapabilityResponse_MatchCapabilities)},
  { 17, -1, -1, sizeof(::tunneloffload::v1alpha1::CapabilityResponse_IPSecCapabilities)},
  { 25, -1, -1, sizeof(::tunneloffload::v1alpha1::CapabilityResponse_GeneveCapabilities)},
  { 32, -1, -1, sizeof(::tunneloffload::v1alpha1::CapabilityResponse)},
  { 41, -1, -1, sizeof(::tunneloffload::v1alpha1::TunnelAdditionError)},
  { 51, -1, -1, sizeof(::tunneloffload::v1alpha1::MatchCriteria_IPSecMatch)},
  { 59, -1, -1, sizeof(::tunneloffload::v1alpha1::MatchCriteria_GeneveMatch)},
  { 71, -1, -1, sizeof(::tunneloffload::v1alpha1::MatchCriteria_VXLanMatch)},
  { 82, -1, -1, sizeof(::tunneloffload::v1alpha1::MatchCriteria)},
  { 98, -1, -1, sizeof(::tunneloffload::v1alpha1::IpTunnelRequest)},
  { 112, -1, -1, sizeof(::tunneloffload::v1alpha1::Geneve)},
  { 121, -1, -1, sizeof(::tunneloffload::v1alpha1::GeneveOption)},
  { 131, -1, -1, sizeof(::tunneloffload::v1alpha1::GeneveEncap)},
  { 147, -1, -1, sizeof(::tunneloffload::v1alpha1::GeneveDecap)},
  { 153, -1, -1, sizeof(::tunneloffload::v1alpha1::MacPair)},
  { 161, -1, -1, sizeof(::tunneloffload::v1alpha1::IPV4Pair)},
  { 169, -1, -1, sizeof(::tunneloffload::v1alpha1::IPV6Pair)},
  { 177, -1, -1, sizeof(::tunneloffload::v1alpha1::IPV4Match)},
  { 187, -1, -1, sizeof(::tunneloffload::v1alpha1::IPV6Match)},
  { 197, -1, -1, sizeof(::tunneloffload::v1alpha1::Nat)},
  { 204, -1, -1, sizeof(::tunneloffload::v1alpha1::IPSecEnc)},
  { 216, -1, -1, sizeof(::tunneloffload::v1alpha1::IPSecDec)},
  { 225, -1, -1, sizeof(::tunneloffload::v1alpha1::IPSecSAParams)},
  { 234, -1, -1, sizeof(::tunneloffload::v1alpha1::IPSecTunnel)},
  { 243, -1, -1, sizeof(::tunneloffload::v1alpha1::TunnelId)},
  { 250, -1, -1, sizeof(::tunneloffload::v1alpha1::Counters)},
  { 264, -1, -1, sizeof(::tunneloffload::v1alpha1::CreateIpTunnelResponses)},
  { 273, -1, -1, sizeof(::tunneloffload::v1alpha1::CreateIpTunnelResponse)},
  { 281, -1, -1, sizeof(::tunneloffload::v1alpha1::Error)},
  { 289, -1, -1, sizeof(::tunneloffload::v1alpha1::IpTunnelResponses)},
  { 296, -1, -1, sizeof(::tunneloffload::v1alpha1::IpTunnelResponse)},
  { 306, -1, -1, sizeof(::tunneloffload::v1alpha1::IpTunnelStatsResponses)},
  { 313, -1, -1, sizeof(::tunneloffload::v1alpha1::IpTunnelStatsResponse)},
  { 322, -1, -1, sizeof(::tunneloffload::v1alpha1::TunnelRequestArgs)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::tunneloffload::v1alpha1::_CapabilityRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::tunneloffload::v1alpha1::_CapabilityResponse_MatchCapabilities_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::tunneloffload::v1alpha1::_CapabilityResponse_IPSecCapabilities_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::tunneloffload::v1alpha1::_CapabilityResponse_GeneveCapabilities_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::tunneloffload::v1alpha1::_CapabilityResponse_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::tunneloffload::v1alpha1::_TunnelAdditionError_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::tunneloffload::v1alpha1::_MatchCriteria_IPSecMatch_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::tunneloffload::v1alpha1::_MatchCriteria_GeneveMatch_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::tunneloffload::v1alpha1::_MatchCriteria_VXLanMatch_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::tunneloffload::v1alpha1::_MatchCriteria_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::tunneloffload::v1alpha1::_IpTunnelRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::tunneloffload::v1alpha1::_Geneve_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::tunneloffload::v1alpha1::_GeneveOption_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::tunneloffload::v1alpha1::_GeneveEncap_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::tunneloffload::v1alpha1::_GeneveDecap_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::tunneloffload::v1alpha1::_MacPair_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::tunneloffload::v1alpha1::_IPV4Pair_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::tunneloffload::v1alpha1::_IPV6Pair_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::tunneloffload::v1alpha1::_IPV4Match_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::tunneloffload::v1alpha1::_IPV6Match_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::tunneloffload::v1alpha1::_Nat_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::tunneloffload::v1alpha1::_IPSecEnc_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::tunneloffload::v1alpha1::_IPSecDec_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::tunneloffload::v1alpha1::_IPSecSAParams_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::tunneloffload::v1alpha1::_IPSecTunnel_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::tunneloffload::v1alpha1::_TunnelId_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::tunneloffload::v1alpha1::_Counters_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::tunneloffload::v1alpha1::_CreateIpTunnelResponses_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::tunneloffload::v1alpha1::_CreateIpTunnelResponse_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::tunneloffload::v1alpha1::_Error_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::tunneloffload::v1alpha1::_IpTunnelResponses_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::tunneloffload::v1alpha1::_IpTunnelResponse_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::tunneloffload::v1alpha1::_IpTunnelStatsResponses_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::tunneloffload::v1alpha1::_IpTunnelStatsResponse_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::tunneloffload::v1alpha1::_TunnelRequestArgs_default_instance_),
};

const char descriptor_table_protodef_tunneloffload_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\023tunneloffload.proto\022\026tunneloffload.v1a"
  "lpha1\"\023\n\021CapabilityRequest\"\232\005\n\022Capabilit"
  "yResponse\022X\n\022match_capabilities\030\001 \001(\0132<."
  "tunneloffload.v1alpha1.CapabilityRespons"
  "e.MatchCapabilities\022X\n\022ipsec_capabilitie"
  "s\030\002 \001(\0132<.tunneloffload.v1alpha1.Capabil"
  "ityResponse.IPSecCapabilities\022Z\n\023geneve_"
  "capabilities\030\003 \001(\0132=.tunneloffload.v1alp"
  "ha1.CapabilityResponse.GeneveCapabilitie"
  "s\032\227\001\n\021MatchCapabilities\022\"\n\032ingress_inter"
  "face_matching\030\001 \001(\010\022\026\n\016vxlan_matching\030\002 "
  "\001(\010\022\027\n\017geneve_matching\030\003 \001(\010\022\027\n\017tunnel_m"
  "atching\030\004 \001(\010\022\024\n\014spi_matching\030\005 \001(\010\032\232\001\n\021"
  "IPSecCapabilities\022F\n\025tunnel_type_support"
  "ed\030\001 \003(\0162\'.tunneloffload.v1alpha1.IPSecT"
  "unnelType\022=\n\024encryption_supported\030\002 \003(\0162"
  "\037.tunneloffload.v1alpha1.EncType\032=\n\022Gene"
  "veCapabilities\022\'\n\037number_geneve_options_"
  "supported\030\001 \001(\r\"\375\001\n\023TunnelAdditionError\022"
  "7\n\013match_error\030\001 \001(\0162\".tunneloffload.v1a"
  "lpha1.MatchError\0229\n\014tunnel_error\030\002 \001(\0162#"
  ".tunneloffload.v1alpha1.TunnelError\0227\n\013i"
  "psec_error\030\003 \001(\0162\".tunneloffload.v1alpha"
  "1.IPSecError\0229\n\014geneve_error\030\004 \001(\0162#.tun"
  "neloffload.v1alpha1.GeneveError\"\260\007\n\rMatc"
  "hCriteria\022\031\n\021ingress_interface\030\001 \001(\t\0222\n\t"
  "mac_match\030\002 \001(\0132\037.tunneloffload.v1alpha1"
  ".MacPair\0227\n\nipv4_match\030\003 \001(\0132!.tunneloff"
  "load.v1alpha1.IPV4MatchH\000\0227\n\nipv6_match\030"
  "\004 \001(\0132!.tunneloffload.v1alpha1.IPV6Match"
  "H\000\022\021\n\ttunnel_id\030\005 \001(\004\022G\n\013ipsec_match\030\006 \001"
  "(\01320.tunneloffload.v1alpha1.MatchCriteri"
  "a.IPSecMatchH\001\022I\n\014geneve_match\030\007 \001(\01321.t"
  "unneloffload.v1alpha1.MatchCriteria.Gene"
  "veMatchH\001\022G\n\013vxlan_match\030\010 \001(\01320.tunnelo"
  "ffload.v1alpha1.MatchCriteria.VXLanMatch"
  "H\001\032%\n\nIPSecMatch\022\013\n\003spi\030\001 \001(\r\022\n\n\002sn\030\002 \001("
  "\r\032\343\001\n\013GeneveMatch\022\013\n\003vni\030\001 \001(\r\0222\n\tmac_ma"
  "tch\030\002 \001(\0132\037.tunneloffload.v1alpha1.MacPa"
  "ir\022\025\n\rprotocol_type\030\003 \001(\r\0227\n\nipv4_match\030"
  "\004 \001(\0132!.tunneloffload.v1alpha1.IPV4Match"
  "H\000\0227\n\nipv6_match\030\005 \001(\0132!.tunneloffload.v"
  "1alpha1.IPV6MatchH\000B\n\n\010ip_match\032\313\001\n\nVXLa"
  "nMatch\022\013\n\003vni\030\001 \001(\r\0222\n\tmac_match\030\002 \001(\0132\037"
  ".tunneloffload.v1alpha1.MacPair\0227\n\nipv4_"
  "match\030\003 \001(\0132!.tunneloffload.v1alpha1.IPV"
  "4MatchH\000\0227\n\nipv6_match\030\004 \001(\0132!.tunneloff"
  "load.v1alpha1.IPV6MatchH\000B\n\n\010ip_matchB\n\n"
  "\010ip_matchB\007\n\005match\"\363\002\n\017IpTunnelRequest\022\021"
  "\n\ttunnel_id\030\001 \001(\004\0224\n\toperation\030\002 \001(\0162!.t"
  "unneloffload.v1alpha1.Operation\022=\n\016match"
  "_criteria\030\003 \001(\0132%.tunneloffload.v1alpha1"
  ".MatchCriteria\0223\n\013next_action\030\004 \001(\0162\036.tu"
  "nneloffload.v1alpha1.Action\022;\n\014ipsec_tun"
  "nel\030\005 \001(\0132#.tunneloffload.v1alpha1.IPSec"
  "TunnelH\000\0220\n\006geneve\030\006 \001(\0132\036.tunneloffload"
  ".v1alpha1.GeneveH\000\022*\n\003nat\030\007 \001(\0132\033.tunnel"
  "offload.v1alpha1.NatH\000B\010\n\006tunnel\"\221\001\n\006Gen"
  "eve\022;\n\014geneve_encap\030\001 \001(\0132#.tunneloffloa"
  "d.v1alpha1.GeneveEncapH\000\022;\n\014geneve_decap"
  "\030\002 \001(\0132#.tunneloffload.v1alpha1.GeneveDe"
  "capH\000B\r\n\013encap_decap\"P\n\014GeneveOption\022\024\n\014"
  "option_class\030\001 \001(\r\022\014\n\004type\030\002 \001(\r\022\016\n\006leng"
  "th\030\003 \001(\r\022\014\n\004data\030\004 \001(\014\"\367\002\n\013GeneveEncap\022;"
  "\n\017outer_ipv4_pair\030\001 \001(\0132 .tunneloffload."
  "v1alpha1.IPV4PairH\000\022;\n\017outer_ipv6_pair\030\002"
  " \001(\0132 .tunneloffload.v1alpha1.IPV6PairH\000"
  "\0227\n\016inner_mac_pair\030\003 \001(\0132\037.tunneloffload"
  ".v1alpha1.MacPair\022\025\n\roption_length\030\004 \001(\r"
  "\022\026\n\016control_packet\030\005 \001(\010\022\037\n\027critical_opt"
  "ion_present\030\006 \001(\010\022\013\n\003vni\030\007 \001(\r\022\025\n\rprotoc"
  "ol_type\030\010 \001(\r\022;\n\rgeneve_option\030\t \003(\0132$.t"
  "unneloffload.v1alpha1.GeneveOptionB\004\n\002ip"
  "\"\r\n\013GeneveDecap\"6\n\007MacPair\022\027\n\017destinatio"
  "n_mac\030\001 \001(\014\022\022\n\nsource_mac\030\002 \001(\014\"5\n\010IPV4P"
  "air\022\021\n\tsource_ip\030\001 \001(\007\022\026\n\016destination_ip"
  "\030\002 \001(\007\"5\n\010IPV6Pair\022\021\n\tsource_ip\030\001 \001(\014\022\026\n"
  "\016destination_ip\030\002 \001(\014\"o\n\tIPV4Match\022\021\n\tso"
  "urce_ip\030\001 \001(\007\022\030\n\020source_ip_prefix\030\002 \001(\r\022"
  "\026\n\016destination_ip\030\003 \001(\007\022\035\n\025destination_i"
  "p_prefix\030\004 \001(\r\"o\n\tIPV6Match\022\021\n\tsource_ip"
  "\030\001 \001(\014\022\030\n\020source_ip_prefix\030\002 \001(\r\022\026\n\016dest"
  "ination_ip\030\003 \001(\014\022\035\n\025destination_ip_prefi"
  "x\030\004 \001(\r\"\030\n\003Nat\022\021\n\tsource_ip\030\001 \001(\r\"\272\002\n\010IP"
  "SecEnc\022<\n\013tunnel_type\030\001 \001(\0162\'.tunneloffl"
  "oad.v1alpha1.IPSecTunnelType\0228\n\017encrypti"
  "on_type\030\002 \001(\0162\037.tunneloffload.v1alpha1.E"
  "ncType\0227\n\010ipsec_sa\030\003 \001(\0132%.tunneloffload"
  ".v1alpha1.IPSecSAParams\0227\n\013ipv4_tunnel\030\004"
  " \001(\0132 .tunneloffload.v1alpha1.IPV4PairH\000"
  "\0227\n\013ipv6_tunnel\030\005 \001(\0132 .tunneloffload.v1"
  "alpha1.IPV6PairH\000B\013\n\ttunnelIps\"\274\001\n\010IPSec"
  "Dec\022<\n\013tunnel_type\030\001 \001(\0162\'.tunneloffload"
  ".v1alpha1.IPSecTunnelType\0228\n\017encryption_"
  "type\030\002 \001(\0162\037.tunneloffload.v1alpha1.EncT"
  "ype\0228\n\tipsec_sas\030\003 \003(\0132%.tunneloffload.v"
  "1alpha1.IPSecSAParams\"j\n\rIPSecSAParams\022\013"
  "\n\003spi\030\001 \001(\r\022\026\n\016encryption_key\030\002 \001(\014\0224\n\to"
  "peration\030\003 \001(\0162!.tunneloffload.v1alpha1."
  "Operation\"\204\001\n\013IPSecTunnel\0225\n\tipsec_enc\030\001"
  " \001(\0132 .tunneloffload.v1alpha1.IPSecEncH\000"
  "\0225\n\tipsec_dec\030\002 \001(\0132 .tunneloffload.v1al"
  "pha1.IPSecDecH\000B\007\n\005ipsec\"\035\n\010TunnelId\022\021\n\t"
  "tunnel_id\030\001 \001(\004\"\276\001\n\010Counters\022\022\n\nin_packe"
  "ts\030\001 \001(\004\022\023\n\013out_packets\030\002 \001(\004\022\020\n\010in_byte"
  "s\030\003 \001(\004\022\021\n\tout_bytes\030\004 \001(\004\022\030\n\020in_packets"
  "_drops\030\005 \001(\004\022\031\n\021out_packets_drops\030\006 \001(\004\022"
  "\026\n\016in_bytes_drops\030\007 \001(\004\022\027\n\017out_bytes_dro"
  "ps\030\010 \001(\004\"\263\001\n\027CreateIpTunnelResponses\022\?\n\016"
  "request_status\030\001 \001(\0162\'.tunneloffload.v1a"
  "lpha1.AddTunnelStatus\022\024\n\014error_status\030\002 "
  "\001(\004\022A\n\tresponses\030\003 \003(\0132..tunneloffload.v"
  "1alpha1.CreateIpTunnelResponse\"Y\n\026Create"
  "IpTunnelResponse\022\021\n\ttunnel_id\030\001 \001(\004\022,\n\005e"
  "rror\030\002 \001(\0132\035.tunneloffload.v1alpha1.Erro"
  "r\"a\n\005Error\022B\n\rerror_message\030\001 \001(\0132+.tunn"
  "eloffload.v1alpha1.TunnelAdditionError\022\024"
  "\n\014error_string\030\002 \001(\t\"P\n\021IpTunnelResponse"
  "s\022;\n\tresponses\030\001 \003(\0132(.tunneloffload.v1a"
  "lpha1.IpTunnelResponse\"\312\001\n\020IpTunnelRespo"
  "nse\022\021\n\ttunnel_id\030\001 \001(\004\022:\n\tip_tunnel\030\002 \001("
  "\0132\'.tunneloffload.v1alpha1.IpTunnelReque"
  "st\0229\n\017tunnel_counters\030\003 \001(\0132 .tunneloffl"
  "oad.v1alpha1.Counters\022,\n\005error\030\004 \001(\0132\035.t"
  "unneloffload.v1alpha1.Error\"Z\n\026IpTunnelS"
  "tatsResponses\022@\n\tresponses\030\001 \003(\0132-.tunne"
  "loffload.v1alpha1.IpTunnelStatsResponse\""
  "\223\001\n\025IpTunnelStatsResponse\022\021\n\ttunnel_id\030\001"
  " \001(\004\0229\n\017tunnel_counters\030\002 \001(\0132 .tunnelof"
  "fload.v1alpha1.Counters\022,\n\005error\030\003 \001(\0132\035"
  ".tunneloffload.v1alpha1.Error\"0\n\021TunnelR"
  "equestArgs\022\033\n\023tunnels_per_request\030\001 \001(\r*"
  "\220\001\n\017AddTunnelStatus\022\024\n\020_TUNNEL_ACCEPTED\020"
  "\000\022\024\n\020_TUNNEL_REJECTED\020\001\022\026\n\022_TUNNEL_TABLE"
  "_FULL\020\002\022\035\n\031_TUNNEL_TABLE_UNAVAILABLE\020\003\022\032"
  "\n\026_TUNNEL_ALREADY_EXISTS\020\004*=\n\tOperation\022"
  "\t\n\005_NONE\020\000\022\013\n\007_CREATE\020\001\022\013\n\007_UPDATE\020\002\022\013\n\007"
  "_DELETE\020\003*\345\001\n\007EncType\022\020\n\014_AES256GCM64\020\000\022"
  "\020\n\014_AES256GCM96\020\001\022\021\n\r_AES256GCM128\020\002\022\020\n\014"
  "_AES128GCM64\020\003\022\020\n\014_AES128GCM96\020\004\022\021\n\r_AES"
  "128GCM128\020\005\022\020\n\014_AES256CCM64\020\006\022\020\n\014_AES256"
  "CCM96\020\007\022\021\n\r_AES256CCM128\020\010\022\020\n\014_AES128CCM"
  "64\020\t\022\020\n\014_AES128CCM96\020\n\022\021\n\r_AES128CCM128\020"
  "\013*0\n\006Action\022\010\n\004NONE\020\000\022\013\n\007FORWARD\020\001\022\017\n\013RE"
  "CIRCULATE\020\002*c\n\nMatchError\022\021\n\rMISING_FIEL"
  "DS\020\000\022\025\n\021INVALID_TUNNEL_ID\020\001\022\030\n\024INVALID_C"
  "APABILITIES\020\002\022\021\n\rINVALID_FIELD\020\003*\'\n\013Tunn"
  "elError\022\030\n\024NOT_SUPPORTED_TUNNEL\020\000*t\n\nIPS"
  "ecError\022\017\n\013INVALID_KEY\020\000\022\034\n\030NON_SUPPORTE"
  "D_ENCRYPTION\020\001\022\035\n\031NON_SUPPORTED_TUNNEL_T"
  "YPE\020\002\022\030\n\024IPSEC_MISSING_FIELDS\020\003*Q\n\013Genev"
  "eError\022\022\n\016INVALID_OPTION\020\000\022\024\n\020TOO_MANY_O"
  "PTIONS\020\001\022\030\n\024INVALID_GENEVE_FIELD\020\002*c\n\017IP"
  "SecTunnelType\022\r\n\tTRANSPORT\020\000\022\n\n\006TUNNEL\020\001"
  "\022\033\n\027TRANSPORT_NAT_TRAVERSAL\020\002\022\030\n\024TUNNEL_"
  "NAT_TRAVERSAL\020\0032\220\005\n\017IpTunnelService\022e\n\014C"
  "apabilities\022).tunneloffload.v1alpha1.Cap"
  "abilityRequest\032*.tunneloffload.v1alpha1."
  "CapabilityResponse\022n\n\016CreateIpTunnel\022\'.t"
  "unneloffload.v1alpha1.IpTunnelRequest\032/."
  "tunneloffload.v1alpha1.CreateIpTunnelRes"
  "ponses\"\000(\001\022[\n\013GetIpTunnel\022 .tunneloffloa"
  "d.v1alpha1.TunnelId\032(.tunneloffload.v1al"
  "pha1.IpTunnelResponse\"\000\022e\n\020GetIpTunnelSt"
  "ats\022 .tunneloffload.v1alpha1.TunnelId\032-."
  "tunneloffload.v1alpha1.IpTunnelStatsResp"
  "onse\"\000\022k\n\017GetAllIpTunnels\022).tunneloffloa"
  "d.v1alpha1.TunnelRequestArgs\032).tunneloff"
  "load.v1alpha1.IpTunnelResponses\"\0000\001\022u\n\024G"
  "etAllIpTunnelsStats\022).tunneloffload.v1al"
  "pha1.TunnelRequestArgs\032..tunneloffload.v"
  "1alpha1.IpTunnelStatsResponses\"\0000\001B&Z$gi"
  "thub.com/att/sessionOffload/protosb\006prot"
  "o3"
  ;
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_tunneloffload_2eproto_once;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_tunneloffload_2eproto = {
  false, false, 6922, descriptor_table_protodef_tunneloffload_2eproto, "tunneloffload.proto", 
  &descriptor_table_tunneloffload_2eproto_once, nullptr, 0, 35,
  schemas, file_default_instances, TableStruct_tunneloffload_2eproto::offsets,
  file_level_metadata_tunneloffload_2eproto, file_level_enum_descriptors_tunneloffload_2eproto, file_level_service_descriptors_tunneloffload_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable* descriptor_table_tunneloffload_2eproto_getter() {
  return &descriptor_table_tunneloffload_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY static ::PROTOBUF_NAMESPACE_ID::internal::AddDescriptorsRunner dynamic_init_dummy_tunneloffload_2eproto(&descriptor_table_tunneloffload_2eproto);
namespace tunneloffload {
namespace v1alpha1 {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AddTunnelStatus_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_tunneloffload_2eproto);
  return file_level_enum_descriptors_tunneloffload_2eproto[0];
}
bool AddTunnelStatus_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Operation_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_tunneloffload_2eproto);
  return file_level_enum_descriptors_tunneloffload_2eproto[1];
}
bool Operation_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EncType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_tunneloffload_2eproto);
  return file_level_enum_descriptors_tunneloffload_2eproto[2];
}
bool EncType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Action_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_tunneloffload_2eproto);
  return file_level_enum_descriptors_tunneloffload_2eproto[3];
}
bool Action_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MatchError_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_tunneloffload_2eproto);
  return file_level_enum_descriptors_tunneloffload_2eproto[4];
}
bool MatchError_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TunnelError_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_tunneloffload_2eproto);
  return file_level_enum_descriptors_tunneloffload_2eproto[5];
}
bool TunnelError_IsValid(int value) {
  switch (value) {
    case 0:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* IPSecError_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_tunneloffload_2eproto);
  return file_level_enum_descriptors_tunneloffload_2eproto[6];
}
bool IPSecError_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GeneveError_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_tunneloffload_2eproto);
  return file_level_enum_descriptors_tunneloffload_2eproto[7];
}
bool GeneveError_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* IPSecTunnelType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_tunneloffload_2eproto);
  return file_level_enum_descriptors_tunneloffload_2eproto[8];
}
bool IPSecTunnelType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class CapabilityRequest::_Internal {
 public:
};

CapabilityRequest::CapabilityRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:tunneloffload.v1alpha1.CapabilityRequest)
}
CapabilityRequest::CapabilityRequest(const CapabilityRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:tunneloffload.v1alpha1.CapabilityRequest)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CapabilityRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CapabilityRequest::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata CapabilityRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_tunneloffload_2eproto_getter, &descriptor_table_tunneloffload_2eproto_once,
      file_level_metadata_tunneloffload_2eproto[0]);
}

// ===================================================================

class CapabilityResponse_MatchCapabilities::_Internal {
 public:
};

CapabilityResponse_MatchCapabilities::CapabilityResponse_MatchCapabilities(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:tunneloffload.v1alpha1.CapabilityResponse.MatchCapabilities)
}
CapabilityResponse_MatchCapabilities::CapabilityResponse_MatchCapabilities(const CapabilityResponse_MatchCapabilities& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&ingress_interface_matching_, &from.ingress_interface_matching_,
    static_cast<size_t>(reinterpret_cast<char*>(&spi_matching_) -
    reinterpret_cast<char*>(&ingress_interface_matching_)) + sizeof(spi_matching_));
  // @@protoc_insertion_point(copy_constructor:tunneloffload.v1alpha1.CapabilityResponse.MatchCapabilities)
}

inline void CapabilityResponse_MatchCapabilities::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&ingress_interface_matching_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&spi_matching_) -
    reinterpret_cast<char*>(&ingress_interface_matching_)) + sizeof(spi_matching_));
}

CapabilityResponse_MatchCapabilities::~CapabilityResponse_MatchCapabilities() {
  // @@protoc_insertion_point(destructor:tunneloffload.v1alpha1.CapabilityResponse.MatchCapabilities)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CapabilityResponse_MatchCapabilities::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CapabilityResponse_MatchCapabilities::ArenaDtor(void* object) {
  CapabilityResponse_MatchCapabilities* _this = reinterpret_cast< CapabilityResponse_MatchCapabilities* >(object);
  (void)_this;
}
void CapabilityResponse_MatchCapabilities::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CapabilityResponse_MatchCapabilities::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CapabilityResponse_MatchCapabilities::Clear() {
// @@protoc_insertion_point(message_clear_start:tunneloffload.v1alpha1.CapabilityResponse.MatchCapabilities)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&ingress_interface_matching_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&spi_matching_) -
      reinterpret_cast<char*>(&ingress_interface_matching_)) + sizeof(spi_matching_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CapabilityResponse_MatchCapabilities::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool ingress_interface_matching = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          ingress_interface_matching_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool vxlan_matching = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          vxlan_matching_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool geneve_matching = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          geneve_matching_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool tunnel_matching = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          tunnel_matching_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool spi_matching = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          spi_matching_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CapabilityResponse_MatchCapabilities::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:tunneloffload.v1alpha1.CapabilityResponse.MatchCapabilities)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool ingress_interface_matching = 1;
  if (this->_internal_ingress_interface_matching() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_ingress_interface_matching(), target);
  }

  // bool vxlan_matching = 2;
  if (this->_internal_vxlan_matching() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->_internal_vxlan_matching(), target);
  }

  // bool geneve_matching = 3;
  if (this->_internal_geneve_matching() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(3, this->_internal_geneve_matching(), target);
  }

  // bool tunnel_matching = 4;
  if (this->_internal_tunnel_matching() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(4, this->_internal_tunnel_matching(), target);
  }

  // bool spi_matching = 5;
  if (this->_internal_spi_matching() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(5, this->_internal_spi_matching(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tunneloffload.v1alpha1.CapabilityResponse.MatchCapabilities)
  return target;
}

size_t CapabilityResponse_MatchCapabilities::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:tunneloffload.v1alpha1.CapabilityResponse.MatchCapabilities)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bool ingress_interface_matching = 1;
  if (this->_internal_ingress_interface_matching() != 0) {
    total_size += 1 + 1;
  }

  // bool vxlan_matching = 2;
  if (this->_internal_vxlan_matching() != 0) {
    total_size += 1 + 1;
  }

  // bool geneve_matching = 3;
  if (this->_internal_geneve_matching() != 0) {
    total_size += 1 + 1;
  }

  // bool tunnel_matching = 4;
  if (this->_internal_tunnel_matching() != 0) {
    total_size += 1 + 1;
  }

  // bool spi_matching = 5;
  if (this->_internal_spi_matching() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CapabilityResponse_MatchCapabilities::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CapabilityResponse_MatchCapabilities::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CapabilityResponse_MatchCapabilities::GetClassData() const { return &_class_data_; }

void CapabilityResponse_MatchCapabilities::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CapabilityResponse_MatchCapabilities *>(to)->MergeFrom(
      static_cast<const CapabilityResponse_MatchCapabilities &>(from));
}


void CapabilityResponse_MatchCapabilities::MergeFrom(const CapabilityResponse_MatchCapabilities& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:tunneloffload.v1alpha1.CapabilityResponse.MatchCapabilities)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_ingress_interface_matching() != 0) {
    _internal_set_ingress_interface_matching(from._internal_ingress_interface_matching());
  }
  if (from._internal_vxlan_matching() != 0) {
    _internal_set_vxlan_matching(from._internal_vxlan_matching());
  }
  if (from._internal_geneve_matching() != 0) {
    _internal_set_geneve_matching(from._internal_geneve_matching());
  }
  if (from._internal_tunnel_matching() != 0) {
    _internal_set_tunnel_matching(from._internal_tunnel_matching());
  }
  if (from._internal_spi_matching() != 0) {
    _internal_set_spi_matching(from._internal_spi_matching());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CapabilityResponse_MatchCapabilities::CopyFrom(const CapabilityResponse_MatchCapabilities& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tunneloffload.v1alpha1.CapabilityResponse.MatchCapabilities)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CapabilityResponse_MatchCapabilities::IsInitialized() const {
  return true;
}

void CapabilityResponse_MatchCapabilities::InternalSwap(CapabilityResponse_MatchCapabilities* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CapabilityResponse_MatchCapabilities, spi_matching_)
      + sizeof(CapabilityResponse_MatchCapabilities::spi_matching_)
      - PROTOBUF_FIELD_OFFSET(CapabilityResponse_MatchCapabilities, ingress_interface_matching_)>(
          reinterpret_cast<char*>(&ingress_interface_matching_),
          reinterpret_cast<char*>(&other->ingress_interface_matching_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CapabilityResponse_MatchCapabilities::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_tunneloffload_2eproto_getter, &descriptor_table_tunneloffload_2eproto_once,
      file_level_metadata_tunneloffload_2eproto[1]);
}

// ===================================================================

class CapabilityResponse_IPSecCapabilities::_Internal {
 public:
};

CapabilityResponse_IPSecCapabilities::CapabilityResponse_IPSecCapabilities(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  tunnel_type_supported_(arena),
  encryption_supported_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:tunneloffload.v1alpha1.CapabilityResponse.IPSecCapabilities)
}
CapabilityResponse_IPSecCapabilities::CapabilityResponse_IPSecCapabilities(const CapabilityResponse_IPSecCapabilities& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      tunnel_type_supported_(from.tunnel_type_supported_),
      encryption_supported_(from.encryption_supported_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:tunneloffload.v1alpha1.CapabilityResponse.IPSecCapabilities)
}

inline void CapabilityResponse_IPSecCapabilities::SharedCtor() {
}

CapabilityResponse_IPSecCapabilities::~CapabilityResponse_IPSecCapabilities() {
  // @@protoc_insertion_point(destructor:tunneloffload.v1alpha1.CapabilityResponse.IPSecCapabilities)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CapabilityResponse_IPSecCapabilities::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CapabilityResponse_IPSecCapabilities::ArenaDtor(void* object) {
  CapabilityResponse_IPSecCapabilities* _this = reinterpret_cast< CapabilityResponse_IPSecCapabilities* >(object);
  (void)_this;
}
void CapabilityResponse_IPSecCapabilities::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CapabilityResponse_IPSecCapabilities::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CapabilityResponse_IPSecCapabilities::Clear() {
// @@protoc_insertion_point(message_clear_start:tunneloffload.v1alpha1.CapabilityResponse.IPSecCapabilities)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  tunnel_type_supported_.Clear();
  encryption_supported_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CapabilityResponse_IPSecCapabilities::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .tunneloffload.v1alpha1.IPSecTunnelType tunnel_type_supported = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser(_internal_mutable_tunnel_type_supported(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 8) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_add_tunnel_type_supported(static_cast<::tunneloffload::v1alpha1::IPSecTunnelType>(val));
        } else
          goto handle_unusual;
        continue;
      // repeated .tunneloffload.v1alpha1.EncType encryption_supported = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser(_internal_mutable_encryption_supported(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 16) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_add_encryption_supported(static_cast<::tunneloffload::v1alpha1::EncType>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CapabilityResponse_IPSecCapabilities::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:tunneloffload.v1alpha1.CapabilityResponse.IPSecCapabilities)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .tunneloffload.v1alpha1.IPSecTunnelType tunnel_type_supported = 1;
  {
    int byte_size = _tunnel_type_supported_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteEnumPacked(
          1, tunnel_type_supported_, byte_size, target);
    }
  }

  // repeated .tunneloffload.v1alpha1.EncType encryption_supported = 2;
  {
    int byte_size = _encryption_supported_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteEnumPacked(
          2, encryption_supported_, byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tunneloffload.v1alpha1.CapabilityResponse.IPSecCapabilities)
  return target;
}

size_t CapabilityResponse_IPSecCapabilities::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:tunneloffload.v1alpha1.CapabilityResponse.IPSecCapabilities)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .tunneloffload.v1alpha1.IPSecTunnelType tunnel_type_supported = 1;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->_internal_tunnel_type_supported_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(
        this->_internal_tunnel_type_supported(static_cast<int>(i)));
    }
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _tunnel_type_supported_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // repeated .tunneloffload.v1alpha1.EncType encryption_supported = 2;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->_internal_encryption_supported_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(
        this->_internal_encryption_supported(static_cast<int>(i)));
    }
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _encryption_supported_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CapabilityResponse_IPSecCapabilities::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CapabilityResponse_IPSecCapabilities::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CapabilityResponse_IPSecCapabilities::GetClassData() const { return &_class_data_; }

void CapabilityResponse_IPSecCapabilities::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CapabilityResponse_IPSecCapabilities *>(to)->MergeFrom(
      static_cast<const CapabilityResponse_IPSecCapabilities &>(from));
}


void CapabilityResponse_IPSecCapabilities::MergeFrom(const CapabilityResponse_IPSecCapabilities& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:tunneloffload.v1alpha1.CapabilityResponse.IPSecCapabilities)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  tunnel_type_supported_.MergeFrom(from.tunnel_type_supported_);
  encryption_supported_.MergeFrom(from.encryption_supported_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CapabilityResponse_IPSecCapabilities::CopyFrom(const CapabilityResponse_IPSecCapabilities& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tunneloffload.v1alpha1.CapabilityResponse.IPSecCapabilities)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CapabilityResponse_IPSecCapabilities::IsInitialized() const {
  return true;
}

void CapabilityResponse_IPSecCapabilities::InternalSwap(CapabilityResponse_IPSecCapabilities* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  tunnel_type_supported_.InternalSwap(&other->tunnel_type_supported_);
  encryption_supported_.InternalSwap(&other->encryption_supported_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CapabilityResponse_IPSecCapabilities::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_tunneloffload_2eproto_getter, &descriptor_table_tunneloffload_2eproto_once,
      file_level_metadata_tunneloffload_2eproto[2]);
}

// ===================================================================

class CapabilityResponse_GeneveCapabilities::_Internal {
 public:
};

CapabilityResponse_GeneveCapabilities::CapabilityResponse_GeneveCapabilities(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:tunneloffload.v1alpha1.CapabilityResponse.GeneveCapabilities)
}
CapabilityResponse_GeneveCapabilities::CapabilityResponse_GeneveCapabilities(const CapabilityResponse_GeneveCapabilities& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  number_geneve_options_supported_ = from.number_geneve_options_supported_;
  // @@protoc_insertion_point(copy_constructor:tunneloffload.v1alpha1.CapabilityResponse.GeneveCapabilities)
}

inline void CapabilityResponse_GeneveCapabilities::SharedCtor() {
number_geneve_options_supported_ = 0u;
}

CapabilityResponse_GeneveCapabilities::~CapabilityResponse_GeneveCapabilities() {
  // @@protoc_insertion_point(destructor:tunneloffload.v1alpha1.CapabilityResponse.GeneveCapabilities)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CapabilityResponse_GeneveCapabilities::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CapabilityResponse_GeneveCapabilities::ArenaDtor(void* object) {
  CapabilityResponse_GeneveCapabilities* _this = reinterpret_cast< CapabilityResponse_GeneveCapabilities* >(object);
  (void)_this;
}
void CapabilityResponse_GeneveCapabilities::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CapabilityResponse_GeneveCapabilities::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CapabilityResponse_GeneveCapabilities::Clear() {
// @@protoc_insertion_point(message_clear_start:tunneloffload.v1alpha1.CapabilityResponse.GeneveCapabilities)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  number_geneve_options_supported_ = 0u;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CapabilityResponse_GeneveCapabilities::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 number_geneve_options_supported = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          number_geneve_options_supported_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CapabilityResponse_GeneveCapabilities::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:tunneloffload.v1alpha1.CapabilityResponse.GeneveCapabilities)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 number_geneve_options_supported = 1;
  if (this->_internal_number_geneve_options_supported() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_number_geneve_options_supported(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tunneloffload.v1alpha1.CapabilityResponse.GeneveCapabilities)
  return target;
}

size_t CapabilityResponse_GeneveCapabilities::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:tunneloffload.v1alpha1.CapabilityResponse.GeneveCapabilities)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 number_geneve_options_supported = 1;
  if (this->_internal_number_geneve_options_supported() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_number_geneve_options_supported());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CapabilityResponse_GeneveCapabilities::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CapabilityResponse_GeneveCapabilities::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CapabilityResponse_GeneveCapabilities::GetClassData() const { return &_class_data_; }

void CapabilityResponse_GeneveCapabilities::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CapabilityResponse_GeneveCapabilities *>(to)->MergeFrom(
      static_cast<const CapabilityResponse_GeneveCapabilities &>(from));
}


void CapabilityResponse_GeneveCapabilities::MergeFrom(const CapabilityResponse_GeneveCapabilities& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:tunneloffload.v1alpha1.CapabilityResponse.GeneveCapabilities)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_number_geneve_options_supported() != 0) {
    _internal_set_number_geneve_options_supported(from._internal_number_geneve_options_supported());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CapabilityResponse_GeneveCapabilities::CopyFrom(const CapabilityResponse_GeneveCapabilities& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tunneloffload.v1alpha1.CapabilityResponse.GeneveCapabilities)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CapabilityResponse_GeneveCapabilities::IsInitialized() const {
  return true;
}

void CapabilityResponse_GeneveCapabilities::InternalSwap(CapabilityResponse_GeneveCapabilities* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(number_geneve_options_supported_, other->number_geneve_options_supported_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CapabilityResponse_GeneveCapabilities::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_tunneloffload_2eproto_getter, &descriptor_table_tunneloffload_2eproto_once,
      file_level_metadata_tunneloffload_2eproto[3]);
}

// ===================================================================

class CapabilityResponse::_Internal {
 public:
  static const ::tunneloffload::v1alpha1::CapabilityResponse_MatchCapabilities& match_capabilities(const CapabilityResponse* msg);
  static const ::tunneloffload::v1alpha1::CapabilityResponse_IPSecCapabilities& ipsec_capabilities(const CapabilityResponse* msg);
  static const ::tunneloffload::v1alpha1::CapabilityResponse_GeneveCapabilities& geneve_capabilities(const CapabilityResponse* msg);
};

const ::tunneloffload::v1alpha1::CapabilityResponse_MatchCapabilities&
CapabilityResponse::_Internal::match_capabilities(const CapabilityResponse* msg) {
  return *msg->match_capabilities_;
}
const ::tunneloffload::v1alpha1::CapabilityResponse_IPSecCapabilities&
CapabilityResponse::_Internal::ipsec_capabilities(const CapabilityResponse* msg) {
  return *msg->ipsec_capabilities_;
}
const ::tunneloffload::v1alpha1::CapabilityResponse_GeneveCapabilities&
CapabilityResponse::_Internal::geneve_capabilities(const CapabilityResponse* msg) {
  return *msg->geneve_capabilities_;
}
CapabilityResponse::CapabilityResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:tunneloffload.v1alpha1.CapabilityResponse)
}
CapabilityResponse::CapabilityResponse(const CapabilityResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_match_capabilities()) {
    match_capabilities_ = new ::tunneloffload::v1alpha1::CapabilityResponse_MatchCapabilities(*from.match_capabilities_);
  } else {
    match_capabilities_ = nullptr;
  }
  if (from._internal_has_ipsec_capabilities()) {
    ipsec_capabilities_ = new ::tunneloffload::v1alpha1::CapabilityResponse_IPSecCapabilities(*from.ipsec_capabilities_);
  } else {
    ipsec_capabilities_ = nullptr;
  }
  if (from._internal_has_geneve_capabilities()) {
    geneve_capabilities_ = new ::tunneloffload::v1alpha1::CapabilityResponse_GeneveCapabilities(*from.geneve_capabilities_);
  } else {
    geneve_capabilities_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:tunneloffload.v1alpha1.CapabilityResponse)
}

inline void CapabilityResponse::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&match_capabilities_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&geneve_capabilities_) -
    reinterpret_cast<char*>(&match_capabilities_)) + sizeof(geneve_capabilities_));
}

CapabilityResponse::~CapabilityResponse() {
  // @@protoc_insertion_point(destructor:tunneloffload.v1alpha1.CapabilityResponse)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CapabilityResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete match_capabilities_;
  if (this != internal_default_instance()) delete ipsec_capabilities_;
  if (this != internal_default_instance()) delete geneve_capabilities_;
}

void CapabilityResponse::ArenaDtor(void* object) {
  CapabilityResponse* _this = reinterpret_cast< CapabilityResponse* >(object);
  (void)_this;
}
void CapabilityResponse::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CapabilityResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CapabilityResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:tunneloffload.v1alpha1.CapabilityResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && match_capabilities_ != nullptr) {
    delete match_capabilities_;
  }
  match_capabilities_ = nullptr;
  if (GetArenaForAllocation() == nullptr && ipsec_capabilities_ != nullptr) {
    delete ipsec_capabilities_;
  }
  ipsec_capabilities_ = nullptr;
  if (GetArenaForAllocation() == nullptr && geneve_capabilities_ != nullptr) {
    delete geneve_capabilities_;
  }
  geneve_capabilities_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CapabilityResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .tunneloffload.v1alpha1.CapabilityResponse.MatchCapabilities match_capabilities = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_match_capabilities(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .tunneloffload.v1alpha1.CapabilityResponse.IPSecCapabilities ipsec_capabilities = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_ipsec_capabilities(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .tunneloffload.v1alpha1.CapabilityResponse.GeneveCapabilities geneve_capabilities = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_geneve_capabilities(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CapabilityResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:tunneloffload.v1alpha1.CapabilityResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .tunneloffload.v1alpha1.CapabilityResponse.MatchCapabilities match_capabilities = 1;
  if (this->_internal_has_match_capabilities()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::match_capabilities(this), target, stream);
  }

  // .tunneloffload.v1alpha1.CapabilityResponse.IPSecCapabilities ipsec_capabilities = 2;
  if (this->_internal_has_ipsec_capabilities()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::ipsec_capabilities(this), target, stream);
  }

  // .tunneloffload.v1alpha1.CapabilityResponse.GeneveCapabilities geneve_capabilities = 3;
  if (this->_internal_has_geneve_capabilities()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::geneve_capabilities(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tunneloffload.v1alpha1.CapabilityResponse)
  return target;
}

size_t CapabilityResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:tunneloffload.v1alpha1.CapabilityResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .tunneloffload.v1alpha1.CapabilityResponse.MatchCapabilities match_capabilities = 1;
  if (this->_internal_has_match_capabilities()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *match_capabilities_);
  }

  // .tunneloffload.v1alpha1.CapabilityResponse.IPSecCapabilities ipsec_capabilities = 2;
  if (this->_internal_has_ipsec_capabilities()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *ipsec_capabilities_);
  }

  // .tunneloffload.v1alpha1.CapabilityResponse.GeneveCapabilities geneve_capabilities = 3;
  if (this->_internal_has_geneve_capabilities()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *geneve_capabilities_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CapabilityResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CapabilityResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CapabilityResponse::GetClassData() const { return &_class_data_; }

void CapabilityResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CapabilityResponse *>(to)->MergeFrom(
      static_cast<const CapabilityResponse &>(from));
}


void CapabilityResponse::MergeFrom(const CapabilityResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:tunneloffload.v1alpha1.CapabilityResponse)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_match_capabilities()) {
    _internal_mutable_match_capabilities()->::tunneloffload::v1alpha1::CapabilityResponse_MatchCapabilities::MergeFrom(from._internal_match_capabilities());
  }
  if (from._internal_has_ipsec_capabilities()) {
    _internal_mutable_ipsec_capabilities()->::tunneloffload::v1alpha1::CapabilityResponse_IPSecCapabilities::MergeFrom(from._internal_ipsec_capabilities());
  }
  if (from._internal_has_geneve_capabilities()) {
    _internal_mutable_geneve_capabilities()->::tunneloffload::v1alpha1::CapabilityResponse_GeneveCapabilities::MergeFrom(from._internal_geneve_capabilities());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CapabilityResponse::CopyFrom(const CapabilityResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tunneloffload.v1alpha1.CapabilityResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CapabilityResponse::IsInitialized() const {
  return true;
}

void CapabilityResponse::InternalSwap(CapabilityResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CapabilityResponse, geneve_capabilities_)
      + sizeof(CapabilityResponse::geneve_capabilities_)
      - PROTOBUF_FIELD_OFFSET(CapabilityResponse, match_capabilities_)>(
          reinterpret_cast<char*>(&match_capabilities_),
          reinterpret_cast<char*>(&other->match_capabilities_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CapabilityResponse::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_tunneloffload_2eproto_getter, &descriptor_table_tunneloffload_2eproto_once,
      file_level_metadata_tunneloffload_2eproto[4]);
}

// ===================================================================

class TunnelAdditionError::_Internal {
 public:
};

TunnelAdditionError::TunnelAdditionError(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:tunneloffload.v1alpha1.TunnelAdditionError)
}
TunnelAdditionError::TunnelAdditionError(const TunnelAdditionError& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&match_error_, &from.match_error_,
    static_cast<size_t>(reinterpret_cast<char*>(&geneve_error_) -
    reinterpret_cast<char*>(&match_error_)) + sizeof(geneve_error_));
  // @@protoc_insertion_point(copy_constructor:tunneloffload.v1alpha1.TunnelAdditionError)
}

inline void TunnelAdditionError::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&match_error_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&geneve_error_) -
    reinterpret_cast<char*>(&match_error_)) + sizeof(geneve_error_));
}

TunnelAdditionError::~TunnelAdditionError() {
  // @@protoc_insertion_point(destructor:tunneloffload.v1alpha1.TunnelAdditionError)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void TunnelAdditionError::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void TunnelAdditionError::ArenaDtor(void* object) {
  TunnelAdditionError* _this = reinterpret_cast< TunnelAdditionError* >(object);
  (void)_this;
}
void TunnelAdditionError::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TunnelAdditionError::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void TunnelAdditionError::Clear() {
// @@protoc_insertion_point(message_clear_start:tunneloffload.v1alpha1.TunnelAdditionError)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&match_error_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&geneve_error_) -
      reinterpret_cast<char*>(&match_error_)) + sizeof(geneve_error_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TunnelAdditionError::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .tunneloffload.v1alpha1.MatchError match_error = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_match_error(static_cast<::tunneloffload::v1alpha1::MatchError>(val));
        } else
          goto handle_unusual;
        continue;
      // .tunneloffload.v1alpha1.TunnelError tunnel_error = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_tunnel_error(static_cast<::tunneloffload::v1alpha1::TunnelError>(val));
        } else
          goto handle_unusual;
        continue;
      // .tunneloffload.v1alpha1.IPSecError ipsec_error = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_ipsec_error(static_cast<::tunneloffload::v1alpha1::IPSecError>(val));
        } else
          goto handle_unusual;
        continue;
      // .tunneloffload.v1alpha1.GeneveError geneve_error = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_geneve_error(static_cast<::tunneloffload::v1alpha1::GeneveError>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TunnelAdditionError::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:tunneloffload.v1alpha1.TunnelAdditionError)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .tunneloffload.v1alpha1.MatchError match_error = 1;
  if (this->_internal_match_error() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_match_error(), target);
  }

  // .tunneloffload.v1alpha1.TunnelError tunnel_error = 2;
  if (this->_internal_tunnel_error() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_tunnel_error(), target);
  }

  // .tunneloffload.v1alpha1.IPSecError ipsec_error = 3;
  if (this->_internal_ipsec_error() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      3, this->_internal_ipsec_error(), target);
  }

  // .tunneloffload.v1alpha1.GeneveError geneve_error = 4;
  if (this->_internal_geneve_error() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      4, this->_internal_geneve_error(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tunneloffload.v1alpha1.TunnelAdditionError)
  return target;
}

size_t TunnelAdditionError::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:tunneloffload.v1alpha1.TunnelAdditionError)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .tunneloffload.v1alpha1.MatchError match_error = 1;
  if (this->_internal_match_error() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_match_error());
  }

  // .tunneloffload.v1alpha1.TunnelError tunnel_error = 2;
  if (this->_internal_tunnel_error() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_tunnel_error());
  }

  // .tunneloffload.v1alpha1.IPSecError ipsec_error = 3;
  if (this->_internal_ipsec_error() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_ipsec_error());
  }

  // .tunneloffload.v1alpha1.GeneveError geneve_error = 4;
  if (this->_internal_geneve_error() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_geneve_error());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TunnelAdditionError::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    TunnelAdditionError::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TunnelAdditionError::GetClassData() const { return &_class_data_; }

void TunnelAdditionError::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<TunnelAdditionError *>(to)->MergeFrom(
      static_cast<const TunnelAdditionError &>(from));
}


void TunnelAdditionError::MergeFrom(const TunnelAdditionError& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:tunneloffload.v1alpha1.TunnelAdditionError)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_match_error() != 0) {
    _internal_set_match_error(from._internal_match_error());
  }
  if (from._internal_tunnel_error() != 0) {
    _internal_set_tunnel_error(from._internal_tunnel_error());
  }
  if (from._internal_ipsec_error() != 0) {
    _internal_set_ipsec_error(from._internal_ipsec_error());
  }
  if (from._internal_geneve_error() != 0) {
    _internal_set_geneve_error(from._internal_geneve_error());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TunnelAdditionError::CopyFrom(const TunnelAdditionError& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tunneloffload.v1alpha1.TunnelAdditionError)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TunnelAdditionError::IsInitialized() const {
  return true;
}

void TunnelAdditionError::InternalSwap(TunnelAdditionError* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TunnelAdditionError, geneve_error_)
      + sizeof(TunnelAdditionError::geneve_error_)
      - PROTOBUF_FIELD_OFFSET(TunnelAdditionError, match_error_)>(
          reinterpret_cast<char*>(&match_error_),
          reinterpret_cast<char*>(&other->match_error_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TunnelAdditionError::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_tunneloffload_2eproto_getter, &descriptor_table_tunneloffload_2eproto_once,
      file_level_metadata_tunneloffload_2eproto[5]);
}

// ===================================================================

class MatchCriteria_IPSecMatch::_Internal {
 public:
};

MatchCriteria_IPSecMatch::MatchCriteria_IPSecMatch(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:tunneloffload.v1alpha1.MatchCriteria.IPSecMatch)
}
MatchCriteria_IPSecMatch::MatchCriteria_IPSecMatch(const MatchCriteria_IPSecMatch& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&spi_, &from.spi_,
    static_cast<size_t>(reinterpret_cast<char*>(&sn_) -
    reinterpret_cast<char*>(&spi_)) + sizeof(sn_));
  // @@protoc_insertion_point(copy_constructor:tunneloffload.v1alpha1.MatchCriteria.IPSecMatch)
}

inline void MatchCriteria_IPSecMatch::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&spi_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&sn_) -
    reinterpret_cast<char*>(&spi_)) + sizeof(sn_));
}

MatchCriteria_IPSecMatch::~MatchCriteria_IPSecMatch() {
  // @@protoc_insertion_point(destructor:tunneloffload.v1alpha1.MatchCriteria.IPSecMatch)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void MatchCriteria_IPSecMatch::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void MatchCriteria_IPSecMatch::ArenaDtor(void* object) {
  MatchCriteria_IPSecMatch* _this = reinterpret_cast< MatchCriteria_IPSecMatch* >(object);
  (void)_this;
}
void MatchCriteria_IPSecMatch::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void MatchCriteria_IPSecMatch::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void MatchCriteria_IPSecMatch::Clear() {
// @@protoc_insertion_point(message_clear_start:tunneloffload.v1alpha1.MatchCriteria.IPSecMatch)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&spi_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&sn_) -
      reinterpret_cast<char*>(&spi_)) + sizeof(sn_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MatchCriteria_IPSecMatch::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 spi = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          spi_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 sn = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          sn_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MatchCriteria_IPSecMatch::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:tunneloffload.v1alpha1.MatchCriteria.IPSecMatch)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 spi = 1;
  if (this->_internal_spi() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_spi(), target);
  }

  // uint32 sn = 2;
  if (this->_internal_sn() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_sn(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tunneloffload.v1alpha1.MatchCriteria.IPSecMatch)
  return target;
}

size_t MatchCriteria_IPSecMatch::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:tunneloffload.v1alpha1.MatchCriteria.IPSecMatch)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 spi = 1;
  if (this->_internal_spi() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_spi());
  }

  // uint32 sn = 2;
  if (this->_internal_sn() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_sn());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MatchCriteria_IPSecMatch::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    MatchCriteria_IPSecMatch::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MatchCriteria_IPSecMatch::GetClassData() const { return &_class_data_; }

void MatchCriteria_IPSecMatch::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<MatchCriteria_IPSecMatch *>(to)->MergeFrom(
      static_cast<const MatchCriteria_IPSecMatch &>(from));
}


void MatchCriteria_IPSecMatch::MergeFrom(const MatchCriteria_IPSecMatch& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:tunneloffload.v1alpha1.MatchCriteria.IPSecMatch)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_spi() != 0) {
    _internal_set_spi(from._internal_spi());
  }
  if (from._internal_sn() != 0) {
    _internal_set_sn(from._internal_sn());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MatchCriteria_IPSecMatch::CopyFrom(const MatchCriteria_IPSecMatch& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tunneloffload.v1alpha1.MatchCriteria.IPSecMatch)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MatchCriteria_IPSecMatch::IsInitialized() const {
  return true;
}

void MatchCriteria_IPSecMatch::InternalSwap(MatchCriteria_IPSecMatch* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MatchCriteria_IPSecMatch, sn_)
      + sizeof(MatchCriteria_IPSecMatch::sn_)
      - PROTOBUF_FIELD_OFFSET(MatchCriteria_IPSecMatch, spi_)>(
          reinterpret_cast<char*>(&spi_),
          reinterpret_cast<char*>(&other->spi_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MatchCriteria_IPSecMatch::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_tunneloffload_2eproto_getter, &descriptor_table_tunneloffload_2eproto_once,
      file_level_metadata_tunneloffload_2eproto[6]);
}

// ===================================================================

class MatchCriteria_GeneveMatch::_Internal {
 public:
  static const ::tunneloffload::v1alpha1::MacPair& mac_match(const MatchCriteria_GeneveMatch* msg);
  static const ::tunneloffload::v1alpha1::IPV4Match& ipv4_match(const MatchCriteria_GeneveMatch* msg);
  static const ::tunneloffload::v1alpha1::IPV6Match& ipv6_match(const MatchCriteria_GeneveMatch* msg);
};

const ::tunneloffload::v1alpha1::MacPair&
MatchCriteria_GeneveMatch::_Internal::mac_match(const MatchCriteria_GeneveMatch* msg) {
  return *msg->mac_match_;
}
const ::tunneloffload::v1alpha1::IPV4Match&
MatchCriteria_GeneveMatch::_Internal::ipv4_match(const MatchCriteria_GeneveMatch* msg) {
  return *msg->ip_match_.ipv4_match_;
}
const ::tunneloffload::v1alpha1::IPV6Match&
MatchCriteria_GeneveMatch::_Internal::ipv6_match(const MatchCriteria_GeneveMatch* msg) {
  return *msg->ip_match_.ipv6_match_;
}
void MatchCriteria_GeneveMatch::set_allocated_ipv4_match(::tunneloffload::v1alpha1::IPV4Match* ipv4_match) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_ip_match();
  if (ipv4_match) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::tunneloffload::v1alpha1::IPV4Match>::GetOwningArena(ipv4_match);
    if (message_arena != submessage_arena) {
      ipv4_match = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ipv4_match, submessage_arena);
    }
    set_has_ipv4_match();
    ip_match_.ipv4_match_ = ipv4_match;
  }
  // @@protoc_insertion_point(field_set_allocated:tunneloffload.v1alpha1.MatchCriteria.GeneveMatch.ipv4_match)
}
void MatchCriteria_GeneveMatch::set_allocated_ipv6_match(::tunneloffload::v1alpha1::IPV6Match* ipv6_match) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_ip_match();
  if (ipv6_match) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::tunneloffload::v1alpha1::IPV6Match>::GetOwningArena(ipv6_match);
    if (message_arena != submessage_arena) {
      ipv6_match = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ipv6_match, submessage_arena);
    }
    set_has_ipv6_match();
    ip_match_.ipv6_match_ = ipv6_match;
  }
  // @@protoc_insertion_point(field_set_allocated:tunneloffload.v1alpha1.MatchCriteria.GeneveMatch.ipv6_match)
}
MatchCriteria_GeneveMatch::MatchCriteria_GeneveMatch(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:tunneloffload.v1alpha1.MatchCriteria.GeneveMatch)
}
MatchCriteria_GeneveMatch::MatchCriteria_GeneveMatch(const MatchCriteria_GeneveMatch& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_mac_match()) {
    mac_match_ = new ::tunneloffload::v1alpha1::MacPair(*from.mac_match_);
  } else {
    mac_match_ = nullptr;
  }
  ::memcpy(&vni_, &from.vni_,
    static_cast<size_t>(reinterpret_cast<char*>(&protocol_type_) -
    reinterpret_cast<char*>(&vni_)) + sizeof(protocol_type_));
  clear_has_ip_match();
  switch (from.ip_match_case()) {
    case kIpv4Match: {
      _internal_mutable_ipv4_match()->::tunneloffload::v1alpha1::IPV4Match::MergeFrom(from._internal_ipv4_match());
      break;
    }
    case kIpv6Match: {
      _internal_mutable_ipv6_match()->::tunneloffload::v1alpha1::IPV6Match::MergeFrom(from._internal_ipv6_match());
      break;
    }
    case IP_MATCH_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:tunneloffload.v1alpha1.MatchCriteria.GeneveMatch)
}

inline void MatchCriteria_GeneveMatch::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&mac_match_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&protocol_type_) -
    reinterpret_cast<char*>(&mac_match_)) + sizeof(protocol_type_));
clear_has_ip_match();
}

MatchCriteria_GeneveMatch::~MatchCriteria_GeneveMatch() {
  // @@protoc_insertion_point(destructor:tunneloffload.v1alpha1.MatchCriteria.GeneveMatch)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void MatchCriteria_GeneveMatch::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete mac_match_;
  if (has_ip_match()) {
    clear_ip_match();
  }
}

void MatchCriteria_GeneveMatch::ArenaDtor(void* object) {
  MatchCriteria_GeneveMatch* _this = reinterpret_cast< MatchCriteria_GeneveMatch* >(object);
  (void)_this;
}
void MatchCriteria_GeneveMatch::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void MatchCriteria_GeneveMatch::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void MatchCriteria_GeneveMatch::clear_ip_match() {
// @@protoc_insertion_point(one_of_clear_start:tunneloffload.v1alpha1.MatchCriteria.GeneveMatch)
  switch (ip_match_case()) {
    case kIpv4Match: {
      if (GetArenaForAllocation() == nullptr) {
        delete ip_match_.ipv4_match_;
      }
      break;
    }
    case kIpv6Match: {
      if (GetArenaForAllocation() == nullptr) {
        delete ip_match_.ipv6_match_;
      }
      break;
    }
    case IP_MATCH_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = IP_MATCH_NOT_SET;
}


void MatchCriteria_GeneveMatch::Clear() {
// @@protoc_insertion_point(message_clear_start:tunneloffload.v1alpha1.MatchCriteria.GeneveMatch)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && mac_match_ != nullptr) {
    delete mac_match_;
  }
  mac_match_ = nullptr;
  ::memset(&vni_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&protocol_type_) -
      reinterpret_cast<char*>(&vni_)) + sizeof(protocol_type_));
  clear_ip_match();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MatchCriteria_GeneveMatch::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 vni = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          vni_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .tunneloffload.v1alpha1.MacPair mac_match = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_mac_match(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 protocol_type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          protocol_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .tunneloffload.v1alpha1.IPV4Match ipv4_match = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_ipv4_match(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .tunneloffload.v1alpha1.IPV6Match ipv6_match = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_ipv6_match(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MatchCriteria_GeneveMatch::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:tunneloffload.v1alpha1.MatchCriteria.GeneveMatch)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 vni = 1;
  if (this->_internal_vni() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_vni(), target);
  }

  // .tunneloffload.v1alpha1.MacPair mac_match = 2;
  if (this->_internal_has_mac_match()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::mac_match(this), target, stream);
  }

  // uint32 protocol_type = 3;
  if (this->_internal_protocol_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_protocol_type(), target);
  }

  // .tunneloffload.v1alpha1.IPV4Match ipv4_match = 4;
  if (_internal_has_ipv4_match()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::ipv4_match(this), target, stream);
  }

  // .tunneloffload.v1alpha1.IPV6Match ipv6_match = 5;
  if (_internal_has_ipv6_match()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        5, _Internal::ipv6_match(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tunneloffload.v1alpha1.MatchCriteria.GeneveMatch)
  return target;
}

size_t MatchCriteria_GeneveMatch::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:tunneloffload.v1alpha1.MatchCriteria.GeneveMatch)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .tunneloffload.v1alpha1.MacPair mac_match = 2;
  if (this->_internal_has_mac_match()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *mac_match_);
  }

  // uint32 vni = 1;
  if (this->_internal_vni() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_vni());
  }

  // uint32 protocol_type = 3;
  if (this->_internal_protocol_type() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_protocol_type());
  }

  switch (ip_match_case()) {
    // .tunneloffload.v1alpha1.IPV4Match ipv4_match = 4;
    case kIpv4Match: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *ip_match_.ipv4_match_);
      break;
    }
    // .tunneloffload.v1alpha1.IPV6Match ipv6_match = 5;
    case kIpv6Match: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *ip_match_.ipv6_match_);
      break;
    }
    case IP_MATCH_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MatchCriteria_GeneveMatch::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    MatchCriteria_GeneveMatch::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MatchCriteria_GeneveMatch::GetClassData() const { return &_class_data_; }

void MatchCriteria_GeneveMatch::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<MatchCriteria_GeneveMatch *>(to)->MergeFrom(
      static_cast<const MatchCriteria_GeneveMatch &>(from));
}


void MatchCriteria_GeneveMatch::MergeFrom(const MatchCriteria_GeneveMatch& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:tunneloffload.v1alpha1.MatchCriteria.GeneveMatch)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_mac_match()) {
    _internal_mutable_mac_match()->::tunneloffload::v1alpha1::MacPair::MergeFrom(from._internal_mac_match());
  }
  if (from._internal_vni() != 0) {
    _internal_set_vni(from._internal_vni());
  }
  if (from._internal_protocol_type() != 0) {
    _internal_set_protocol_type(from._internal_protocol_type());
  }
  switch (from.ip_match_case()) {
    case kIpv4Match: {
      _internal_mutable_ipv4_match()->::tunneloffload::v1alpha1::IPV4Match::MergeFrom(from._internal_ipv4_match());
      break;
    }
    case kIpv6Match: {
      _internal_mutable_ipv6_match()->::tunneloffload::v1alpha1::IPV6Match::MergeFrom(from._internal_ipv6_match());
      break;
    }
    case IP_MATCH_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MatchCriteria_GeneveMatch::CopyFrom(const MatchCriteria_GeneveMatch& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tunneloffload.v1alpha1.MatchCriteria.GeneveMatch)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MatchCriteria_GeneveMatch::IsInitialized() const {
  return true;
}

void MatchCriteria_GeneveMatch::InternalSwap(MatchCriteria_GeneveMatch* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MatchCriteria_GeneveMatch, protocol_type_)
      + sizeof(MatchCriteria_GeneveMatch::protocol_type_)
      - PROTOBUF_FIELD_OFFSET(MatchCriteria_GeneveMatch, mac_match_)>(
          reinterpret_cast<char*>(&mac_match_),
          reinterpret_cast<char*>(&other->mac_match_));
  swap(ip_match_, other->ip_match_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata MatchCriteria_GeneveMatch::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_tunneloffload_2eproto_getter, &descriptor_table_tunneloffload_2eproto_once,
      file_level_metadata_tunneloffload_2eproto[7]);
}

// ===================================================================

class MatchCriteria_VXLanMatch::_Internal {
 public:
  static const ::tunneloffload::v1alpha1::MacPair& mac_match(const MatchCriteria_VXLanMatch* msg);
  static const ::tunneloffload::v1alpha1::IPV4Match& ipv4_match(const MatchCriteria_VXLanMatch* msg);
  static const ::tunneloffload::v1alpha1::IPV6Match& ipv6_match(const MatchCriteria_VXLanMatch* msg);
};

const ::tunneloffload::v1alpha1::MacPair&
MatchCriteria_VXLanMatch::_Internal::mac_match(const MatchCriteria_VXLanMatch* msg) {
  return *msg->mac_match_;
}
const ::tunneloffload::v1alpha1::IPV4Match&
MatchCriteria_VXLanMatch::_Internal::ipv4_match(const MatchCriteria_VXLanMatch* msg) {
  return *msg->ip_match_.ipv4_match_;
}
const ::tunneloffload::v1alpha1::IPV6Match&
MatchCriteria_VXLanMatch::_Internal::ipv6_match(const MatchCriteria_VXLanMatch* msg) {
  return *msg->ip_match_.ipv6_match_;
}
void MatchCriteria_VXLanMatch::set_allocated_ipv4_match(::tunneloffload::v1alpha1::IPV4Match* ipv4_match) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_ip_match();
  if (ipv4_match) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::tunneloffload::v1alpha1::IPV4Match>::GetOwningArena(ipv4_match);
    if (message_arena != submessage_arena) {
      ipv4_match = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ipv4_match, submessage_arena);
    }
    set_has_ipv4_match();
    ip_match_.ipv4_match_ = ipv4_match;
  }
  // @@protoc_insertion_point(field_set_allocated:tunneloffload.v1alpha1.MatchCriteria.VXLanMatch.ipv4_match)
}
void MatchCriteria_VXLanMatch::set_allocated_ipv6_match(::tunneloffload::v1alpha1::IPV6Match* ipv6_match) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_ip_match();
  if (ipv6_match) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::tunneloffload::v1alpha1::IPV6Match>::GetOwningArena(ipv6_match);
    if (message_arena != submessage_arena) {
      ipv6_match = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ipv6_match, submessage_arena);
    }
    set_has_ipv6_match();
    ip_match_.ipv6_match_ = ipv6_match;
  }
  // @@protoc_insertion_point(field_set_allocated:tunneloffload.v1alpha1.MatchCriteria.VXLanMatch.ipv6_match)
}
MatchCriteria_VXLanMatch::MatchCriteria_VXLanMatch(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:tunneloffload.v1alpha1.MatchCriteria.VXLanMatch)
}
MatchCriteria_VXLanMatch::MatchCriteria_VXLanMatch(const MatchCriteria_VXLanMatch& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_mac_match()) {
    mac_match_ = new ::tunneloffload::v1alpha1::MacPair(*from.mac_match_);
  } else {
    mac_match_ = nullptr;
  }
  vni_ = from.vni_;
  clear_has_ip_match();
  switch (from.ip_match_case()) {
    case kIpv4Match: {
      _internal_mutable_ipv4_match()->::tunneloffload::v1alpha1::IPV4Match::MergeFrom(from._internal_ipv4_match());
      break;
    }
    case kIpv6Match: {
      _internal_mutable_ipv6_match()->::tunneloffload::v1alpha1::IPV6Match::MergeFrom(from._internal_ipv6_match());
      break;
    }
    case IP_MATCH_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:tunneloffload.v1alpha1.MatchCriteria.VXLanMatch)
}

inline void MatchCriteria_VXLanMatch::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&mac_match_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&vni_) -
    reinterpret_cast<char*>(&mac_match_)) + sizeof(vni_));
clear_has_ip_match();
}

MatchCriteria_VXLanMatch::~MatchCriteria_VXLanMatch() {
  // @@protoc_insertion_point(destructor:tunneloffload.v1alpha1.MatchCriteria.VXLanMatch)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void MatchCriteria_VXLanMatch::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete mac_match_;
  if (has_ip_match()) {
    clear_ip_match();
  }
}

void MatchCriteria_VXLanMatch::ArenaDtor(void* object) {
  MatchCriteria_VXLanMatch* _this = reinterpret_cast< MatchCriteria_VXLanMatch* >(object);
  (void)_this;
}
void MatchCriteria_VXLanMatch::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void MatchCriteria_VXLanMatch::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void MatchCriteria_VXLanMatch::clear_ip_match() {
// @@protoc_insertion_point(one_of_clear_start:tunneloffload.v1alpha1.MatchCriteria.VXLanMatch)
  switch (ip_match_case()) {
    case kIpv4Match: {
      if (GetArenaForAllocation() == nullptr) {
        delete ip_match_.ipv4_match_;
      }
      break;
    }
    case kIpv6Match: {
      if (GetArenaForAllocation() == nullptr) {
        delete ip_match_.ipv6_match_;
      }
      break;
    }
    case IP_MATCH_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = IP_MATCH_NOT_SET;
}


void MatchCriteria_VXLanMatch::Clear() {
// @@protoc_insertion_point(message_clear_start:tunneloffload.v1alpha1.MatchCriteria.VXLanMatch)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && mac_match_ != nullptr) {
    delete mac_match_;
  }
  mac_match_ = nullptr;
  vni_ = 0u;
  clear_ip_match();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MatchCriteria_VXLanMatch::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 vni = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          vni_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .tunneloffload.v1alpha1.MacPair mac_match = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_mac_match(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .tunneloffload.v1alpha1.IPV4Match ipv4_match = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_ipv4_match(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .tunneloffload.v1alpha1.IPV6Match ipv6_match = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_ipv6_match(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MatchCriteria_VXLanMatch::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:tunneloffload.v1alpha1.MatchCriteria.VXLanMatch)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 vni = 1;
  if (this->_internal_vni() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_vni(), target);
  }

  // .tunneloffload.v1alpha1.MacPair mac_match = 2;
  if (this->_internal_has_mac_match()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::mac_match(this), target, stream);
  }

  // .tunneloffload.v1alpha1.IPV4Match ipv4_match = 3;
  if (_internal_has_ipv4_match()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::ipv4_match(this), target, stream);
  }

  // .tunneloffload.v1alpha1.IPV6Match ipv6_match = 4;
  if (_internal_has_ipv6_match()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::ipv6_match(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tunneloffload.v1alpha1.MatchCriteria.VXLanMatch)
  return target;
}

size_t MatchCriteria_VXLanMatch::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:tunneloffload.v1alpha1.MatchCriteria.VXLanMatch)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .tunneloffload.v1alpha1.MacPair mac_match = 2;
  if (this->_internal_has_mac_match()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *mac_match_);
  }

  // uint32 vni = 1;
  if (this->_internal_vni() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_vni());
  }

  switch (ip_match_case()) {
    // .tunneloffload.v1alpha1.IPV4Match ipv4_match = 3;
    case kIpv4Match: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *ip_match_.ipv4_match_);
      break;
    }
    // .tunneloffload.v1alpha1.IPV6Match ipv6_match = 4;
    case kIpv6Match: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *ip_match_.ipv6_match_);
      break;
    }
    case IP_MATCH_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MatchCriteria_VXLanMatch::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    MatchCriteria_VXLanMatch::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MatchCriteria_VXLanMatch::GetClassData() const { return &_class_data_; }

void MatchCriteria_VXLanMatch::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<MatchCriteria_VXLanMatch *>(to)->MergeFrom(
      static_cast<const MatchCriteria_VXLanMatch &>(from));
}


void MatchCriteria_VXLanMatch::MergeFrom(const MatchCriteria_VXLanMatch& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:tunneloffload.v1alpha1.MatchCriteria.VXLanMatch)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_mac_match()) {
    _internal_mutable_mac_match()->::tunneloffload::v1alpha1::MacPair::MergeFrom(from._internal_mac_match());
  }
  if (from._internal_vni() != 0) {
    _internal_set_vni(from._internal_vni());
  }
  switch (from.ip_match_case()) {
    case kIpv4Match: {
      _internal_mutable_ipv4_match()->::tunneloffload::v1alpha1::IPV4Match::MergeFrom(from._internal_ipv4_match());
      break;
    }
    case kIpv6Match: {
      _internal_mutable_ipv6_match()->::tunneloffload::v1alpha1::IPV6Match::MergeFrom(from._internal_ipv6_match());
      break;
    }
    case IP_MATCH_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MatchCriteria_VXLanMatch::CopyFrom(const MatchCriteria_VXLanMatch& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tunneloffload.v1alpha1.MatchCriteria.VXLanMatch)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MatchCriteria_VXLanMatch::IsInitialized() const {
  return true;
}

void MatchCriteria_VXLanMatch::InternalSwap(MatchCriteria_VXLanMatch* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MatchCriteria_VXLanMatch, vni_)
      + sizeof(MatchCriteria_VXLanMatch::vni_)
      - PROTOBUF_FIELD_OFFSET(MatchCriteria_VXLanMatch, mac_match_)>(
          reinterpret_cast<char*>(&mac_match_),
          reinterpret_cast<char*>(&other->mac_match_));
  swap(ip_match_, other->ip_match_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata MatchCriteria_VXLanMatch::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_tunneloffload_2eproto_getter, &descriptor_table_tunneloffload_2eproto_once,
      file_level_metadata_tunneloffload_2eproto[8]);
}

// ===================================================================

class MatchCriteria::_Internal {
 public:
  static const ::tunneloffload::v1alpha1::MacPair& mac_match(const MatchCriteria* msg);
  static const ::tunneloffload::v1alpha1::IPV4Match& ipv4_match(const MatchCriteria* msg);
  static const ::tunneloffload::v1alpha1::IPV6Match& ipv6_match(const MatchCriteria* msg);
  static const ::tunneloffload::v1alpha1::MatchCriteria_IPSecMatch& ipsec_match(const MatchCriteria* msg);
  static const ::tunneloffload::v1alpha1::MatchCriteria_GeneveMatch& geneve_match(const MatchCriteria* msg);
  static const ::tunneloffload::v1alpha1::MatchCriteria_VXLanMatch& vxlan_match(const MatchCriteria* msg);
};

const ::tunneloffload::v1alpha1::MacPair&
MatchCriteria::_Internal::mac_match(const MatchCriteria* msg) {
  return *msg->mac_match_;
}
const ::tunneloffload::v1alpha1::IPV4Match&
MatchCriteria::_Internal::ipv4_match(const MatchCriteria* msg) {
  return *msg->ip_match_.ipv4_match_;
}
const ::tunneloffload::v1alpha1::IPV6Match&
MatchCriteria::_Internal::ipv6_match(const MatchCriteria* msg) {
  return *msg->ip_match_.ipv6_match_;
}
const ::tunneloffload::v1alpha1::MatchCriteria_IPSecMatch&
MatchCriteria::_Internal::ipsec_match(const MatchCriteria* msg) {
  return *msg->match_.ipsec_match_;
}
const ::tunneloffload::v1alpha1::MatchCriteria_GeneveMatch&
MatchCriteria::_Internal::geneve_match(const MatchCriteria* msg) {
  return *msg->match_.geneve_match_;
}
const ::tunneloffload::v1alpha1::MatchCriteria_VXLanMatch&
MatchCriteria::_Internal::vxlan_match(const MatchCriteria* msg) {
  return *msg->match_.vxlan_match_;
}
void MatchCriteria::set_allocated_ipv4_match(::tunneloffload::v1alpha1::IPV4Match* ipv4_match) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_ip_match();
  if (ipv4_match) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::tunneloffload::v1alpha1::IPV4Match>::GetOwningArena(ipv4_match);
    if (message_arena != submessage_arena) {
      ipv4_match = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ipv4_match, submessage_arena);
    }
    set_has_ipv4_match();
    ip_match_.ipv4_match_ = ipv4_match;
  }
  // @@protoc_insertion_point(field_set_allocated:tunneloffload.v1alpha1.MatchCriteria.ipv4_match)
}
void MatchCriteria::set_allocated_ipv6_match(::tunneloffload::v1alpha1::IPV6Match* ipv6_match) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_ip_match();
  if (ipv6_match) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::tunneloffload::v1alpha1::IPV6Match>::GetOwningArena(ipv6_match);
    if (message_arena != submessage_arena) {
      ipv6_match = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ipv6_match, submessage_arena);
    }
    set_has_ipv6_match();
    ip_match_.ipv6_match_ = ipv6_match;
  }
  // @@protoc_insertion_point(field_set_allocated:tunneloffload.v1alpha1.MatchCriteria.ipv6_match)
}
void MatchCriteria::set_allocated_ipsec_match(::tunneloffload::v1alpha1::MatchCriteria_IPSecMatch* ipsec_match) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_match();
  if (ipsec_match) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::tunneloffload::v1alpha1::MatchCriteria_IPSecMatch>::GetOwningArena(ipsec_match);
    if (message_arena != submessage_arena) {
      ipsec_match = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ipsec_match, submessage_arena);
    }
    set_has_ipsec_match();
    match_.ipsec_match_ = ipsec_match;
  }
  // @@protoc_insertion_point(field_set_allocated:tunneloffload.v1alpha1.MatchCriteria.ipsec_match)
}
void MatchCriteria::set_allocated_geneve_match(::tunneloffload::v1alpha1::MatchCriteria_GeneveMatch* geneve_match) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_match();
  if (geneve_match) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::tunneloffload::v1alpha1::MatchCriteria_GeneveMatch>::GetOwningArena(geneve_match);
    if (message_arena != submessage_arena) {
      geneve_match = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, geneve_match, submessage_arena);
    }
    set_has_geneve_match();
    match_.geneve_match_ = geneve_match;
  }
  // @@protoc_insertion_point(field_set_allocated:tunneloffload.v1alpha1.MatchCriteria.geneve_match)
}
void MatchCriteria::set_allocated_vxlan_match(::tunneloffload::v1alpha1::MatchCriteria_VXLanMatch* vxlan_match) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_match();
  if (vxlan_match) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::tunneloffload::v1alpha1::MatchCriteria_VXLanMatch>::GetOwningArena(vxlan_match);
    if (message_arena != submessage_arena) {
      vxlan_match = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vxlan_match, submessage_arena);
    }
    set_has_vxlan_match();
    match_.vxlan_match_ = vxlan_match;
  }
  // @@protoc_insertion_point(field_set_allocated:tunneloffload.v1alpha1.MatchCriteria.vxlan_match)
}
MatchCriteria::MatchCriteria(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:tunneloffload.v1alpha1.MatchCriteria)
}
MatchCriteria::MatchCriteria(const MatchCriteria& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ingress_interface_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    ingress_interface_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_ingress_interface().empty()) {
    ingress_interface_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_ingress_interface(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_mac_match()) {
    mac_match_ = new ::tunneloffload::v1alpha1::MacPair(*from.mac_match_);
  } else {
    mac_match_ = nullptr;
  }
  tunnel_id_ = from.tunnel_id_;
  clear_has_ip_match();
  switch (from.ip_match_case()) {
    case kIpv4Match: {
      _internal_mutable_ipv4_match()->::tunneloffload::v1alpha1::IPV4Match::MergeFrom(from._internal_ipv4_match());
      break;
    }
    case kIpv6Match: {
      _internal_mutable_ipv6_match()->::tunneloffload::v1alpha1::IPV6Match::MergeFrom(from._internal_ipv6_match());
      break;
    }
    case IP_MATCH_NOT_SET: {
      break;
    }
  }
  clear_has_match();
  switch (from.match_case()) {
    case kIpsecMatch: {
      _internal_mutable_ipsec_match()->::tunneloffload::v1alpha1::MatchCriteria_IPSecMatch::MergeFrom(from._internal_ipsec_match());
      break;
    }
    case kGeneveMatch: {
      _internal_mutable_geneve_match()->::tunneloffload::v1alpha1::MatchCriteria_GeneveMatch::MergeFrom(from._internal_geneve_match());
      break;
    }
    case kVxlanMatch: {
      _internal_mutable_vxlan_match()->::tunneloffload::v1alpha1::MatchCriteria_VXLanMatch::MergeFrom(from._internal_vxlan_match());
      break;
    }
    case MATCH_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:tunneloffload.v1alpha1.MatchCriteria)
}

inline void MatchCriteria::SharedCtor() {
ingress_interface_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  ingress_interface_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&mac_match_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&tunnel_id_) -
    reinterpret_cast<char*>(&mac_match_)) + sizeof(tunnel_id_));
clear_has_ip_match();
clear_has_match();
}

MatchCriteria::~MatchCriteria() {
  // @@protoc_insertion_point(destructor:tunneloffload.v1alpha1.MatchCriteria)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void MatchCriteria::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  ingress_interface_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete mac_match_;
  if (has_ip_match()) {
    clear_ip_match();
  }
  if (has_match()) {
    clear_match();
  }
}

void MatchCriteria::ArenaDtor(void* object) {
  MatchCriteria* _this = reinterpret_cast< MatchCriteria* >(object);
  (void)_this;
}
void MatchCriteria::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void MatchCriteria::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void MatchCriteria::clear_ip_match() {
// @@protoc_insertion_point(one_of_clear_start:tunneloffload.v1alpha1.MatchCriteria)
  switch (ip_match_case()) {
    case kIpv4Match: {
      if (GetArenaForAllocation() == nullptr) {
        delete ip_match_.ipv4_match_;
      }
      break;
    }
    case kIpv6Match: {
      if (GetArenaForAllocation() == nullptr) {
        delete ip_match_.ipv6_match_;
      }
      break;
    }
    case IP_MATCH_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = IP_MATCH_NOT_SET;
}

void MatchCriteria::clear_match() {
// @@protoc_insertion_point(one_of_clear_start:tunneloffload.v1alpha1.MatchCriteria)
  switch (match_case()) {
    case kIpsecMatch: {
      if (GetArenaForAllocation() == nullptr) {
        delete match_.ipsec_match_;
      }
      break;
    }
    case kGeneveMatch: {
      if (GetArenaForAllocation() == nullptr) {
        delete match_.geneve_match_;
      }
      break;
    }
    case kVxlanMatch: {
      if (GetArenaForAllocation() == nullptr) {
        delete match_.vxlan_match_;
      }
      break;
    }
    case MATCH_NOT_SET: {
      break;
    }
  }
  _oneof_case_[1] = MATCH_NOT_SET;
}


void MatchCriteria::Clear() {
// @@protoc_insertion_point(message_clear_start:tunneloffload.v1alpha1.MatchCriteria)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ingress_interface_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && mac_match_ != nullptr) {
    delete mac_match_;
  }
  mac_match_ = nullptr;
  tunnel_id_ = uint64_t{0u};
  clear_ip_match();
  clear_match();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MatchCriteria::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string ingress_interface = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_ingress_interface();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "tunneloffload.v1alpha1.MatchCriteria.ingress_interface"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .tunneloffload.v1alpha1.MacPair mac_match = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_mac_match(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .tunneloffload.v1alpha1.IPV4Match ipv4_match = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_ipv4_match(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .tunneloffload.v1alpha1.IPV6Match ipv6_match = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_ipv6_match(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 tunnel_id = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          tunnel_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .tunneloffload.v1alpha1.MatchCriteria.IPSecMatch ipsec_match = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_ipsec_match(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .tunneloffload.v1alpha1.MatchCriteria.GeneveMatch geneve_match = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_geneve_match(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .tunneloffload.v1alpha1.MatchCriteria.VXLanMatch vxlan_match = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_vxlan_match(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MatchCriteria::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:tunneloffload.v1alpha1.MatchCriteria)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string ingress_interface = 1;
  if (!this->_internal_ingress_interface().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_ingress_interface().data(), static_cast<int>(this->_internal_ingress_interface().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "tunneloffload.v1alpha1.MatchCriteria.ingress_interface");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_ingress_interface(), target);
  }

  // .tunneloffload.v1alpha1.MacPair mac_match = 2;
  if (this->_internal_has_mac_match()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::mac_match(this), target, stream);
  }

  // .tunneloffload.v1alpha1.IPV4Match ipv4_match = 3;
  if (_internal_has_ipv4_match()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::ipv4_match(this), target, stream);
  }

  // .tunneloffload.v1alpha1.IPV6Match ipv6_match = 4;
  if (_internal_has_ipv6_match()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::ipv6_match(this), target, stream);
  }

  // uint64 tunnel_id = 5;
  if (this->_internal_tunnel_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(5, this->_internal_tunnel_id(), target);
  }

  // .tunneloffload.v1alpha1.MatchCriteria.IPSecMatch ipsec_match = 6;
  if (_internal_has_ipsec_match()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        6, _Internal::ipsec_match(this), target, stream);
  }

  // .tunneloffload.v1alpha1.MatchCriteria.GeneveMatch geneve_match = 7;
  if (_internal_has_geneve_match()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        7, _Internal::geneve_match(this), target, stream);
  }

  // .tunneloffload.v1alpha1.MatchCriteria.VXLanMatch vxlan_match = 8;
  if (_internal_has_vxlan_match()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        8, _Internal::vxlan_match(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tunneloffload.v1alpha1.MatchCriteria)
  return target;
}

size_t MatchCriteria::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:tunneloffload.v1alpha1.MatchCriteria)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string ingress_interface = 1;
  if (!this->_internal_ingress_interface().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_ingress_interface());
  }

  // .tunneloffload.v1alpha1.MacPair mac_match = 2;
  if (this->_internal_has_mac_match()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *mac_match_);
  }

  // uint64 tunnel_id = 5;
  if (this->_internal_tunnel_id() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_tunnel_id());
  }

  switch (ip_match_case()) {
    // .tunneloffload.v1alpha1.IPV4Match ipv4_match = 3;
    case kIpv4Match: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *ip_match_.ipv4_match_);
      break;
    }
    // .tunneloffload.v1alpha1.IPV6Match ipv6_match = 4;
    case kIpv6Match: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *ip_match_.ipv6_match_);
      break;
    }
    case IP_MATCH_NOT_SET: {
      break;
    }
  }
  switch (match_case()) {
    // .tunneloffload.v1alpha1.MatchCriteria.IPSecMatch ipsec_match = 6;
    case kIpsecMatch: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *match_.ipsec_match_);
      break;
    }
    // .tunneloffload.v1alpha1.MatchCriteria.GeneveMatch geneve_match = 7;
    case kGeneveMatch: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *match_.geneve_match_);
      break;
    }
    // .tunneloffload.v1alpha1.MatchCriteria.VXLanMatch vxlan_match = 8;
    case kVxlanMatch: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *match_.vxlan_match_);
      break;
    }
    case MATCH_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MatchCriteria::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    MatchCriteria::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MatchCriteria::GetClassData() const { return &_class_data_; }

void MatchCriteria::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<MatchCriteria *>(to)->MergeFrom(
      static_cast<const MatchCriteria &>(from));
}


void MatchCriteria::MergeFrom(const MatchCriteria& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:tunneloffload.v1alpha1.MatchCriteria)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_ingress_interface().empty()) {
    _internal_set_ingress_interface(from._internal_ingress_interface());
  }
  if (from._internal_has_mac_match()) {
    _internal_mutable_mac_match()->::tunneloffload::v1alpha1::MacPair::MergeFrom(from._internal_mac_match());
  }
  if (from._internal_tunnel_id() != 0) {
    _internal_set_tunnel_id(from._internal_tunnel_id());
  }
  switch (from.ip_match_case()) {
    case kIpv4Match: {
      _internal_mutable_ipv4_match()->::tunneloffload::v1alpha1::IPV4Match::MergeFrom(from._internal_ipv4_match());
      break;
    }
    case kIpv6Match: {
      _internal_mutable_ipv6_match()->::tunneloffload::v1alpha1::IPV6Match::MergeFrom(from._internal_ipv6_match());
      break;
    }
    case IP_MATCH_NOT_SET: {
      break;
    }
  }
  switch (from.match_case()) {
    case kIpsecMatch: {
      _internal_mutable_ipsec_match()->::tunneloffload::v1alpha1::MatchCriteria_IPSecMatch::MergeFrom(from._internal_ipsec_match());
      break;
    }
    case kGeneveMatch: {
      _internal_mutable_geneve_match()->::tunneloffload::v1alpha1::MatchCriteria_GeneveMatch::MergeFrom(from._internal_geneve_match());
      break;
    }
    case kVxlanMatch: {
      _internal_mutable_vxlan_match()->::tunneloffload::v1alpha1::MatchCriteria_VXLanMatch::MergeFrom(from._internal_vxlan_match());
      break;
    }
    case MATCH_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MatchCriteria::CopyFrom(const MatchCriteria& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tunneloffload.v1alpha1.MatchCriteria)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MatchCriteria::IsInitialized() const {
  return true;
}

void MatchCriteria::InternalSwap(MatchCriteria* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &ingress_interface_, lhs_arena,
      &other->ingress_interface_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MatchCriteria, tunnel_id_)
      + sizeof(MatchCriteria::tunnel_id_)
      - PROTOBUF_FIELD_OFFSET(MatchCriteria, mac_match_)>(
          reinterpret_cast<char*>(&mac_match_),
          reinterpret_cast<char*>(&other->mac_match_));
  swap(ip_match_, other->ip_match_);
  swap(match_, other->match_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
  swap(_oneof_case_[1], other->_oneof_case_[1]);
}

::PROTOBUF_NAMESPACE_ID::Metadata MatchCriteria::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_tunneloffload_2eproto_getter, &descriptor_table_tunneloffload_2eproto_once,
      file_level_metadata_tunneloffload_2eproto[9]);
}

// ===================================================================

class IpTunnelRequest::_Internal {
 public:
  static const ::tunneloffload::v1alpha1::MatchCriteria& match_criteria(const IpTunnelRequest* msg);
  static const ::tunneloffload::v1alpha1::IPSecTunnel& ipsec_tunnel(const IpTunnelRequest* msg);
  static const ::tunneloffload::v1alpha1::Geneve& geneve(const IpTunnelRequest* msg);
  static const ::tunneloffload::v1alpha1::Nat& nat(const IpTunnelRequest* msg);
};

const ::tunneloffload::v1alpha1::MatchCriteria&
IpTunnelRequest::_Internal::match_criteria(const IpTunnelRequest* msg) {
  return *msg->match_criteria_;
}
const ::tunneloffload::v1alpha1::IPSecTunnel&
IpTunnelRequest::_Internal::ipsec_tunnel(const IpTunnelRequest* msg) {
  return *msg->tunnel_.ipsec_tunnel_;
}
const ::tunneloffload::v1alpha1::Geneve&
IpTunnelRequest::_Internal::geneve(const IpTunnelRequest* msg) {
  return *msg->tunnel_.geneve_;
}
const ::tunneloffload::v1alpha1::Nat&
IpTunnelRequest::_Internal::nat(const IpTunnelRequest* msg) {
  return *msg->tunnel_.nat_;
}
void IpTunnelRequest::set_allocated_ipsec_tunnel(::tunneloffload::v1alpha1::IPSecTunnel* ipsec_tunnel) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_tunnel();
  if (ipsec_tunnel) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::tunneloffload::v1alpha1::IPSecTunnel>::GetOwningArena(ipsec_tunnel);
    if (message_arena != submessage_arena) {
      ipsec_tunnel = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ipsec_tunnel, submessage_arena);
    }
    set_has_ipsec_tunnel();
    tunnel_.ipsec_tunnel_ = ipsec_tunnel;
  }
  // @@protoc_insertion_point(field_set_allocated:tunneloffload.v1alpha1.IpTunnelRequest.ipsec_tunnel)
}
void IpTunnelRequest::set_allocated_geneve(::tunneloffload::v1alpha1::Geneve* geneve) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_tunnel();
  if (geneve) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::tunneloffload::v1alpha1::Geneve>::GetOwningArena(geneve);
    if (message_arena != submessage_arena) {
      geneve = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, geneve, submessage_arena);
    }
    set_has_geneve();
    tunnel_.geneve_ = geneve;
  }
  // @@protoc_insertion_point(field_set_allocated:tunneloffload.v1alpha1.IpTunnelRequest.geneve)
}
void IpTunnelRequest::set_allocated_nat(::tunneloffload::v1alpha1::Nat* nat) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_tunnel();
  if (nat) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::tunneloffload::v1alpha1::Nat>::GetOwningArena(nat);
    if (message_arena != submessage_arena) {
      nat = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nat, submessage_arena);
    }
    set_has_nat();
    tunnel_.nat_ = nat;
  }
  // @@protoc_insertion_point(field_set_allocated:tunneloffload.v1alpha1.IpTunnelRequest.nat)
}
IpTunnelRequest::IpTunnelRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:tunneloffload.v1alpha1.IpTunnelRequest)
}
IpTunnelRequest::IpTunnelRequest(const IpTunnelRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_match_criteria()) {
    match_criteria_ = new ::tunneloffload::v1alpha1::MatchCriteria(*from.match_criteria_);
  } else {
    match_criteria_ = nullptr;
  }
  ::memcpy(&tunnel_id_, &from.tunnel_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&next_action_) -
    reinterpret_cast<char*>(&tunnel_id_)) + sizeof(next_action_));
  clear_has_tunnel();
  switch (from.tunnel_case()) {
    case kIpsecTunnel: {
      _internal_mutable_ipsec_tunnel()->::tunneloffload::v1alpha1::IPSecTunnel::MergeFrom(from._internal_ipsec_tunnel());
      break;
    }
    case kGeneve: {
      _internal_mutable_geneve()->::tunneloffload::v1alpha1::Geneve::MergeFrom(from._internal_geneve());
      break;
    }
    case kNat: {
      _internal_mutable_nat()->::tunneloffload::v1alpha1::Nat::MergeFrom(from._internal_nat());
      break;
    }
    case TUNNEL_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:tunneloffload.v1alpha1.IpTunnelRequest)
}

inline void IpTunnelRequest::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&match_criteria_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&next_action_) -
    reinterpret_cast<char*>(&match_criteria_)) + sizeof(next_action_));
clear_has_tunnel();
}

IpTunnelRequest::~IpTunnelRequest() {
  // @@protoc_insertion_point(destructor:tunneloffload.v1alpha1.IpTunnelRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void IpTunnelRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete match_criteria_;
  if (has_tunnel()) {
    clear_tunnel();
  }
}

void IpTunnelRequest::ArenaDtor(void* object) {
  IpTunnelRequest* _this = reinterpret_cast< IpTunnelRequest* >(object);
  (void)_this;
}
void IpTunnelRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void IpTunnelRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void IpTunnelRequest::clear_tunnel() {
// @@protoc_insertion_point(one_of_clear_start:tunneloffload.v1alpha1.IpTunnelRequest)
  switch (tunnel_case()) {
    case kIpsecTunnel: {
      if (GetArenaForAllocation() == nullptr) {
        delete tunnel_.ipsec_tunnel_;
      }
      break;
    }
    case kGeneve: {
      if (GetArenaForAllocation() == nullptr) {
        delete tunnel_.geneve_;
      }
      break;
    }
    case kNat: {
      if (GetArenaForAllocation() == nullptr) {
        delete tunnel_.nat_;
      }
      break;
    }
    case TUNNEL_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = TUNNEL_NOT_SET;
}


void IpTunnelRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:tunneloffload.v1alpha1.IpTunnelRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && match_criteria_ != nullptr) {
    delete match_criteria_;
  }
  match_criteria_ = nullptr;
  ::memset(&tunnel_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&next_action_) -
      reinterpret_cast<char*>(&tunnel_id_)) + sizeof(next_action_));
  clear_tunnel();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* IpTunnelRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 tunnel_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          tunnel_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .tunneloffload.v1alpha1.Operation operation = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_operation(static_cast<::tunneloffload::v1alpha1::Operation>(val));
        } else
          goto handle_unusual;
        continue;
      // .tunneloffload.v1alpha1.MatchCriteria match_criteria = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_match_criteria(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .tunneloffload.v1alpha1.Action next_action = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_next_action(static_cast<::tunneloffload::v1alpha1::Action>(val));
        } else
          goto handle_unusual;
        continue;
      // .tunneloffload.v1alpha1.IPSecTunnel ipsec_tunnel = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_ipsec_tunnel(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .tunneloffload.v1alpha1.Geneve geneve = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_geneve(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .tunneloffload.v1alpha1.Nat nat = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_nat(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IpTunnelRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:tunneloffload.v1alpha1.IpTunnelRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 tunnel_id = 1;
  if (this->_internal_tunnel_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_tunnel_id(), target);
  }

  // .tunneloffload.v1alpha1.Operation operation = 2;
  if (this->_internal_operation() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_operation(), target);
  }

  // .tunneloffload.v1alpha1.MatchCriteria match_criteria = 3;
  if (this->_internal_has_match_criteria()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::match_criteria(this), target, stream);
  }

  // .tunneloffload.v1alpha1.Action next_action = 4;
  if (this->_internal_next_action() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      4, this->_internal_next_action(), target);
  }

  // .tunneloffload.v1alpha1.IPSecTunnel ipsec_tunnel = 5;
  if (_internal_has_ipsec_tunnel()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        5, _Internal::ipsec_tunnel(this), target, stream);
  }

  // .tunneloffload.v1alpha1.Geneve geneve = 6;
  if (_internal_has_geneve()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        6, _Internal::geneve(this), target, stream);
  }

  // .tunneloffload.v1alpha1.Nat nat = 7;
  if (_internal_has_nat()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        7, _Internal::nat(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tunneloffload.v1alpha1.IpTunnelRequest)
  return target;
}

size_t IpTunnelRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:tunneloffload.v1alpha1.IpTunnelRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .tunneloffload.v1alpha1.MatchCriteria match_criteria = 3;
  if (this->_internal_has_match_criteria()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *match_criteria_);
  }

  // uint64 tunnel_id = 1;
  if (this->_internal_tunnel_id() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_tunnel_id());
  }

  // .tunneloffload.v1alpha1.Operation operation = 2;
  if (this->_internal_operation() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_operation());
  }

  // .tunneloffload.v1alpha1.Action next_action = 4;
  if (this->_internal_next_action() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_next_action());
  }

  switch (tunnel_case()) {
    // .tunneloffload.v1alpha1.IPSecTunnel ipsec_tunnel = 5;
    case kIpsecTunnel: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *tunnel_.ipsec_tunnel_);
      break;
    }
    // .tunneloffload.v1alpha1.Geneve geneve = 6;
    case kGeneve: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *tunnel_.geneve_);
      break;
    }
    // .tunneloffload.v1alpha1.Nat nat = 7;
    case kNat: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *tunnel_.nat_);
      break;
    }
    case TUNNEL_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData IpTunnelRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    IpTunnelRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*IpTunnelRequest::GetClassData() const { return &_class_data_; }

void IpTunnelRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<IpTunnelRequest *>(to)->MergeFrom(
      static_cast<const IpTunnelRequest &>(from));
}


void IpTunnelRequest::MergeFrom(const IpTunnelRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:tunneloffload.v1alpha1.IpTunnelRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_match_criteria()) {
    _internal_mutable_match_criteria()->::tunneloffload::v1alpha1::MatchCriteria::MergeFrom(from._internal_match_criteria());
  }
  if (from._internal_tunnel_id() != 0) {
    _internal_set_tunnel_id(from._internal_tunnel_id());
  }
  if (from._internal_operation() != 0) {
    _internal_set_operation(from._internal_operation());
  }
  if (from._internal_next_action() != 0) {
    _internal_set_next_action(from._internal_next_action());
  }
  switch (from.tunnel_case()) {
    case kIpsecTunnel: {
      _internal_mutable_ipsec_tunnel()->::tunneloffload::v1alpha1::IPSecTunnel::MergeFrom(from._internal_ipsec_tunnel());
      break;
    }
    case kGeneve: {
      _internal_mutable_geneve()->::tunneloffload::v1alpha1::Geneve::MergeFrom(from._internal_geneve());
      break;
    }
    case kNat: {
      _internal_mutable_nat()->::tunneloffload::v1alpha1::Nat::MergeFrom(from._internal_nat());
      break;
    }
    case TUNNEL_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void IpTunnelRequest::CopyFrom(const IpTunnelRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tunneloffload.v1alpha1.IpTunnelRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IpTunnelRequest::IsInitialized() const {
  return true;
}

void IpTunnelRequest::InternalSwap(IpTunnelRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(IpTunnelRequest, next_action_)
      + sizeof(IpTunnelRequest::next_action_)
      - PROTOBUF_FIELD_OFFSET(IpTunnelRequest, match_criteria_)>(
          reinterpret_cast<char*>(&match_criteria_),
          reinterpret_cast<char*>(&other->match_criteria_));
  swap(tunnel_, other->tunnel_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata IpTunnelRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_tunneloffload_2eproto_getter, &descriptor_table_tunneloffload_2eproto_once,
      file_level_metadata_tunneloffload_2eproto[10]);
}

// ===================================================================

class Geneve::_Internal {
 public:
  static const ::tunneloffload::v1alpha1::GeneveEncap& geneve_encap(const Geneve* msg);
  static const ::tunneloffload::v1alpha1::GeneveDecap& geneve_decap(const Geneve* msg);
};

const ::tunneloffload::v1alpha1::GeneveEncap&
Geneve::_Internal::geneve_encap(const Geneve* msg) {
  return *msg->encap_decap_.geneve_encap_;
}
const ::tunneloffload::v1alpha1::GeneveDecap&
Geneve::_Internal::geneve_decap(const Geneve* msg) {
  return *msg->encap_decap_.geneve_decap_;
}
void Geneve::set_allocated_geneve_encap(::tunneloffload::v1alpha1::GeneveEncap* geneve_encap) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_encap_decap();
  if (geneve_encap) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::tunneloffload::v1alpha1::GeneveEncap>::GetOwningArena(geneve_encap);
    if (message_arena != submessage_arena) {
      geneve_encap = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, geneve_encap, submessage_arena);
    }
    set_has_geneve_encap();
    encap_decap_.geneve_encap_ = geneve_encap;
  }
  // @@protoc_insertion_point(field_set_allocated:tunneloffload.v1alpha1.Geneve.geneve_encap)
}
void Geneve::set_allocated_geneve_decap(::tunneloffload::v1alpha1::GeneveDecap* geneve_decap) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_encap_decap();
  if (geneve_decap) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::tunneloffload::v1alpha1::GeneveDecap>::GetOwningArena(geneve_decap);
    if (message_arena != submessage_arena) {
      geneve_decap = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, geneve_decap, submessage_arena);
    }
    set_has_geneve_decap();
    encap_decap_.geneve_decap_ = geneve_decap;
  }
  // @@protoc_insertion_point(field_set_allocated:tunneloffload.v1alpha1.Geneve.geneve_decap)
}
Geneve::Geneve(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:tunneloffload.v1alpha1.Geneve)
}
Geneve::Geneve(const Geneve& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_encap_decap();
  switch (from.encap_decap_case()) {
    case kGeneveEncap: {
      _internal_mutable_geneve_encap()->::tunneloffload::v1alpha1::GeneveEncap::MergeFrom(from._internal_geneve_encap());
      break;
    }
    case kGeneveDecap: {
      _internal_mutable_geneve_decap()->::tunneloffload::v1alpha1::GeneveDecap::MergeFrom(from._internal_geneve_decap());
      break;
    }
    case ENCAP_DECAP_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:tunneloffload.v1alpha1.Geneve)
}

inline void Geneve::SharedCtor() {
clear_has_encap_decap();
}

Geneve::~Geneve() {
  // @@protoc_insertion_point(destructor:tunneloffload.v1alpha1.Geneve)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void Geneve::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_encap_decap()) {
    clear_encap_decap();
  }
}

void Geneve::ArenaDtor(void* object) {
  Geneve* _this = reinterpret_cast< Geneve* >(object);
  (void)_this;
}
void Geneve::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Geneve::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Geneve::clear_encap_decap() {
// @@protoc_insertion_point(one_of_clear_start:tunneloffload.v1alpha1.Geneve)
  switch (encap_decap_case()) {
    case kGeneveEncap: {
      if (GetArenaForAllocation() == nullptr) {
        delete encap_decap_.geneve_encap_;
      }
      break;
    }
    case kGeneveDecap: {
      if (GetArenaForAllocation() == nullptr) {
        delete encap_decap_.geneve_decap_;
      }
      break;
    }
    case ENCAP_DECAP_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = ENCAP_DECAP_NOT_SET;
}


void Geneve::Clear() {
// @@protoc_insertion_point(message_clear_start:tunneloffload.v1alpha1.Geneve)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_encap_decap();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Geneve::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .tunneloffload.v1alpha1.GeneveEncap geneve_encap = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_geneve_encap(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .tunneloffload.v1alpha1.GeneveDecap geneve_decap = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_geneve_decap(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Geneve::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:tunneloffload.v1alpha1.Geneve)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .tunneloffload.v1alpha1.GeneveEncap geneve_encap = 1;
  if (_internal_has_geneve_encap()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::geneve_encap(this), target, stream);
  }

  // .tunneloffload.v1alpha1.GeneveDecap geneve_decap = 2;
  if (_internal_has_geneve_decap()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::geneve_decap(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tunneloffload.v1alpha1.Geneve)
  return target;
}

size_t Geneve::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:tunneloffload.v1alpha1.Geneve)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (encap_decap_case()) {
    // .tunneloffload.v1alpha1.GeneveEncap geneve_encap = 1;
    case kGeneveEncap: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *encap_decap_.geneve_encap_);
      break;
    }
    // .tunneloffload.v1alpha1.GeneveDecap geneve_decap = 2;
    case kGeneveDecap: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *encap_decap_.geneve_decap_);
      break;
    }
    case ENCAP_DECAP_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Geneve::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Geneve::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Geneve::GetClassData() const { return &_class_data_; }

void Geneve::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Geneve *>(to)->MergeFrom(
      static_cast<const Geneve &>(from));
}


void Geneve::MergeFrom(const Geneve& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:tunneloffload.v1alpha1.Geneve)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.encap_decap_case()) {
    case kGeneveEncap: {
      _internal_mutable_geneve_encap()->::tunneloffload::v1alpha1::GeneveEncap::MergeFrom(from._internal_geneve_encap());
      break;
    }
    case kGeneveDecap: {
      _internal_mutable_geneve_decap()->::tunneloffload::v1alpha1::GeneveDecap::MergeFrom(from._internal_geneve_decap());
      break;
    }
    case ENCAP_DECAP_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Geneve::CopyFrom(const Geneve& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tunneloffload.v1alpha1.Geneve)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Geneve::IsInitialized() const {
  return true;
}

void Geneve::InternalSwap(Geneve* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(encap_decap_, other->encap_decap_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata Geneve::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_tunneloffload_2eproto_getter, &descriptor_table_tunneloffload_2eproto_once,
      file_level_metadata_tunneloffload_2eproto[11]);
}

// ===================================================================

class GeneveOption::_Internal {
 public:
};

GeneveOption::GeneveOption(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:tunneloffload.v1alpha1.GeneveOption)
}
GeneveOption::GeneveOption(const GeneveOption& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_data().empty()) {
    data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_data(), 
      GetArenaForAllocation());
  }
  ::memcpy(&option_class_, &from.option_class_,
    static_cast<size_t>(reinterpret_cast<char*>(&length_) -
    reinterpret_cast<char*>(&option_class_)) + sizeof(length_));
  // @@protoc_insertion_point(copy_constructor:tunneloffload.v1alpha1.GeneveOption)
}

inline void GeneveOption::SharedCtor() {
data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&option_class_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&length_) -
    reinterpret_cast<char*>(&option_class_)) + sizeof(length_));
}

GeneveOption::~GeneveOption() {
  // @@protoc_insertion_point(destructor:tunneloffload.v1alpha1.GeneveOption)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void GeneveOption::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  data_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void GeneveOption::ArenaDtor(void* object) {
  GeneveOption* _this = reinterpret_cast< GeneveOption* >(object);
  (void)_this;
}
void GeneveOption::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void GeneveOption::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GeneveOption::Clear() {
// @@protoc_insertion_point(message_clear_start:tunneloffload.v1alpha1.GeneveOption)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  data_.ClearToEmpty();
  ::memset(&option_class_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&length_) -
      reinterpret_cast<char*>(&option_class_)) + sizeof(length_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GeneveOption::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 option_class = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          option_class_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 length = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          length_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes data = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_data();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GeneveOption::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:tunneloffload.v1alpha1.GeneveOption)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 option_class = 1;
  if (this->_internal_option_class() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_option_class(), target);
  }

  // uint32 type = 2;
  if (this->_internal_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_type(), target);
  }

  // uint32 length = 3;
  if (this->_internal_length() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_length(), target);
  }

  // bytes data = 4;
  if (!this->_internal_data().empty()) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tunneloffload.v1alpha1.GeneveOption)
  return target;
}

size_t GeneveOption::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:tunneloffload.v1alpha1.GeneveOption)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes data = 4;
  if (!this->_internal_data().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_data());
  }

  // uint32 option_class = 1;
  if (this->_internal_option_class() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_option_class());
  }

  // uint32 type = 2;
  if (this->_internal_type() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_type());
  }

  // uint32 length = 3;
  if (this->_internal_length() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_length());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GeneveOption::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    GeneveOption::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GeneveOption::GetClassData() const { return &_class_data_; }

void GeneveOption::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<GeneveOption *>(to)->MergeFrom(
      static_cast<const GeneveOption &>(from));
}


void GeneveOption::MergeFrom(const GeneveOption& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:tunneloffload.v1alpha1.GeneveOption)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_data().empty()) {
    _internal_set_data(from._internal_data());
  }
  if (from._internal_option_class() != 0) {
    _internal_set_option_class(from._internal_option_class());
  }
  if (from._internal_type() != 0) {
    _internal_set_type(from._internal_type());
  }
  if (from._internal_length() != 0) {
    _internal_set_length(from._internal_length());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GeneveOption::CopyFrom(const GeneveOption& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tunneloffload.v1alpha1.GeneveOption)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GeneveOption::IsInitialized() const {
  return true;
}

void GeneveOption::InternalSwap(GeneveOption* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &data_, lhs_arena,
      &other->data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GeneveOption, length_)
      + sizeof(GeneveOption::length_)
      - PROTOBUF_FIELD_OFFSET(GeneveOption, option_class_)>(
          reinterpret_cast<char*>(&option_class_),
          reinterpret_cast<char*>(&other->option_class_));
}

::PROTOBUF_NAMESPACE_ID::Metadata GeneveOption::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_tunneloffload_2eproto_getter, &descriptor_table_tunneloffload_2eproto_once,
      file_level_metadata_tunneloffload_2eproto[12]);
}

// ===================================================================

class GeneveEncap::_Internal {
 public:
  static const ::tunneloffload::v1alpha1::IPV4Pair& outer_ipv4_pair(const GeneveEncap* msg);
  static const ::tunneloffload::v1alpha1::IPV6Pair& outer_ipv6_pair(const GeneveEncap* msg);
  static const ::tunneloffload::v1alpha1::MacPair& inner_mac_pair(const GeneveEncap* msg);
};

const ::tunneloffload::v1alpha1::IPV4Pair&
GeneveEncap::_Internal::outer_ipv4_pair(const GeneveEncap* msg) {
  return *msg->ip_.outer_ipv4_pair_;
}
const ::tunneloffload::v1alpha1::IPV6Pair&
GeneveEncap::_Internal::outer_ipv6_pair(const GeneveEncap* msg) {
  return *msg->ip_.outer_ipv6_pair_;
}
const ::tunneloffload::v1alpha1::MacPair&
GeneveEncap::_Internal::inner_mac_pair(const GeneveEncap* msg) {
  return *msg->inner_mac_pair_;
}
void GeneveEncap::set_allocated_outer_ipv4_pair(::tunneloffload::v1alpha1::IPV4Pair* outer_ipv4_pair) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_ip();
  if (outer_ipv4_pair) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::tunneloffload::v1alpha1::IPV4Pair>::GetOwningArena(outer_ipv4_pair);
    if (message_arena != submessage_arena) {
      outer_ipv4_pair = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, outer_ipv4_pair, submessage_arena);
    }
    set_has_outer_ipv4_pair();
    ip_.outer_ipv4_pair_ = outer_ipv4_pair;
  }
  // @@protoc_insertion_point(field_set_allocated:tunneloffload.v1alpha1.GeneveEncap.outer_ipv4_pair)
}
void GeneveEncap::set_allocated_outer_ipv6_pair(::tunneloffload::v1alpha1::IPV6Pair* outer_ipv6_pair) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_ip();
  if (outer_ipv6_pair) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::tunneloffload::v1alpha1::IPV6Pair>::GetOwningArena(outer_ipv6_pair);
    if (message_arena != submessage_arena) {
      outer_ipv6_pair = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, outer_ipv6_pair, submessage_arena);
    }
    set_has_outer_ipv6_pair();
    ip_.outer_ipv6_pair_ = outer_ipv6_pair;
  }
  // @@protoc_insertion_point(field_set_allocated:tunneloffload.v1alpha1.GeneveEncap.outer_ipv6_pair)
}
GeneveEncap::GeneveEncap(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  geneve_option_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:tunneloffload.v1alpha1.GeneveEncap)
}
GeneveEncap::GeneveEncap(const GeneveEncap& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      geneve_option_(from.geneve_option_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_inner_mac_pair()) {
    inner_mac_pair_ = new ::tunneloffload::v1alpha1::MacPair(*from.inner_mac_pair_);
  } else {
    inner_mac_pair_ = nullptr;
  }
  ::memcpy(&option_length_, &from.option_length_,
    static_cast<size_t>(reinterpret_cast<char*>(&protocol_type_) -
    reinterpret_cast<char*>(&option_length_)) + sizeof(protocol_type_));
  clear_has_ip();
  switch (from.ip_case()) {
    case kOuterIpv4Pair: {
      _internal_mutable_outer_ipv4_pair()->::tunneloffload::v1alpha1::IPV4Pair::MergeFrom(from._internal_outer_ipv4_pair());
      break;
    }
    case kOuterIpv6Pair: {
      _internal_mutable_outer_ipv6_pair()->::tunneloffload::v1alpha1::IPV6Pair::MergeFrom(from._internal_outer_ipv6_pair());
      break;
    }
    case IP_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:tunneloffload.v1alpha1.GeneveEncap)
}

inline void GeneveEncap::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&inner_mac_pair_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&protocol_type_) -
    reinterpret_cast<char*>(&inner_mac_pair_)) + sizeof(protocol_type_));
clear_has_ip();
}

GeneveEncap::~GeneveEncap() {
  // @@protoc_insertion_point(destructor:tunneloffload.v1alpha1.GeneveEncap)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void GeneveEncap::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete inner_mac_pair_;
  if (has_ip()) {
    clear_ip();
  }
}

void GeneveEncap::ArenaDtor(void* object) {
  GeneveEncap* _this = reinterpret_cast< GeneveEncap* >(object);
  (void)_this;
}
void GeneveEncap::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void GeneveEncap::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GeneveEncap::clear_ip() {
// @@protoc_insertion_point(one_of_clear_start:tunneloffload.v1alpha1.GeneveEncap)
  switch (ip_case()) {
    case kOuterIpv4Pair: {
      if (GetArenaForAllocation() == nullptr) {
        delete ip_.outer_ipv4_pair_;
      }
      break;
    }
    case kOuterIpv6Pair: {
      if (GetArenaForAllocation() == nullptr) {
        delete ip_.outer_ipv6_pair_;
      }
      break;
    }
    case IP_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = IP_NOT_SET;
}


void GeneveEncap::Clear() {
// @@protoc_insertion_point(message_clear_start:tunneloffload.v1alpha1.GeneveEncap)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  geneve_option_.Clear();
  if (GetArenaForAllocation() == nullptr && inner_mac_pair_ != nullptr) {
    delete inner_mac_pair_;
  }
  inner_mac_pair_ = nullptr;
  ::memset(&option_length_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&protocol_type_) -
      reinterpret_cast<char*>(&option_length_)) + sizeof(protocol_type_));
  clear_ip();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GeneveEncap::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .tunneloffload.v1alpha1.IPV4Pair outer_ipv4_pair = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_outer_ipv4_pair(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .tunneloffload.v1alpha1.IPV6Pair outer_ipv6_pair = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_outer_ipv6_pair(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .tunneloffload.v1alpha1.MacPair inner_mac_pair = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_inner_mac_pair(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 option_length = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          option_length_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool control_packet = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          control_packet_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool critical_option_present = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          critical_option_present_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 vni = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          vni_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 protocol_type = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          protocol_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .tunneloffload.v1alpha1.GeneveOption geneve_option = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_geneve_option(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<74>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GeneveEncap::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:tunneloffload.v1alpha1.GeneveEncap)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .tunneloffload.v1alpha1.IPV4Pair outer_ipv4_pair = 1;
  if (_internal_has_outer_ipv4_pair()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::outer_ipv4_pair(this), target, stream);
  }

  // .tunneloffload.v1alpha1.IPV6Pair outer_ipv6_pair = 2;
  if (_internal_has_outer_ipv6_pair()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::outer_ipv6_pair(this), target, stream);
  }

  // .tunneloffload.v1alpha1.MacPair inner_mac_pair = 3;
  if (this->_internal_has_inner_mac_pair()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::inner_mac_pair(this), target, stream);
  }

  // uint32 option_length = 4;
  if (this->_internal_option_length() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->_internal_option_length(), target);
  }

  // bool control_packet = 5;
  if (this->_internal_control_packet() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(5, this->_internal_control_packet(), target);
  }

  // bool critical_option_present = 6;
  if (this->_internal_critical_option_present() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(6, this->_internal_critical_option_present(), target);
  }

  // uint32 vni = 7;
  if (this->_internal_vni() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(7, this->_internal_vni(), target);
  }

  // uint32 protocol_type = 8;
  if (this->_internal_protocol_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(8, this->_internal_protocol_type(), target);
  }

  // repeated .tunneloffload.v1alpha1.GeneveOption geneve_option = 9;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_geneve_option_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, this->_internal_geneve_option(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tunneloffload.v1alpha1.GeneveEncap)
  return target;
}

size_t GeneveEncap::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:tunneloffload.v1alpha1.GeneveEncap)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .tunneloffload.v1alpha1.GeneveOption geneve_option = 9;
  total_size += 1UL * this->_internal_geneve_option_size();
  for (const auto& msg : this->geneve_option_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .tunneloffload.v1alpha1.MacPair inner_mac_pair = 3;
  if (this->_internal_has_inner_mac_pair()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *inner_mac_pair_);
  }

  // uint32 option_length = 4;
  if (this->_internal_option_length() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_option_length());
  }

  // bool control_packet = 5;
  if (this->_internal_control_packet() != 0) {
    total_size += 1 + 1;
  }

  // bool critical_option_present = 6;
  if (this->_internal_critical_option_present() != 0) {
    total_size += 1 + 1;
  }

  // uint32 vni = 7;
  if (this->_internal_vni() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_vni());
  }

  // uint32 protocol_type = 8;
  if (this->_internal_protocol_type() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_protocol_type());
  }

  switch (ip_case()) {
    // .tunneloffload.v1alpha1.IPV4Pair outer_ipv4_pair = 1;
    case kOuterIpv4Pair: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *ip_.outer_ipv4_pair_);
      break;
    }
    // .tunneloffload.v1alpha1.IPV6Pair outer_ipv6_pair = 2;
    case kOuterIpv6Pair: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *ip_.outer_ipv6_pair_);
      break;
    }
    case IP_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GeneveEncap::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    GeneveEncap::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GeneveEncap::GetClassData() const { return &_class_data_; }

void GeneveEncap::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<GeneveEncap *>(to)->MergeFrom(
      static_cast<const GeneveEncap &>(from));
}


void GeneveEncap::MergeFrom(const GeneveEncap& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:tunneloffload.v1alpha1.GeneveEncap)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  geneve_option_.MergeFrom(from.geneve_option_);
  if (from._internal_has_inner_mac_pair()) {
    _internal_mutable_inner_mac_pair()->::tunneloffload::v1alpha1::MacPair::MergeFrom(from._internal_inner_mac_pair());
  }
  if (from._internal_option_length() != 0) {
    _internal_set_option_length(from._internal_option_length());
  }
  if (from._internal_control_packet() != 0) {
    _internal_set_control_packet(from._internal_control_packet());
  }
  if (from._internal_critical_option_present() != 0) {
    _internal_set_critical_option_present(from._internal_critical_option_present());
  }
  if (from._internal_vni() != 0) {
    _internal_set_vni(from._internal_vni());
  }
  if (from._internal_protocol_type() != 0) {
    _internal_set_protocol_type(from._internal_protocol_type());
  }
  switch (from.ip_case()) {
    case kOuterIpv4Pair: {
      _internal_mutable_outer_ipv4_pair()->::tunneloffload::v1alpha1::IPV4Pair::MergeFrom(from._internal_outer_ipv4_pair());
      break;
    }
    case kOuterIpv6Pair: {
      _internal_mutable_outer_ipv6_pair()->::tunneloffload::v1alpha1::IPV6Pair::MergeFrom(from._internal_outer_ipv6_pair());
      break;
    }
    case IP_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GeneveEncap::CopyFrom(const GeneveEncap& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tunneloffload.v1alpha1.GeneveEncap)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GeneveEncap::IsInitialized() const {
  return true;
}

void GeneveEncap::InternalSwap(GeneveEncap* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  geneve_option_.InternalSwap(&other->geneve_option_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GeneveEncap, protocol_type_)
      + sizeof(GeneveEncap::protocol_type_)
      - PROTOBUF_FIELD_OFFSET(GeneveEncap, inner_mac_pair_)>(
          reinterpret_cast<char*>(&inner_mac_pair_),
          reinterpret_cast<char*>(&other->inner_mac_pair_));
  swap(ip_, other->ip_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata GeneveEncap::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_tunneloffload_2eproto_getter, &descriptor_table_tunneloffload_2eproto_once,
      file_level_metadata_tunneloffload_2eproto[13]);
}

// ===================================================================

class GeneveDecap::_Internal {
 public:
};

GeneveDecap::GeneveDecap(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:tunneloffload.v1alpha1.GeneveDecap)
}
GeneveDecap::GeneveDecap(const GeneveDecap& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:tunneloffload.v1alpha1.GeneveDecap)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GeneveDecap::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GeneveDecap::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata GeneveDecap::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_tunneloffload_2eproto_getter, &descriptor_table_tunneloffload_2eproto_once,
      file_level_metadata_tunneloffload_2eproto[14]);
}

// ===================================================================

class MacPair::_Internal {
 public:
};

MacPair::MacPair(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:tunneloffload.v1alpha1.MacPair)
}
MacPair::MacPair(const MacPair& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  destination_mac_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    destination_mac_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_destination_mac().empty()) {
    destination_mac_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_destination_mac(), 
      GetArenaForAllocation());
  }
  source_mac_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    source_mac_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_source_mac().empty()) {
    source_mac_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_source_mac(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:tunneloffload.v1alpha1.MacPair)
}

inline void MacPair::SharedCtor() {
destination_mac_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  destination_mac_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
source_mac_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  source_mac_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

MacPair::~MacPair() {
  // @@protoc_insertion_point(destructor:tunneloffload.v1alpha1.MacPair)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void MacPair::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  destination_mac_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  source_mac_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void MacPair::ArenaDtor(void* object) {
  MacPair* _this = reinterpret_cast< MacPair* >(object);
  (void)_this;
}
void MacPair::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void MacPair::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void MacPair::Clear() {
// @@protoc_insertion_point(message_clear_start:tunneloffload.v1alpha1.MacPair)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  destination_mac_.ClearToEmpty();
  source_mac_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MacPair::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes destination_mac = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_destination_mac();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes source_mac = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_source_mac();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MacPair::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:tunneloffload.v1alpha1.MacPair)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes destination_mac = 1;
  if (!this->_internal_destination_mac().empty()) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_destination_mac(), target);
  }

  // bytes source_mac = 2;
  if (!this->_internal_source_mac().empty()) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_source_mac(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tunneloffload.v1alpha1.MacPair)
  return target;
}

size_t MacPair::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:tunneloffload.v1alpha1.MacPair)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes destination_mac = 1;
  if (!this->_internal_destination_mac().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_destination_mac());
  }

  // bytes source_mac = 2;
  if (!this->_internal_source_mac().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_source_mac());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MacPair::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    MacPair::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MacPair::GetClassData() const { return &_class_data_; }

void MacPair::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<MacPair *>(to)->MergeFrom(
      static_cast<const MacPair &>(from));
}


void MacPair::MergeFrom(const MacPair& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:tunneloffload.v1alpha1.MacPair)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_destination_mac().empty()) {
    _internal_set_destination_mac(from._internal_destination_mac());
  }
  if (!from._internal_source_mac().empty()) {
    _internal_set_source_mac(from._internal_source_mac());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MacPair::CopyFrom(const MacPair& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tunneloffload.v1alpha1.MacPair)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MacPair::IsInitialized() const {
  return true;
}

void MacPair::InternalSwap(MacPair* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &destination_mac_, lhs_arena,
      &other->destination_mac_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &source_mac_, lhs_arena,
      &other->source_mac_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata MacPair::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_tunneloffload_2eproto_getter, &descriptor_table_tunneloffload_2eproto_once,
      file_level_metadata_tunneloffload_2eproto[15]);
}

// ===================================================================

class IPV4Pair::_Internal {
 public:
};

IPV4Pair::IPV4Pair(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:tunneloffload.v1alpha1.IPV4Pair)
}
IPV4Pair::IPV4Pair(const IPV4Pair& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&source_ip_, &from.source_ip_,
    static_cast<size_t>(reinterpret_cast<char*>(&destination_ip_) -
    reinterpret_cast<char*>(&source_ip_)) + sizeof(destination_ip_));
  // @@protoc_insertion_point(copy_constructor:tunneloffload.v1alpha1.IPV4Pair)
}

inline void IPV4Pair::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&source_ip_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&destination_ip_) -
    reinterpret_cast<char*>(&source_ip_)) + sizeof(destination_ip_));
}

IPV4Pair::~IPV4Pair() {
  // @@protoc_insertion_point(destructor:tunneloffload.v1alpha1.IPV4Pair)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void IPV4Pair::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void IPV4Pair::ArenaDtor(void* object) {
  IPV4Pair* _this = reinterpret_cast< IPV4Pair* >(object);
  (void)_this;
}
void IPV4Pair::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void IPV4Pair::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void IPV4Pair::Clear() {
// @@protoc_insertion_point(message_clear_start:tunneloffload.v1alpha1.IPV4Pair)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&source_ip_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&destination_ip_) -
      reinterpret_cast<char*>(&source_ip_)) + sizeof(destination_ip_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* IPV4Pair::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // fixed32 source_ip = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          source_ip_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // fixed32 destination_ip = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          destination_ip_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IPV4Pair::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:tunneloffload.v1alpha1.IPV4Pair)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // fixed32 source_ip = 1;
  if (this->_internal_source_ip() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFixed32ToArray(1, this->_internal_source_ip(), target);
  }

  // fixed32 destination_ip = 2;
  if (this->_internal_destination_ip() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFixed32ToArray(2, this->_internal_destination_ip(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tunneloffload.v1alpha1.IPV4Pair)
  return target;
}

size_t IPV4Pair::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:tunneloffload.v1alpha1.IPV4Pair)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // fixed32 source_ip = 1;
  if (this->_internal_source_ip() != 0) {
    total_size += 1 + 4;
  }

  // fixed32 destination_ip = 2;
  if (this->_internal_destination_ip() != 0) {
    total_size += 1 + 4;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData IPV4Pair::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    IPV4Pair::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*IPV4Pair::GetClassData() const { return &_class_data_; }

void IPV4Pair::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<IPV4Pair *>(to)->MergeFrom(
      static_cast<const IPV4Pair &>(from));
}


void IPV4Pair::MergeFrom(const IPV4Pair& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:tunneloffload.v1alpha1.IPV4Pair)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_source_ip() != 0) {
    _internal_set_source_ip(from._internal_source_ip());
  }
  if (from._internal_destination_ip() != 0) {
    _internal_set_destination_ip(from._internal_destination_ip());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void IPV4Pair::CopyFrom(const IPV4Pair& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tunneloffload.v1alpha1.IPV4Pair)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IPV4Pair::IsInitialized() const {
  return true;
}

void IPV4Pair::InternalSwap(IPV4Pair* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(IPV4Pair, destination_ip_)
      + sizeof(IPV4Pair::destination_ip_)
      - PROTOBUF_FIELD_OFFSET(IPV4Pair, source_ip_)>(
          reinterpret_cast<char*>(&source_ip_),
          reinterpret_cast<char*>(&other->source_ip_));
}

::PROTOBUF_NAMESPACE_ID::Metadata IPV4Pair::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_tunneloffload_2eproto_getter, &descriptor_table_tunneloffload_2eproto_once,
      file_level_metadata_tunneloffload_2eproto[16]);
}

// ===================================================================

class IPV6Pair::_Internal {
 public:
};

IPV6Pair::IPV6Pair(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:tunneloffload.v1alpha1.IPV6Pair)
}
IPV6Pair::IPV6Pair(const IPV6Pair& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  source_ip_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    source_ip_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_source_ip().empty()) {
    source_ip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_source_ip(), 
      GetArenaForAllocation());
  }
  destination_ip_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    destination_ip_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_destination_ip().empty()) {
    destination_ip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_destination_ip(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:tunneloffload.v1alpha1.IPV6Pair)
}

inline void IPV6Pair::SharedCtor() {
source_ip_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  source_ip_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
destination_ip_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  destination_ip_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

IPV6Pair::~IPV6Pair() {
  // @@protoc_insertion_point(destructor:tunneloffload.v1alpha1.IPV6Pair)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void IPV6Pair::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  source_ip_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  destination_ip_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void IPV6Pair::ArenaDtor(void* object) {
  IPV6Pair* _this = reinterpret_cast< IPV6Pair* >(object);
  (void)_this;
}
void IPV6Pair::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void IPV6Pair::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void IPV6Pair::Clear() {
// @@protoc_insertion_point(message_clear_start:tunneloffload.v1alpha1.IPV6Pair)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  source_ip_.ClearToEmpty();
  destination_ip_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* IPV6Pair::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes source_ip = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_source_ip();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes destination_ip = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_destination_ip();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IPV6Pair::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:tunneloffload.v1alpha1.IPV6Pair)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes source_ip = 1;
  if (!this->_internal_source_ip().empty()) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_source_ip(), target);
  }

  // bytes destination_ip = 2;
  if (!this->_internal_destination_ip().empty()) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_destination_ip(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tunneloffload.v1alpha1.IPV6Pair)
  return target;
}

size_t IPV6Pair::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:tunneloffload.v1alpha1.IPV6Pair)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes source_ip = 1;
  if (!this->_internal_source_ip().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_source_ip());
  }

  // bytes destination_ip = 2;
  if (!this->_internal_destination_ip().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_destination_ip());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData IPV6Pair::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    IPV6Pair::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*IPV6Pair::GetClassData() const { return &_class_data_; }

void IPV6Pair::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<IPV6Pair *>(to)->MergeFrom(
      static_cast<const IPV6Pair &>(from));
}


void IPV6Pair::MergeFrom(const IPV6Pair& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:tunneloffload.v1alpha1.IPV6Pair)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_source_ip().empty()) {
    _internal_set_source_ip(from._internal_source_ip());
  }
  if (!from._internal_destination_ip().empty()) {
    _internal_set_destination_ip(from._internal_destination_ip());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void IPV6Pair::CopyFrom(const IPV6Pair& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tunneloffload.v1alpha1.IPV6Pair)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IPV6Pair::IsInitialized() const {
  return true;
}

void IPV6Pair::InternalSwap(IPV6Pair* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &source_ip_, lhs_arena,
      &other->source_ip_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &destination_ip_, lhs_arena,
      &other->destination_ip_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata IPV6Pair::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_tunneloffload_2eproto_getter, &descriptor_table_tunneloffload_2eproto_once,
      file_level_metadata_tunneloffload_2eproto[17]);
}

// ===================================================================

class IPV4Match::_Internal {
 public:
};

IPV4Match::IPV4Match(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:tunneloffload.v1alpha1.IPV4Match)
}
IPV4Match::IPV4Match(const IPV4Match& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&source_ip_, &from.source_ip_,
    static_cast<size_t>(reinterpret_cast<char*>(&destination_ip_prefix_) -
    reinterpret_cast<char*>(&source_ip_)) + sizeof(destination_ip_prefix_));
  // @@protoc_insertion_point(copy_constructor:tunneloffload.v1alpha1.IPV4Match)
}

inline void IPV4Match::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&source_ip_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&destination_ip_prefix_) -
    reinterpret_cast<char*>(&source_ip_)) + sizeof(destination_ip_prefix_));
}

IPV4Match::~IPV4Match() {
  // @@protoc_insertion_point(destructor:tunneloffload.v1alpha1.IPV4Match)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void IPV4Match::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void IPV4Match::ArenaDtor(void* object) {
  IPV4Match* _this = reinterpret_cast< IPV4Match* >(object);
  (void)_this;
}
void IPV4Match::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void IPV4Match::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void IPV4Match::Clear() {
// @@protoc_insertion_point(message_clear_start:tunneloffload.v1alpha1.IPV4Match)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&source_ip_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&destination_ip_prefix_) -
      reinterpret_cast<char*>(&source_ip_)) + sizeof(destination_ip_prefix_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* IPV4Match::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // fixed32 source_ip = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          source_ip_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // uint32 source_ip_prefix = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          source_ip_prefix_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // fixed32 destination_ip = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          destination_ip_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // uint32 destination_ip_prefix = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          destination_ip_prefix_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IPV4Match::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:tunneloffload.v1alpha1.IPV4Match)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // fixed32 source_ip = 1;
  if (this->_internal_source_ip() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFixed32ToArray(1, this->_internal_source_ip(), target);
  }

  // uint32 source_ip_prefix = 2;
  if (this->_internal_source_ip_prefix() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_source_ip_prefix(), target);
  }

  // fixed32 destination_ip = 3;
  if (this->_internal_destination_ip() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFixed32ToArray(3, this->_internal_destination_ip(), target);
  }

  // uint32 destination_ip_prefix = 4;
  if (this->_internal_destination_ip_prefix() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->_internal_destination_ip_prefix(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tunneloffload.v1alpha1.IPV4Match)
  return target;
}

size_t IPV4Match::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:tunneloffload.v1alpha1.IPV4Match)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // fixed32 source_ip = 1;
  if (this->_internal_source_ip() != 0) {
    total_size += 1 + 4;
  }

  // uint32 source_ip_prefix = 2;
  if (this->_internal_source_ip_prefix() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_source_ip_prefix());
  }

  // fixed32 destination_ip = 3;
  if (this->_internal_destination_ip() != 0) {
    total_size += 1 + 4;
  }

  // uint32 destination_ip_prefix = 4;
  if (this->_internal_destination_ip_prefix() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_destination_ip_prefix());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData IPV4Match::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    IPV4Match::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*IPV4Match::GetClassData() const { return &_class_data_; }

void IPV4Match::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<IPV4Match *>(to)->MergeFrom(
      static_cast<const IPV4Match &>(from));
}


void IPV4Match::MergeFrom(const IPV4Match& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:tunneloffload.v1alpha1.IPV4Match)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_source_ip() != 0) {
    _internal_set_source_ip(from._internal_source_ip());
  }
  if (from._internal_source_ip_prefix() != 0) {
    _internal_set_source_ip_prefix(from._internal_source_ip_prefix());
  }
  if (from._internal_destination_ip() != 0) {
    _internal_set_destination_ip(from._internal_destination_ip());
  }
  if (from._internal_destination_ip_prefix() != 0) {
    _internal_set_destination_ip_prefix(from._internal_destination_ip_prefix());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void IPV4Match::CopyFrom(const IPV4Match& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tunneloffload.v1alpha1.IPV4Match)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IPV4Match::IsInitialized() const {
  return true;
}

void IPV4Match::InternalSwap(IPV4Match* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(IPV4Match, destination_ip_prefix_)
      + sizeof(IPV4Match::destination_ip_prefix_)
      - PROTOBUF_FIELD_OFFSET(IPV4Match, source_ip_)>(
          reinterpret_cast<char*>(&source_ip_),
          reinterpret_cast<char*>(&other->source_ip_));
}

::PROTOBUF_NAMESPACE_ID::Metadata IPV4Match::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_tunneloffload_2eproto_getter, &descriptor_table_tunneloffload_2eproto_once,
      file_level_metadata_tunneloffload_2eproto[18]);
}

// ===================================================================

class IPV6Match::_Internal {
 public:
};

IPV6Match::IPV6Match(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:tunneloffload.v1alpha1.IPV6Match)
}
IPV6Match::IPV6Match(const IPV6Match& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  source_ip_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    source_ip_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_source_ip().empty()) {
    source_ip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_source_ip(), 
      GetArenaForAllocation());
  }
  destination_ip_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    destination_ip_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_destination_ip().empty()) {
    destination_ip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_destination_ip(), 
      GetArenaForAllocation());
  }
  ::memcpy(&source_ip_prefix_, &from.source_ip_prefix_,
    static_cast<size_t>(reinterpret_cast<char*>(&destination_ip_prefix_) -
    reinterpret_cast<char*>(&source_ip_prefix_)) + sizeof(destination_ip_prefix_));
  // @@protoc_insertion_point(copy_constructor:tunneloffload.v1alpha1.IPV6Match)
}

inline void IPV6Match::SharedCtor() {
source_ip_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  source_ip_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
destination_ip_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  destination_ip_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&source_ip_prefix_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&destination_ip_prefix_) -
    reinterpret_cast<char*>(&source_ip_prefix_)) + sizeof(destination_ip_prefix_));
}

IPV6Match::~IPV6Match() {
  // @@protoc_insertion_point(destructor:tunneloffload.v1alpha1.IPV6Match)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void IPV6Match::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  source_ip_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  destination_ip_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void IPV6Match::ArenaDtor(void* object) {
  IPV6Match* _this = reinterpret_cast< IPV6Match* >(object);
  (void)_this;
}
void IPV6Match::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void IPV6Match::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void IPV6Match::Clear() {
// @@protoc_insertion_point(message_clear_start:tunneloffload.v1alpha1.IPV6Match)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  source_ip_.ClearToEmpty();
  destination_ip_.ClearToEmpty();
  ::memset(&source_ip_prefix_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&destination_ip_prefix_) -
      reinterpret_cast<char*>(&source_ip_prefix_)) + sizeof(destination_ip_prefix_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* IPV6Match::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes source_ip = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_source_ip();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 source_ip_prefix = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          source_ip_prefix_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes destination_ip = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_destination_ip();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 destination_ip_prefix = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          destination_ip_prefix_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IPV6Match::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:tunneloffload.v1alpha1.IPV6Match)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes source_ip = 1;
  if (!this->_internal_source_ip().empty()) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_source_ip(), target);
  }

  // uint32 source_ip_prefix = 2;
  if (this->_internal_source_ip_prefix() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_source_ip_prefix(), target);
  }

  // bytes destination_ip = 3;
  if (!this->_internal_destination_ip().empty()) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_destination_ip(), target);
  }

  // uint32 destination_ip_prefix = 4;
  if (this->_internal_destination_ip_prefix() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->_internal_destination_ip_prefix(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tunneloffload.v1alpha1.IPV6Match)
  return target;
}

size_t IPV6Match::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:tunneloffload.v1alpha1.IPV6Match)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes source_ip = 1;
  if (!this->_internal_source_ip().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_source_ip());
  }

  // bytes destination_ip = 3;
  if (!this->_internal_destination_ip().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_destination_ip());
  }

  // uint32 source_ip_prefix = 2;
  if (this->_internal_source_ip_prefix() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_source_ip_prefix());
  }

  // uint32 destination_ip_prefix = 4;
  if (this->_internal_destination_ip_prefix() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_destination_ip_prefix());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData IPV6Match::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    IPV6Match::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*IPV6Match::GetClassData() const { return &_class_data_; }

void IPV6Match::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<IPV6Match *>(to)->MergeFrom(
      static_cast<const IPV6Match &>(from));
}


void IPV6Match::MergeFrom(const IPV6Match& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:tunneloffload.v1alpha1.IPV6Match)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_source_ip().empty()) {
    _internal_set_source_ip(from._internal_source_ip());
  }
  if (!from._internal_destination_ip().empty()) {
    _internal_set_destination_ip(from._internal_destination_ip());
  }
  if (from._internal_source_ip_prefix() != 0) {
    _internal_set_source_ip_prefix(from._internal_source_ip_prefix());
  }
  if (from._internal_destination_ip_prefix() != 0) {
    _internal_set_destination_ip_prefix(from._internal_destination_ip_prefix());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void IPV6Match::CopyFrom(const IPV6Match& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tunneloffload.v1alpha1.IPV6Match)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IPV6Match::IsInitialized() const {
  return true;
}

void IPV6Match::InternalSwap(IPV6Match* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &source_ip_, lhs_arena,
      &other->source_ip_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &destination_ip_, lhs_arena,
      &other->destination_ip_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(IPV6Match, destination_ip_prefix_)
      + sizeof(IPV6Match::destination_ip_prefix_)
      - PROTOBUF_FIELD_OFFSET(IPV6Match, source_ip_prefix_)>(
          reinterpret_cast<char*>(&source_ip_prefix_),
          reinterpret_cast<char*>(&other->source_ip_prefix_));
}

::PROTOBUF_NAMESPACE_ID::Metadata IPV6Match::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_tunneloffload_2eproto_getter, &descriptor_table_tunneloffload_2eproto_once,
      file_level_metadata_tunneloffload_2eproto[19]);
}

// ===================================================================

class Nat::_Internal {
 public:
};

Nat::Nat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:tunneloffload.v1alpha1.Nat)
}
Nat::Nat(const Nat& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  source_ip_ = from.source_ip_;
  // @@protoc_insertion_point(copy_constructor:tunneloffload.v1alpha1.Nat)
}

inline void Nat::SharedCtor() {
source_ip_ = 0u;
}

Nat::~Nat() {
  // @@protoc_insertion_point(destructor:tunneloffload.v1alpha1.Nat)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void Nat::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Nat::ArenaDtor(void* object) {
  Nat* _this = reinterpret_cast< Nat* >(object);
  (void)_this;
}
void Nat::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Nat::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Nat::Clear() {
// @@protoc_insertion_point(message_clear_start:tunneloffload.v1alpha1.Nat)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  source_ip_ = 0u;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Nat::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 source_ip = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          source_ip_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Nat::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:tunneloffload.v1alpha1.Nat)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 source_ip = 1;
  if (this->_internal_source_ip() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_source_ip(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tunneloffload.v1alpha1.Nat)
  return target;
}

size_t Nat::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:tunneloffload.v1alpha1.Nat)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 source_ip = 1;
  if (this->_internal_source_ip() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_source_ip());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Nat::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Nat::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Nat::GetClassData() const { return &_class_data_; }

void Nat::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Nat *>(to)->MergeFrom(
      static_cast<const Nat &>(from));
}


void Nat::MergeFrom(const Nat& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:tunneloffload.v1alpha1.Nat)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_source_ip() != 0) {
    _internal_set_source_ip(from._internal_source_ip());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Nat::CopyFrom(const Nat& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tunneloffload.v1alpha1.Nat)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Nat::IsInitialized() const {
  return true;
}

void Nat::InternalSwap(Nat* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(source_ip_, other->source_ip_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Nat::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_tunneloffload_2eproto_getter, &descriptor_table_tunneloffload_2eproto_once,
      file_level_metadata_tunneloffload_2eproto[20]);
}

// ===================================================================

class IPSecEnc::_Internal {
 public:
  static const ::tunneloffload::v1alpha1::IPSecSAParams& ipsec_sa(const IPSecEnc* msg);
  static const ::tunneloffload::v1alpha1::IPV4Pair& ipv4_tunnel(const IPSecEnc* msg);
  static const ::tunneloffload::v1alpha1::IPV6Pair& ipv6_tunnel(const IPSecEnc* msg);
};

const ::tunneloffload::v1alpha1::IPSecSAParams&
IPSecEnc::_Internal::ipsec_sa(const IPSecEnc* msg) {
  return *msg->ipsec_sa_;
}
const ::tunneloffload::v1alpha1::IPV4Pair&
IPSecEnc::_Internal::ipv4_tunnel(const IPSecEnc* msg) {
  return *msg->tunnelIps_.ipv4_tunnel_;
}
const ::tunneloffload::v1alpha1::IPV6Pair&
IPSecEnc::_Internal::ipv6_tunnel(const IPSecEnc* msg) {
  return *msg->tunnelIps_.ipv6_tunnel_;
}
void IPSecEnc::set_allocated_ipv4_tunnel(::tunneloffload::v1alpha1::IPV4Pair* ipv4_tunnel) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_tunnelIps();
  if (ipv4_tunnel) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::tunneloffload::v1alpha1::IPV4Pair>::GetOwningArena(ipv4_tunnel);
    if (message_arena != submessage_arena) {
      ipv4_tunnel = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ipv4_tunnel, submessage_arena);
    }
    set_has_ipv4_tunnel();
    tunnelIps_.ipv4_tunnel_ = ipv4_tunnel;
  }
  // @@protoc_insertion_point(field_set_allocated:tunneloffload.v1alpha1.IPSecEnc.ipv4_tunnel)
}
void IPSecEnc::set_allocated_ipv6_tunnel(::tunneloffload::v1alpha1::IPV6Pair* ipv6_tunnel) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_tunnelIps();
  if (ipv6_tunnel) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::tunneloffload::v1alpha1::IPV6Pair>::GetOwningArena(ipv6_tunnel);
    if (message_arena != submessage_arena) {
      ipv6_tunnel = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ipv6_tunnel, submessage_arena);
    }
    set_has_ipv6_tunnel();
    tunnelIps_.ipv6_tunnel_ = ipv6_tunnel;
  }
  // @@protoc_insertion_point(field_set_allocated:tunneloffload.v1alpha1.IPSecEnc.ipv6_tunnel)
}
IPSecEnc::IPSecEnc(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:tunneloffload.v1alpha1.IPSecEnc)
}
IPSecEnc::IPSecEnc(const IPSecEnc& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_ipsec_sa()) {
    ipsec_sa_ = new ::tunneloffload::v1alpha1::IPSecSAParams(*from.ipsec_sa_);
  } else {
    ipsec_sa_ = nullptr;
  }
  ::memcpy(&tunnel_type_, &from.tunnel_type_,
    static_cast<size_t>(reinterpret_cast<char*>(&encryption_type_) -
    reinterpret_cast<char*>(&tunnel_type_)) + sizeof(encryption_type_));
  clear_has_tunnelIps();
  switch (from.tunnelIps_case()) {
    case kIpv4Tunnel: {
      _internal_mutable_ipv4_tunnel()->::tunneloffload::v1alpha1::IPV4Pair::MergeFrom(from._internal_ipv4_tunnel());
      break;
    }
    case kIpv6Tunnel: {
      _internal_mutable_ipv6_tunnel()->::tunneloffload::v1alpha1::IPV6Pair::MergeFrom(from._internal_ipv6_tunnel());
      break;
    }
    case TUNNELIPS_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:tunneloffload.v1alpha1.IPSecEnc)
}

inline void IPSecEnc::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&ipsec_sa_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&encryption_type_) -
    reinterpret_cast<char*>(&ipsec_sa_)) + sizeof(encryption_type_));
clear_has_tunnelIps();
}

IPSecEnc::~IPSecEnc() {
  // @@protoc_insertion_point(destructor:tunneloffload.v1alpha1.IPSecEnc)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void IPSecEnc::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete ipsec_sa_;
  if (has_tunnelIps()) {
    clear_tunnelIps();
  }
}

void IPSecEnc::ArenaDtor(void* object) {
  IPSecEnc* _this = reinterpret_cast< IPSecEnc* >(object);
  (void)_this;
}
void IPSecEnc::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void IPSecEnc::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void IPSecEnc::clear_tunnelIps() {
// @@protoc_insertion_point(one_of_clear_start:tunneloffload.v1alpha1.IPSecEnc)
  switch (tunnelIps_case()) {
    case kIpv4Tunnel: {
      if (GetArenaForAllocation() == nullptr) {
        delete tunnelIps_.ipv4_tunnel_;
      }
      break;
    }
    case kIpv6Tunnel: {
      if (GetArenaForAllocation() == nullptr) {
        delete tunnelIps_.ipv6_tunnel_;
      }
      break;
    }
    case TUNNELIPS_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = TUNNELIPS_NOT_SET;
}


void IPSecEnc::Clear() {
// @@protoc_insertion_point(message_clear_start:tunneloffload.v1alpha1.IPSecEnc)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && ipsec_sa_ != nullptr) {
    delete ipsec_sa_;
  }
  ipsec_sa_ = nullptr;
  ::memset(&tunnel_type_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&encryption_type_) -
      reinterpret_cast<char*>(&tunnel_type_)) + sizeof(encryption_type_));
  clear_tunnelIps();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* IPSecEnc::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .tunneloffload.v1alpha1.IPSecTunnelType tunnel_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_tunnel_type(static_cast<::tunneloffload::v1alpha1::IPSecTunnelType>(val));
        } else
          goto handle_unusual;
        continue;
      // .tunneloffload.v1alpha1.EncType encryption_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_encryption_type(static_cast<::tunneloffload::v1alpha1::EncType>(val));
        } else
          goto handle_unusual;
        continue;
      // .tunneloffload.v1alpha1.IPSecSAParams ipsec_sa = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_ipsec_sa(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .tunneloffload.v1alpha1.IPV4Pair ipv4_tunnel = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_ipv4_tunnel(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .tunneloffload.v1alpha1.IPV6Pair ipv6_tunnel = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_ipv6_tunnel(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IPSecEnc::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:tunneloffload.v1alpha1.IPSecEnc)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .tunneloffload.v1alpha1.IPSecTunnelType tunnel_type = 1;
  if (this->_internal_tunnel_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_tunnel_type(), target);
  }

  // .tunneloffload.v1alpha1.EncType encryption_type = 2;
  if (this->_internal_encryption_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_encryption_type(), target);
  }

  // .tunneloffload.v1alpha1.IPSecSAParams ipsec_sa = 3;
  if (this->_internal_has_ipsec_sa()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::ipsec_sa(this), target, stream);
  }

  // .tunneloffload.v1alpha1.IPV4Pair ipv4_tunnel = 4;
  if (_internal_has_ipv4_tunnel()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::ipv4_tunnel(this), target, stream);
  }

  // .tunneloffload.v1alpha1.IPV6Pair ipv6_tunnel = 5;
  if (_internal_has_ipv6_tunnel()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        5, _Internal::ipv6_tunnel(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tunneloffload.v1alpha1.IPSecEnc)
  return target;
}

size_t IPSecEnc::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:tunneloffload.v1alpha1.IPSecEnc)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .tunneloffload.v1alpha1.IPSecSAParams ipsec_sa = 3;
  if (this->_internal_has_ipsec_sa()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *ipsec_sa_);
  }

  // .tunneloffload.v1alpha1.IPSecTunnelType tunnel_type = 1;
  if (this->_internal_tunnel_type() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_tunnel_type());
  }

  // .tunneloffload.v1alpha1.EncType encryption_type = 2;
  if (this->_internal_encryption_type() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_encryption_type());
  }

  switch (tunnelIps_case()) {
    // .tunneloffload.v1alpha1.IPV4Pair ipv4_tunnel = 4;
    case kIpv4Tunnel: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *tunnelIps_.ipv4_tunnel_);
      break;
    }
    // .tunneloffload.v1alpha1.IPV6Pair ipv6_tunnel = 5;
    case kIpv6Tunnel: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *tunnelIps_.ipv6_tunnel_);
      break;
    }
    case TUNNELIPS_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData IPSecEnc::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    IPSecEnc::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*IPSecEnc::GetClassData() const { return &_class_data_; }

void IPSecEnc::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<IPSecEnc *>(to)->MergeFrom(
      static_cast<const IPSecEnc &>(from));
}


void IPSecEnc::MergeFrom(const IPSecEnc& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:tunneloffload.v1alpha1.IPSecEnc)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_ipsec_sa()) {
    _internal_mutable_ipsec_sa()->::tunneloffload::v1alpha1::IPSecSAParams::MergeFrom(from._internal_ipsec_sa());
  }
  if (from._internal_tunnel_type() != 0) {
    _internal_set_tunnel_type(from._internal_tunnel_type());
  }
  if (from._internal_encryption_type() != 0) {
    _internal_set_encryption_type(from._internal_encryption_type());
  }
  switch (from.tunnelIps_case()) {
    case kIpv4Tunnel: {
      _internal_mutable_ipv4_tunnel()->::tunneloffload::v1alpha1::IPV4Pair::MergeFrom(from._internal_ipv4_tunnel());
      break;
    }
    case kIpv6Tunnel: {
      _internal_mutable_ipv6_tunnel()->::tunneloffload::v1alpha1::IPV6Pair::MergeFrom(from._internal_ipv6_tunnel());
      break;
    }
    case TUNNELIPS_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void IPSecEnc::CopyFrom(const IPSecEnc& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tunneloffload.v1alpha1.IPSecEnc)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IPSecEnc::IsInitialized() const {
  return true;
}

void IPSecEnc::InternalSwap(IPSecEnc* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(IPSecEnc, encryption_type_)
      + sizeof(IPSecEnc::encryption_type_)
      - PROTOBUF_FIELD_OFFSET(IPSecEnc, ipsec_sa_)>(
          reinterpret_cast<char*>(&ipsec_sa_),
          reinterpret_cast<char*>(&other->ipsec_sa_));
  swap(tunnelIps_, other->tunnelIps_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata IPSecEnc::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_tunneloffload_2eproto_getter, &descriptor_table_tunneloffload_2eproto_once,
      file_level_metadata_tunneloffload_2eproto[21]);
}

// ===================================================================

class IPSecDec::_Internal {
 public:
};

IPSecDec::IPSecDec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  ipsec_sas_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:tunneloffload.v1alpha1.IPSecDec)
}
IPSecDec::IPSecDec(const IPSecDec& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      ipsec_sas_(from.ipsec_sas_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&tunnel_type_, &from.tunnel_type_,
    static_cast<size_t>(reinterpret_cast<char*>(&encryption_type_) -
    reinterpret_cast<char*>(&tunnel_type_)) + sizeof(encryption_type_));
  // @@protoc_insertion_point(copy_constructor:tunneloffload.v1alpha1.IPSecDec)
}

inline void IPSecDec::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&tunnel_type_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&encryption_type_) -
    reinterpret_cast<char*>(&tunnel_type_)) + sizeof(encryption_type_));
}

IPSecDec::~IPSecDec() {
  // @@protoc_insertion_point(destructor:tunneloffload.v1alpha1.IPSecDec)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void IPSecDec::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void IPSecDec::ArenaDtor(void* object) {
  IPSecDec* _this = reinterpret_cast< IPSecDec* >(object);
  (void)_this;
}
void IPSecDec::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void IPSecDec::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void IPSecDec::Clear() {
// @@protoc_insertion_point(message_clear_start:tunneloffload.v1alpha1.IPSecDec)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ipsec_sas_.Clear();
  ::memset(&tunnel_type_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&encryption_type_) -
      reinterpret_cast<char*>(&tunnel_type_)) + sizeof(encryption_type_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* IPSecDec::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .tunneloffload.v1alpha1.IPSecTunnelType tunnel_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_tunnel_type(static_cast<::tunneloffload::v1alpha1::IPSecTunnelType>(val));
        } else
          goto handle_unusual;
        continue;
      // .tunneloffload.v1alpha1.EncType encryption_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_encryption_type(static_cast<::tunneloffload::v1alpha1::EncType>(val));
        } else
          goto handle_unusual;
        continue;
      // repeated .tunneloffload.v1alpha1.IPSecSAParams ipsec_sas = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_ipsec_sas(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IPSecDec::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:tunneloffload.v1alpha1.IPSecDec)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .tunneloffload.v1alpha1.IPSecTunnelType tunnel_type = 1;
  if (this->_internal_tunnel_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_tunnel_type(), target);
  }

  // .tunneloffload.v1alpha1.EncType encryption_type = 2;
  if (this->_internal_encryption_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_encryption_type(), target);
  }

  // repeated .tunneloffload.v1alpha1.IPSecSAParams ipsec_sas = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_ipsec_sas_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, this->_internal_ipsec_sas(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tunneloffload.v1alpha1.IPSecDec)
  return target;
}

size_t IPSecDec::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:tunneloffload.v1alpha1.IPSecDec)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .tunneloffload.v1alpha1.IPSecSAParams ipsec_sas = 3;
  total_size += 1UL * this->_internal_ipsec_sas_size();
  for (const auto& msg : this->ipsec_sas_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .tunneloffload.v1alpha1.IPSecTunnelType tunnel_type = 1;
  if (this->_internal_tunnel_type() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_tunnel_type());
  }

  // .tunneloffload.v1alpha1.EncType encryption_type = 2;
  if (this->_internal_encryption_type() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_encryption_type());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData IPSecDec::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    IPSecDec::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*IPSecDec::GetClassData() const { return &_class_data_; }

void IPSecDec::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<IPSecDec *>(to)->MergeFrom(
      static_cast<const IPSecDec &>(from));
}


void IPSecDec::MergeFrom(const IPSecDec& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:tunneloffload.v1alpha1.IPSecDec)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  ipsec_sas_.MergeFrom(from.ipsec_sas_);
  if (from._internal_tunnel_type() != 0) {
    _internal_set_tunnel_type(from._internal_tunnel_type());
  }
  if (from._internal_encryption_type() != 0) {
    _internal_set_encryption_type(from._internal_encryption_type());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void IPSecDec::CopyFrom(const IPSecDec& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tunneloffload.v1alpha1.IPSecDec)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IPSecDec::IsInitialized() const {
  return true;
}

void IPSecDec::InternalSwap(IPSecDec* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ipsec_sas_.InternalSwap(&other->ipsec_sas_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(IPSecDec, encryption_type_)
      + sizeof(IPSecDec::encryption_type_)
      - PROTOBUF_FIELD_OFFSET(IPSecDec, tunnel_type_)>(
          reinterpret_cast<char*>(&tunnel_type_),
          reinterpret_cast<char*>(&other->tunnel_type_));
}

::PROTOBUF_NAMESPACE_ID::Metadata IPSecDec::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_tunneloffload_2eproto_getter, &descriptor_table_tunneloffload_2eproto_once,
      file_level_metadata_tunneloffload_2eproto[22]);
}

// ===================================================================

class IPSecSAParams::_Internal {
 public:
};

IPSecSAParams::IPSecSAParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:tunneloffload.v1alpha1.IPSecSAParams)
}
IPSecSAParams::IPSecSAParams(const IPSecSAParams& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  encryption_key_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    encryption_key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_encryption_key().empty()) {
    encryption_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_encryption_key(), 
      GetArenaForAllocation());
  }
  ::memcpy(&spi_, &from.spi_,
    static_cast<size_t>(reinterpret_cast<char*>(&operation_) -
    reinterpret_cast<char*>(&spi_)) + sizeof(operation_));
  // @@protoc_insertion_point(copy_constructor:tunneloffload.v1alpha1.IPSecSAParams)
}

inline void IPSecSAParams::SharedCtor() {
encryption_key_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  encryption_key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&spi_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&operation_) -
    reinterpret_cast<char*>(&spi_)) + sizeof(operation_));
}

IPSecSAParams::~IPSecSAParams() {
  // @@protoc_insertion_point(destructor:tunneloffload.v1alpha1.IPSecSAParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void IPSecSAParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  encryption_key_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void IPSecSAParams::ArenaDtor(void* object) {
  IPSecSAParams* _this = reinterpret_cast< IPSecSAParams* >(object);
  (void)_this;
}
void IPSecSAParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void IPSecSAParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void IPSecSAParams::Clear() {
// @@protoc_insertion_point(message_clear_start:tunneloffload.v1alpha1.IPSecSAParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  encryption_key_.ClearToEmpty();
  ::memset(&spi_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&operation_) -
      reinterpret_cast<char*>(&spi_)) + sizeof(operation_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* IPSecSAParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 spi = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          spi_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes encryption_key = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_encryption_key();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .tunneloffload.v1alpha1.Operation operation = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_operation(static_cast<::tunneloffload::v1alpha1::Operation>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IPSecSAParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:tunneloffload.v1alpha1.IPSecSAParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 spi = 1;
  if (this->_internal_spi() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_spi(), target);
  }

  // bytes encryption_key = 2;
  if (!this->_internal_encryption_key().empty()) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_encryption_key(), target);
  }

  // .tunneloffload.v1alpha1.Operation operation = 3;
  if (this->_internal_operation() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      3, this->_internal_operation(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tunneloffload.v1alpha1.IPSecSAParams)
  return target;
}

size_t IPSecSAParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:tunneloffload.v1alpha1.IPSecSAParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes encryption_key = 2;
  if (!this->_internal_encryption_key().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_encryption_key());
  }

  // uint32 spi = 1;
  if (this->_internal_spi() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_spi());
  }

  // .tunneloffload.v1alpha1.Operation operation = 3;
  if (this->_internal_operation() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_operation());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData IPSecSAParams::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    IPSecSAParams::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*IPSecSAParams::GetClassData() const { return &_class_data_; }

void IPSecSAParams::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<IPSecSAParams *>(to)->MergeFrom(
      static_cast<const IPSecSAParams &>(from));
}


void IPSecSAParams::MergeFrom(const IPSecSAParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:tunneloffload.v1alpha1.IPSecSAParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_encryption_key().empty()) {
    _internal_set_encryption_key(from._internal_encryption_key());
  }
  if (from._internal_spi() != 0) {
    _internal_set_spi(from._internal_spi());
  }
  if (from._internal_operation() != 0) {
    _internal_set_operation(from._internal_operation());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void IPSecSAParams::CopyFrom(const IPSecSAParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tunneloffload.v1alpha1.IPSecSAParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IPSecSAParams::IsInitialized() const {
  return true;
}

void IPSecSAParams::InternalSwap(IPSecSAParams* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &encryption_key_, lhs_arena,
      &other->encryption_key_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(IPSecSAParams, operation_)
      + sizeof(IPSecSAParams::operation_)
      - PROTOBUF_FIELD_OFFSET(IPSecSAParams, spi_)>(
          reinterpret_cast<char*>(&spi_),
          reinterpret_cast<char*>(&other->spi_));
}

::PROTOBUF_NAMESPACE_ID::Metadata IPSecSAParams::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_tunneloffload_2eproto_getter, &descriptor_table_tunneloffload_2eproto_once,
      file_level_metadata_tunneloffload_2eproto[23]);
}

// ===================================================================

class IPSecTunnel::_Internal {
 public:
  static const ::tunneloffload::v1alpha1::IPSecEnc& ipsec_enc(const IPSecTunnel* msg);
  static const ::tunneloffload::v1alpha1::IPSecDec& ipsec_dec(const IPSecTunnel* msg);
};

const ::tunneloffload::v1alpha1::IPSecEnc&
IPSecTunnel::_Internal::ipsec_enc(const IPSecTunnel* msg) {
  return *msg->ipsec_.ipsec_enc_;
}
const ::tunneloffload::v1alpha1::IPSecDec&
IPSecTunnel::_Internal::ipsec_dec(const IPSecTunnel* msg) {
  return *msg->ipsec_.ipsec_dec_;
}
void IPSecTunnel::set_allocated_ipsec_enc(::tunneloffload::v1alpha1::IPSecEnc* ipsec_enc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_ipsec();
  if (ipsec_enc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::tunneloffload::v1alpha1::IPSecEnc>::GetOwningArena(ipsec_enc);
    if (message_arena != submessage_arena) {
      ipsec_enc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ipsec_enc, submessage_arena);
    }
    set_has_ipsec_enc();
    ipsec_.ipsec_enc_ = ipsec_enc;
  }
  // @@protoc_insertion_point(field_set_allocated:tunneloffload.v1alpha1.IPSecTunnel.ipsec_enc)
}
void IPSecTunnel::set_allocated_ipsec_dec(::tunneloffload::v1alpha1::IPSecDec* ipsec_dec) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_ipsec();
  if (ipsec_dec) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::tunneloffload::v1alpha1::IPSecDec>::GetOwningArena(ipsec_dec);
    if (message_arena != submessage_arena) {
      ipsec_dec = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ipsec_dec, submessage_arena);
    }
    set_has_ipsec_dec();
    ipsec_.ipsec_dec_ = ipsec_dec;
  }
  // @@protoc_insertion_point(field_set_allocated:tunneloffload.v1alpha1.IPSecTunnel.ipsec_dec)
}
IPSecTunnel::IPSecTunnel(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:tunneloffload.v1alpha1.IPSecTunnel)
}
IPSecTunnel::IPSecTunnel(const IPSecTunnel& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_ipsec();
  switch (from.ipsec_case()) {
    case kIpsecEnc: {
      _internal_mutable_ipsec_enc()->::tunneloffload::v1alpha1::IPSecEnc::MergeFrom(from._internal_ipsec_enc());
      break;
    }
    case kIpsecDec: {
      _internal_mutable_ipsec_dec()->::tunneloffload::v1alpha1::IPSecDec::MergeFrom(from._internal_ipsec_dec());
      break;
    }
    case IPSEC_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:tunneloffload.v1alpha1.IPSecTunnel)
}

inline void IPSecTunnel::SharedCtor() {
clear_has_ipsec();
}

IPSecTunnel::~IPSecTunnel() {
  // @@protoc_insertion_point(destructor:tunneloffload.v1alpha1.IPSecTunnel)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void IPSecTunnel::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_ipsec()) {
    clear_ipsec();
  }
}

void IPSecTunnel::ArenaDtor(void* object) {
  IPSecTunnel* _this = reinterpret_cast< IPSecTunnel* >(object);
  (void)_this;
}
void IPSecTunnel::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void IPSecTunnel::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void IPSecTunnel::clear_ipsec() {
// @@protoc_insertion_point(one_of_clear_start:tunneloffload.v1alpha1.IPSecTunnel)
  switch (ipsec_case()) {
    case kIpsecEnc: {
      if (GetArenaForAllocation() == nullptr) {
        delete ipsec_.ipsec_enc_;
      }
      break;
    }
    case kIpsecDec: {
      if (GetArenaForAllocation() == nullptr) {
        delete ipsec_.ipsec_dec_;
      }
      break;
    }
    case IPSEC_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = IPSEC_NOT_SET;
}


void IPSecTunnel::Clear() {
// @@protoc_insertion_point(message_clear_start:tunneloffload.v1alpha1.IPSecTunnel)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_ipsec();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* IPSecTunnel::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .tunneloffload.v1alpha1.IPSecEnc ipsec_enc = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_ipsec_enc(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .tunneloffload.v1alpha1.IPSecDec ipsec_dec = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_ipsec_dec(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IPSecTunnel::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:tunneloffload.v1alpha1.IPSecTunnel)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .tunneloffload.v1alpha1.IPSecEnc ipsec_enc = 1;
  if (_internal_has_ipsec_enc()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::ipsec_enc(this), target, stream);
  }

  // .tunneloffload.v1alpha1.IPSecDec ipsec_dec = 2;
  if (_internal_has_ipsec_dec()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::ipsec_dec(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tunneloffload.v1alpha1.IPSecTunnel)
  return target;
}

size_t IPSecTunnel::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:tunneloffload.v1alpha1.IPSecTunnel)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (ipsec_case()) {
    // .tunneloffload.v1alpha1.IPSecEnc ipsec_enc = 1;
    case kIpsecEnc: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *ipsec_.ipsec_enc_);
      break;
    }
    // .tunneloffload.v1alpha1.IPSecDec ipsec_dec = 2;
    case kIpsecDec: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *ipsec_.ipsec_dec_);
      break;
    }
    case IPSEC_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData IPSecTunnel::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    IPSecTunnel::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*IPSecTunnel::GetClassData() const { return &_class_data_; }

void IPSecTunnel::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<IPSecTunnel *>(to)->MergeFrom(
      static_cast<const IPSecTunnel &>(from));
}


void IPSecTunnel::MergeFrom(const IPSecTunnel& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:tunneloffload.v1alpha1.IPSecTunnel)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.ipsec_case()) {
    case kIpsecEnc: {
      _internal_mutable_ipsec_enc()->::tunneloffload::v1alpha1::IPSecEnc::MergeFrom(from._internal_ipsec_enc());
      break;
    }
    case kIpsecDec: {
      _internal_mutable_ipsec_dec()->::tunneloffload::v1alpha1::IPSecDec::MergeFrom(from._internal_ipsec_dec());
      break;
    }
    case IPSEC_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void IPSecTunnel::CopyFrom(const IPSecTunnel& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tunneloffload.v1alpha1.IPSecTunnel)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IPSecTunnel::IsInitialized() const {
  return true;
}

void IPSecTunnel::InternalSwap(IPSecTunnel* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(ipsec_, other->ipsec_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata IPSecTunnel::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_tunneloffload_2eproto_getter, &descriptor_table_tunneloffload_2eproto_once,
      file_level_metadata_tunneloffload_2eproto[24]);
}

// ===================================================================

class TunnelId::_Internal {
 public:
};

TunnelId::TunnelId(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:tunneloffload.v1alpha1.TunnelId)
}
TunnelId::TunnelId(const TunnelId& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  tunnel_id_ = from.tunnel_id_;
  // @@protoc_insertion_point(copy_constructor:tunneloffload.v1alpha1.TunnelId)
}

inline void TunnelId::SharedCtor() {
tunnel_id_ = uint64_t{0u};
}

TunnelId::~TunnelId() {
  // @@protoc_insertion_point(destructor:tunneloffload.v1alpha1.TunnelId)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void TunnelId::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void TunnelId::ArenaDtor(void* object) {
  TunnelId* _this = reinterpret_cast< TunnelId* >(object);
  (void)_this;
}
void TunnelId::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TunnelId::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void TunnelId::Clear() {
// @@protoc_insertion_point(message_clear_start:tunneloffload.v1alpha1.TunnelId)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  tunnel_id_ = uint64_t{0u};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TunnelId::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 tunnel_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          tunnel_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TunnelId::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:tunneloffload.v1alpha1.TunnelId)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 tunnel_id = 1;
  if (this->_internal_tunnel_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_tunnel_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tunneloffload.v1alpha1.TunnelId)
  return target;
}

size_t TunnelId::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:tunneloffload.v1alpha1.TunnelId)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint64 tunnel_id = 1;
  if (this->_internal_tunnel_id() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_tunnel_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TunnelId::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    TunnelId::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TunnelId::GetClassData() const { return &_class_data_; }

void TunnelId::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<TunnelId *>(to)->MergeFrom(
      static_cast<const TunnelId &>(from));
}


void TunnelId::MergeFrom(const TunnelId& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:tunneloffload.v1alpha1.TunnelId)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_tunnel_id() != 0) {
    _internal_set_tunnel_id(from._internal_tunnel_id());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TunnelId::CopyFrom(const TunnelId& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tunneloffload.v1alpha1.TunnelId)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TunnelId::IsInitialized() const {
  return true;
}

void TunnelId::InternalSwap(TunnelId* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(tunnel_id_, other->tunnel_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TunnelId::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_tunneloffload_2eproto_getter, &descriptor_table_tunneloffload_2eproto_once,
      file_level_metadata_tunneloffload_2eproto[25]);
}

// ===================================================================

class Counters::_Internal {
 public:
};

Counters::Counters(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:tunneloffload.v1alpha1.Counters)
}
Counters::Counters(const Counters& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&in_packets_, &from.in_packets_,
    static_cast<size_t>(reinterpret_cast<char*>(&out_bytes_drops_) -
    reinterpret_cast<char*>(&in_packets_)) + sizeof(out_bytes_drops_));
  // @@protoc_insertion_point(copy_constructor:tunneloffload.v1alpha1.Counters)
}

inline void Counters::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&in_packets_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&out_bytes_drops_) -
    reinterpret_cast<char*>(&in_packets_)) + sizeof(out_bytes_drops_));
}

Counters::~Counters() {
  // @@protoc_insertion_point(destructor:tunneloffload.v1alpha1.Counters)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void Counters::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Counters::ArenaDtor(void* object) {
  Counters* _this = reinterpret_cast< Counters* >(object);
  (void)_this;
}
void Counters::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Counters::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Counters::Clear() {
// @@protoc_insertion_point(message_clear_start:tunneloffload.v1alpha1.Counters)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&in_packets_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&out_bytes_drops_) -
      reinterpret_cast<char*>(&in_packets_)) + sizeof(out_bytes_drops_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Counters::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 in_packets = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          in_packets_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 out_packets = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          out_packets_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 in_bytes = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          in_bytes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 out_bytes = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          out_bytes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 in_packets_drops = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          in_packets_drops_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 out_packets_drops = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          out_packets_drops_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 in_bytes_drops = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          in_bytes_drops_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 out_bytes_drops = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          out_bytes_drops_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Counters::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:tunneloffload.v1alpha1.Counters)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 in_packets = 1;
  if (this->_internal_in_packets() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_in_packets(), target);
  }

  // uint64 out_packets = 2;
  if (this->_internal_out_packets() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(2, this->_internal_out_packets(), target);
  }

  // uint64 in_bytes = 3;
  if (this->_internal_in_bytes() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(3, this->_internal_in_bytes(), target);
  }

  // uint64 out_bytes = 4;
  if (this->_internal_out_bytes() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(4, this->_internal_out_bytes(), target);
  }

  // uint64 in_packets_drops = 5;
  if (this->_internal_in_packets_drops() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(5, this->_internal_in_packets_drops(), target);
  }

  // uint64 out_packets_drops = 6;
  if (this->_internal_out_packets_drops() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(6, this->_internal_out_packets_drops(), target);
  }

  // uint64 in_bytes_drops = 7;
  if (this->_internal_in_bytes_drops() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(7, this->_internal_in_bytes_drops(), target);
  }

  // uint64 out_bytes_drops = 8;
  if (this->_internal_out_bytes_drops() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(8, this->_internal_out_bytes_drops(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tunneloffload.v1alpha1.Counters)
  return target;
}

size_t Counters::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:tunneloffload.v1alpha1.Counters)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint64 in_packets = 1;
  if (this->_internal_in_packets() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_in_packets());
  }

  // uint64 out_packets = 2;
  if (this->_internal_out_packets() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_out_packets());
  }

  // uint64 in_bytes = 3;
  if (this->_internal_in_bytes() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_in_bytes());
  }

  // uint64 out_bytes = 4;
  if (this->_internal_out_bytes() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_out_bytes());
  }

  // uint64 in_packets_drops = 5;
  if (this->_internal_in_packets_drops() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_in_packets_drops());
  }

  // uint64 out_packets_drops = 6;
  if (this->_internal_out_packets_drops() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_out_packets_drops());
  }

  // uint64 in_bytes_drops = 7;
  if (this->_internal_in_bytes_drops() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_in_bytes_drops());
  }

  // uint64 out_bytes_drops = 8;
  if (this->_internal_out_bytes_drops() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_out_bytes_drops());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Counters::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Counters::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Counters::GetClassData() const { return &_class_data_; }

void Counters::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Counters *>(to)->MergeFrom(
      static_cast<const Counters &>(from));
}


void Counters::MergeFrom(const Counters& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:tunneloffload.v1alpha1.Counters)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_in_packets() != 0) {
    _internal_set_in_packets(from._internal_in_packets());
  }
  if (from._internal_out_packets() != 0) {
    _internal_set_out_packets(from._internal_out_packets());
  }
  if (from._internal_in_bytes() != 0) {
    _internal_set_in_bytes(from._internal_in_bytes());
  }
  if (from._internal_out_bytes() != 0) {
    _internal_set_out_bytes(from._internal_out_bytes());
  }
  if (from._internal_in_packets_drops() != 0) {
    _internal_set_in_packets_drops(from._internal_in_packets_drops());
  }
  if (from._internal_out_packets_drops() != 0) {
    _internal_set_out_packets_drops(from._internal_out_packets_drops());
  }
  if (from._internal_in_bytes_drops() != 0) {
    _internal_set_in_bytes_drops(from._internal_in_bytes_drops());
  }
  if (from._internal_out_bytes_drops() != 0) {
    _internal_set_out_bytes_drops(from._internal_out_bytes_drops());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Counters::CopyFrom(const Counters& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tunneloffload.v1alpha1.Counters)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Counters::IsInitialized() const {
  return true;
}

void Counters::InternalSwap(Counters* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Counters, out_bytes_drops_)
      + sizeof(Counters::out_bytes_drops_)
      - PROTOBUF_FIELD_OFFSET(Counters, in_packets_)>(
          reinterpret_cast<char*>(&in_packets_),
          reinterpret_cast<char*>(&other->in_packets_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Counters::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_tunneloffload_2eproto_getter, &descriptor_table_tunneloffload_2eproto_once,
      file_level_metadata_tunneloffload_2eproto[26]);
}

// ===================================================================

class CreateIpTunnelResponses::_Internal {
 public:
};

CreateIpTunnelResponses::CreateIpTunnelResponses(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  responses_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:tunneloffload.v1alpha1.CreateIpTunnelResponses)
}
CreateIpTunnelResponses::CreateIpTunnelResponses(const CreateIpTunnelResponses& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      responses_(from.responses_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&error_status_, &from.error_status_,
    static_cast<size_t>(reinterpret_cast<char*>(&request_status_) -
    reinterpret_cast<char*>(&error_status_)) + sizeof(request_status_));
  // @@protoc_insertion_point(copy_constructor:tunneloffload.v1alpha1.CreateIpTunnelResponses)
}

inline void CreateIpTunnelResponses::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&error_status_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&request_status_) -
    reinterpret_cast<char*>(&error_status_)) + sizeof(request_status_));
}

CreateIpTunnelResponses::~CreateIpTunnelResponses() {
  // @@protoc_insertion_point(destructor:tunneloffload.v1alpha1.CreateIpTunnelResponses)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CreateIpTunnelResponses::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CreateIpTunnelResponses::ArenaDtor(void* object) {
  CreateIpTunnelResponses* _this = reinterpret_cast< CreateIpTunnelResponses* >(object);
  (void)_this;
}
void CreateIpTunnelResponses::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CreateIpTunnelResponses::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CreateIpTunnelResponses::Clear() {
// @@protoc_insertion_point(message_clear_start:tunneloffload.v1alpha1.CreateIpTunnelResponses)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  responses_.Clear();
  ::memset(&error_status_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&request_status_) -
      reinterpret_cast<char*>(&error_status_)) + sizeof(request_status_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CreateIpTunnelResponses::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .tunneloffload.v1alpha1.AddTunnelStatus request_status = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_request_status(static_cast<::tunneloffload::v1alpha1::AddTunnelStatus>(val));
        } else
          goto handle_unusual;
        continue;
      // uint64 error_status = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          error_status_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .tunneloffload.v1alpha1.CreateIpTunnelResponse responses = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_responses(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CreateIpTunnelResponses::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:tunneloffload.v1alpha1.CreateIpTunnelResponses)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .tunneloffload.v1alpha1.AddTunnelStatus request_status = 1;
  if (this->_internal_request_status() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_request_status(), target);
  }

  // uint64 error_status = 2;
  if (this->_internal_error_status() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(2, this->_internal_error_status(), target);
  }

  // repeated .tunneloffload.v1alpha1.CreateIpTunnelResponse responses = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_responses_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, this->_internal_responses(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tunneloffload.v1alpha1.CreateIpTunnelResponses)
  return target;
}

size_t CreateIpTunnelResponses::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:tunneloffload.v1alpha1.CreateIpTunnelResponses)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .tunneloffload.v1alpha1.CreateIpTunnelResponse responses = 3;
  total_size += 1UL * this->_internal_responses_size();
  for (const auto& msg : this->responses_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // uint64 error_status = 2;
  if (this->_internal_error_status() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_error_status());
  }

  // .tunneloffload.v1alpha1.AddTunnelStatus request_status = 1;
  if (this->_internal_request_status() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_request_status());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CreateIpTunnelResponses::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CreateIpTunnelResponses::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CreateIpTunnelResponses::GetClassData() const { return &_class_data_; }

void CreateIpTunnelResponses::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CreateIpTunnelResponses *>(to)->MergeFrom(
      static_cast<const CreateIpTunnelResponses &>(from));
}


void CreateIpTunnelResponses::MergeFrom(const CreateIpTunnelResponses& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:tunneloffload.v1alpha1.CreateIpTunnelResponses)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  responses_.MergeFrom(from.responses_);
  if (from._internal_error_status() != 0) {
    _internal_set_error_status(from._internal_error_status());
  }
  if (from._internal_request_status() != 0) {
    _internal_set_request_status(from._internal_request_status());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CreateIpTunnelResponses::CopyFrom(const CreateIpTunnelResponses& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tunneloffload.v1alpha1.CreateIpTunnelResponses)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CreateIpTunnelResponses::IsInitialized() const {
  return true;
}

void CreateIpTunnelResponses::InternalSwap(CreateIpTunnelResponses* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  responses_.InternalSwap(&other->responses_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CreateIpTunnelResponses, request_status_)
      + sizeof(CreateIpTunnelResponses::request_status_)
      - PROTOBUF_FIELD_OFFSET(CreateIpTunnelResponses, error_status_)>(
          reinterpret_cast<char*>(&error_status_),
          reinterpret_cast<char*>(&other->error_status_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CreateIpTunnelResponses::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_tunneloffload_2eproto_getter, &descriptor_table_tunneloffload_2eproto_once,
      file_level_metadata_tunneloffload_2eproto[27]);
}

// ===================================================================

class CreateIpTunnelResponse::_Internal {
 public:
  static const ::tunneloffload::v1alpha1::Error& error(const CreateIpTunnelResponse* msg);
};

const ::tunneloffload::v1alpha1::Error&
CreateIpTunnelResponse::_Internal::error(const CreateIpTunnelResponse* msg) {
  return *msg->error_;
}
CreateIpTunnelResponse::CreateIpTunnelResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:tunneloffload.v1alpha1.CreateIpTunnelResponse)
}
CreateIpTunnelResponse::CreateIpTunnelResponse(const CreateIpTunnelResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_error()) {
    error_ = new ::tunneloffload::v1alpha1::Error(*from.error_);
  } else {
    error_ = nullptr;
  }
  tunnel_id_ = from.tunnel_id_;
  // @@protoc_insertion_point(copy_constructor:tunneloffload.v1alpha1.CreateIpTunnelResponse)
}

inline void CreateIpTunnelResponse::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&error_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&tunnel_id_) -
    reinterpret_cast<char*>(&error_)) + sizeof(tunnel_id_));
}

CreateIpTunnelResponse::~CreateIpTunnelResponse() {
  // @@protoc_insertion_point(destructor:tunneloffload.v1alpha1.CreateIpTunnelResponse)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CreateIpTunnelResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete error_;
}

void CreateIpTunnelResponse::ArenaDtor(void* object) {
  CreateIpTunnelResponse* _this = reinterpret_cast< CreateIpTunnelResponse* >(object);
  (void)_this;
}
void CreateIpTunnelResponse::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CreateIpTunnelResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CreateIpTunnelResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:tunneloffload.v1alpha1.CreateIpTunnelResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && error_ != nullptr) {
    delete error_;
  }
  error_ = nullptr;
  tunnel_id_ = uint64_t{0u};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CreateIpTunnelResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 tunnel_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          tunnel_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .tunneloffload.v1alpha1.Error error = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_error(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CreateIpTunnelResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:tunneloffload.v1alpha1.CreateIpTunnelResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 tunnel_id = 1;
  if (this->_internal_tunnel_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_tunnel_id(), target);
  }

  // .tunneloffload.v1alpha1.Error error = 2;
  if (this->_internal_has_error()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::error(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tunneloffload.v1alpha1.CreateIpTunnelResponse)
  return target;
}

size_t CreateIpTunnelResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:tunneloffload.v1alpha1.CreateIpTunnelResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .tunneloffload.v1alpha1.Error error = 2;
  if (this->_internal_has_error()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *error_);
  }

  // uint64 tunnel_id = 1;
  if (this->_internal_tunnel_id() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_tunnel_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CreateIpTunnelResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CreateIpTunnelResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CreateIpTunnelResponse::GetClassData() const { return &_class_data_; }

void CreateIpTunnelResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CreateIpTunnelResponse *>(to)->MergeFrom(
      static_cast<const CreateIpTunnelResponse &>(from));
}


void CreateIpTunnelResponse::MergeFrom(const CreateIpTunnelResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:tunneloffload.v1alpha1.CreateIpTunnelResponse)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_error()) {
    _internal_mutable_error()->::tunneloffload::v1alpha1::Error::MergeFrom(from._internal_error());
  }
  if (from._internal_tunnel_id() != 0) {
    _internal_set_tunnel_id(from._internal_tunnel_id());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CreateIpTunnelResponse::CopyFrom(const CreateIpTunnelResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tunneloffload.v1alpha1.CreateIpTunnelResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CreateIpTunnelResponse::IsInitialized() const {
  return true;
}

void CreateIpTunnelResponse::InternalSwap(CreateIpTunnelResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CreateIpTunnelResponse, tunnel_id_)
      + sizeof(CreateIpTunnelResponse::tunnel_id_)
      - PROTOBUF_FIELD_OFFSET(CreateIpTunnelResponse, error_)>(
          reinterpret_cast<char*>(&error_),
          reinterpret_cast<char*>(&other->error_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CreateIpTunnelResponse::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_tunneloffload_2eproto_getter, &descriptor_table_tunneloffload_2eproto_once,
      file_level_metadata_tunneloffload_2eproto[28]);
}

// ===================================================================

class Error::_Internal {
 public:
  static const ::tunneloffload::v1alpha1::TunnelAdditionError& error_message(const Error* msg);
};

const ::tunneloffload::v1alpha1::TunnelAdditionError&
Error::_Internal::error_message(const Error* msg) {
  return *msg->error_message_;
}
Error::Error(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:tunneloffload.v1alpha1.Error)
}
Error::Error(const Error& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  error_string_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    error_string_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_error_string().empty()) {
    error_string_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_error_string(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_error_message()) {
    error_message_ = new ::tunneloffload::v1alpha1::TunnelAdditionError(*from.error_message_);
  } else {
    error_message_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:tunneloffload.v1alpha1.Error)
}

inline void Error::SharedCtor() {
error_string_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  error_string_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
error_message_ = nullptr;
}

Error::~Error() {
  // @@protoc_insertion_point(destructor:tunneloffload.v1alpha1.Error)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void Error::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  error_string_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete error_message_;
}

void Error::ArenaDtor(void* object) {
  Error* _this = reinterpret_cast< Error* >(object);
  (void)_this;
}
void Error::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Error::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Error::Clear() {
// @@protoc_insertion_point(message_clear_start:tunneloffload.v1alpha1.Error)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  error_string_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && error_message_ != nullptr) {
    delete error_message_;
  }
  error_message_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Error::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .tunneloffload.v1alpha1.TunnelAdditionError error_message = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_error_message(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string error_string = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_error_string();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "tunneloffload.v1alpha1.Error.error_string"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Error::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:tunneloffload.v1alpha1.Error)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .tunneloffload.v1alpha1.TunnelAdditionError error_message = 1;
  if (this->_internal_has_error_message()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::error_message(this), target, stream);
  }

  // string error_string = 2;
  if (!this->_internal_error_string().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_error_string().data(), static_cast<int>(this->_internal_error_string().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "tunneloffload.v1alpha1.Error.error_string");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_error_string(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tunneloffload.v1alpha1.Error)
  return target;
}

size_t Error::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:tunneloffload.v1alpha1.Error)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string error_string = 2;
  if (!this->_internal_error_string().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_error_string());
  }

  // .tunneloffload.v1alpha1.TunnelAdditionError error_message = 1;
  if (this->_internal_has_error_message()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *error_message_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Error::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Error::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Error::GetClassData() const { return &_class_data_; }

void Error::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Error *>(to)->MergeFrom(
      static_cast<const Error &>(from));
}


void Error::MergeFrom(const Error& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:tunneloffload.v1alpha1.Error)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_error_string().empty()) {
    _internal_set_error_string(from._internal_error_string());
  }
  if (from._internal_has_error_message()) {
    _internal_mutable_error_message()->::tunneloffload::v1alpha1::TunnelAdditionError::MergeFrom(from._internal_error_message());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Error::CopyFrom(const Error& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tunneloffload.v1alpha1.Error)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Error::IsInitialized() const {
  return true;
}

void Error::InternalSwap(Error* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &error_string_, lhs_arena,
      &other->error_string_, rhs_arena
  );
  swap(error_message_, other->error_message_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Error::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_tunneloffload_2eproto_getter, &descriptor_table_tunneloffload_2eproto_once,
      file_level_metadata_tunneloffload_2eproto[29]);
}

// ===================================================================

class IpTunnelResponses::_Internal {
 public:
};

IpTunnelResponses::IpTunnelResponses(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  responses_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:tunneloffload.v1alpha1.IpTunnelResponses)
}
IpTunnelResponses::IpTunnelResponses(const IpTunnelResponses& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      responses_(from.responses_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:tunneloffload.v1alpha1.IpTunnelResponses)
}

inline void IpTunnelResponses::SharedCtor() {
}

IpTunnelResponses::~IpTunnelResponses() {
  // @@protoc_insertion_point(destructor:tunneloffload.v1alpha1.IpTunnelResponses)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void IpTunnelResponses::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void IpTunnelResponses::ArenaDtor(void* object) {
  IpTunnelResponses* _this = reinterpret_cast< IpTunnelResponses* >(object);
  (void)_this;
}
void IpTunnelResponses::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void IpTunnelResponses::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void IpTunnelResponses::Clear() {
// @@protoc_insertion_point(message_clear_start:tunneloffload.v1alpha1.IpTunnelResponses)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  responses_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* IpTunnelResponses::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .tunneloffload.v1alpha1.IpTunnelResponse responses = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_responses(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IpTunnelResponses::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:tunneloffload.v1alpha1.IpTunnelResponses)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .tunneloffload.v1alpha1.IpTunnelResponse responses = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_responses_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_responses(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tunneloffload.v1alpha1.IpTunnelResponses)
  return target;
}

size_t IpTunnelResponses::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:tunneloffload.v1alpha1.IpTunnelResponses)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .tunneloffload.v1alpha1.IpTunnelResponse responses = 1;
  total_size += 1UL * this->_internal_responses_size();
  for (const auto& msg : this->responses_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData IpTunnelResponses::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    IpTunnelResponses::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*IpTunnelResponses::GetClassData() const { return &_class_data_; }

void IpTunnelResponses::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<IpTunnelResponses *>(to)->MergeFrom(
      static_cast<const IpTunnelResponses &>(from));
}


void IpTunnelResponses::MergeFrom(const IpTunnelResponses& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:tunneloffload.v1alpha1.IpTunnelResponses)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  responses_.MergeFrom(from.responses_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void IpTunnelResponses::CopyFrom(const IpTunnelResponses& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tunneloffload.v1alpha1.IpTunnelResponses)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IpTunnelResponses::IsInitialized() const {
  return true;
}

void IpTunnelResponses::InternalSwap(IpTunnelResponses* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  responses_.InternalSwap(&other->responses_);
}

::PROTOBUF_NAMESPACE_ID::Metadata IpTunnelResponses::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_tunneloffload_2eproto_getter, &descriptor_table_tunneloffload_2eproto_once,
      file_level_metadata_tunneloffload_2eproto[30]);
}

// ===================================================================

class IpTunnelResponse::_Internal {
 public:
  static const ::tunneloffload::v1alpha1::IpTunnelRequest& ip_tunnel(const IpTunnelResponse* msg);
  static const ::tunneloffload::v1alpha1::Counters& tunnel_counters(const IpTunnelResponse* msg);
  static const ::tunneloffload::v1alpha1::Error& error(const IpTunnelResponse* msg);
};

const ::tunneloffload::v1alpha1::IpTunnelRequest&
IpTunnelResponse::_Internal::ip_tunnel(const IpTunnelResponse* msg) {
  return *msg->ip_tunnel_;
}
const ::tunneloffload::v1alpha1::Counters&
IpTunnelResponse::_Internal::tunnel_counters(const IpTunnelResponse* msg) {
  return *msg->tunnel_counters_;
}
const ::tunneloffload::v1alpha1::Error&
IpTunnelResponse::_Internal::error(const IpTunnelResponse* msg) {
  return *msg->error_;
}
IpTunnelResponse::IpTunnelResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:tunneloffload.v1alpha1.IpTunnelResponse)
}
IpTunnelResponse::IpTunnelResponse(const IpTunnelResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_ip_tunnel()) {
    ip_tunnel_ = new ::tunneloffload::v1alpha1::IpTunnelRequest(*from.ip_tunnel_);
  } else {
    ip_tunnel_ = nullptr;
  }
  if (from._internal_has_tunnel_counters()) {
    tunnel_counters_ = new ::tunneloffload::v1alpha1::Counters(*from.tunnel_counters_);
  } else {
    tunnel_counters_ = nullptr;
  }
  if (from._internal_has_error()) {
    error_ = new ::tunneloffload::v1alpha1::Error(*from.error_);
  } else {
    error_ = nullptr;
  }
  tunnel_id_ = from.tunnel_id_;
  // @@protoc_insertion_point(copy_constructor:tunneloffload.v1alpha1.IpTunnelResponse)
}

inline void IpTunnelResponse::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&ip_tunnel_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&tunnel_id_) -
    reinterpret_cast<char*>(&ip_tunnel_)) + sizeof(tunnel_id_));
}

IpTunnelResponse::~IpTunnelResponse() {
  // @@protoc_insertion_point(destructor:tunneloffload.v1alpha1.IpTunnelResponse)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void IpTunnelResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete ip_tunnel_;
  if (this != internal_default_instance()) delete tunnel_counters_;
  if (this != internal_default_instance()) delete error_;
}

void IpTunnelResponse::ArenaDtor(void* object) {
  IpTunnelResponse* _this = reinterpret_cast< IpTunnelResponse* >(object);
  (void)_this;
}
void IpTunnelResponse::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void IpTunnelResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void IpTunnelResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:tunneloffload.v1alpha1.IpTunnelResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && ip_tunnel_ != nullptr) {
    delete ip_tunnel_;
  }
  ip_tunnel_ = nullptr;
  if (GetArenaForAllocation() == nullptr && tunnel_counters_ != nullptr) {
    delete tunnel_counters_;
  }
  tunnel_counters_ = nullptr;
  if (GetArenaForAllocation() == nullptr && error_ != nullptr) {
    delete error_;
  }
  error_ = nullptr;
  tunnel_id_ = uint64_t{0u};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* IpTunnelResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 tunnel_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          tunnel_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .tunneloffload.v1alpha1.IpTunnelRequest ip_tunnel = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_ip_tunnel(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .tunneloffload.v1alpha1.Counters tunnel_counters = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_tunnel_counters(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .tunneloffload.v1alpha1.Error error = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_error(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IpTunnelResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:tunneloffload.v1alpha1.IpTunnelResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 tunnel_id = 1;
  if (this->_internal_tunnel_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_tunnel_id(), target);
  }

  // .tunneloffload.v1alpha1.IpTunnelRequest ip_tunnel = 2;
  if (this->_internal_has_ip_tunnel()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::ip_tunnel(this), target, stream);
  }

  // .tunneloffload.v1alpha1.Counters tunnel_counters = 3;
  if (this->_internal_has_tunnel_counters()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::tunnel_counters(this), target, stream);
  }

  // .tunneloffload.v1alpha1.Error error = 4;
  if (this->_internal_has_error()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::error(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tunneloffload.v1alpha1.IpTunnelResponse)
  return target;
}

size_t IpTunnelResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:tunneloffload.v1alpha1.IpTunnelResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .tunneloffload.v1alpha1.IpTunnelRequest ip_tunnel = 2;
  if (this->_internal_has_ip_tunnel()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *ip_tunnel_);
  }

  // .tunneloffload.v1alpha1.Counters tunnel_counters = 3;
  if (this->_internal_has_tunnel_counters()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *tunnel_counters_);
  }

  // .tunneloffload.v1alpha1.Error error = 4;
  if (this->_internal_has_error()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *error_);
  }

  // uint64 tunnel_id = 1;
  if (this->_internal_tunnel_id() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_tunnel_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData IpTunnelResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    IpTunnelResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*IpTunnelResponse::GetClassData() const { return &_class_data_; }

void IpTunnelResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<IpTunnelResponse *>(to)->MergeFrom(
      static_cast<const IpTunnelResponse &>(from));
}


void IpTunnelResponse::MergeFrom(const IpTunnelResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:tunneloffload.v1alpha1.IpTunnelResponse)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_ip_tunnel()) {
    _internal_mutable_ip_tunnel()->::tunneloffload::v1alpha1::IpTunnelRequest::MergeFrom(from._internal_ip_tunnel());
  }
  if (from._internal_has_tunnel_counters()) {
    _internal_mutable_tunnel_counters()->::tunneloffload::v1alpha1::Counters::MergeFrom(from._internal_tunnel_counters());
  }
  if (from._internal_has_error()) {
    _internal_mutable_error()->::tunneloffload::v1alpha1::Error::MergeFrom(from._internal_error());
  }
  if (from._internal_tunnel_id() != 0) {
    _internal_set_tunnel_id(from._internal_tunnel_id());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void IpTunnelResponse::CopyFrom(const IpTunnelResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tunneloffload.v1alpha1.IpTunnelResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IpTunnelResponse::IsInitialized() const {
  return true;
}

void IpTunnelResponse::InternalSwap(IpTunnelResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(IpTunnelResponse, tunnel_id_)
      + sizeof(IpTunnelResponse::tunnel_id_)
      - PROTOBUF_FIELD_OFFSET(IpTunnelResponse, ip_tunnel_)>(
          reinterpret_cast<char*>(&ip_tunnel_),
          reinterpret_cast<char*>(&other->ip_tunnel_));
}

::PROTOBUF_NAMESPACE_ID::Metadata IpTunnelResponse::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_tunneloffload_2eproto_getter, &descriptor_table_tunneloffload_2eproto_once,
      file_level_metadata_tunneloffload_2eproto[31]);
}

// ===================================================================

class IpTunnelStatsResponses::_Internal {
 public:
};

IpTunnelStatsResponses::IpTunnelStatsResponses(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  responses_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:tunneloffload.v1alpha1.IpTunnelStatsResponses)
}
IpTunnelStatsResponses::IpTunnelStatsResponses(const IpTunnelStatsResponses& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      responses_(from.responses_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:tunneloffload.v1alpha1.IpTunnelStatsResponses)
}

inline void IpTunnelStatsResponses::SharedCtor() {
}

IpTunnelStatsResponses::~IpTunnelStatsResponses() {
  // @@protoc_insertion_point(destructor:tunneloffload.v1alpha1.IpTunnelStatsResponses)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void IpTunnelStatsResponses::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void IpTunnelStatsResponses::ArenaDtor(void* object) {
  IpTunnelStatsResponses* _this = reinterpret_cast< IpTunnelStatsResponses* >(object);
  (void)_this;
}
void IpTunnelStatsResponses::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void IpTunnelStatsResponses::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void IpTunnelStatsResponses::Clear() {
// @@protoc_insertion_point(message_clear_start:tunneloffload.v1alpha1.IpTunnelStatsResponses)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  responses_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* IpTunnelStatsResponses::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .tunneloffload.v1alpha1.IpTunnelStatsResponse responses = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_responses(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IpTunnelStatsResponses::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:tunneloffload.v1alpha1.IpTunnelStatsResponses)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .tunneloffload.v1alpha1.IpTunnelStatsResponse responses = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_responses_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_responses(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tunneloffload.v1alpha1.IpTunnelStatsResponses)
  return target;
}

size_t IpTunnelStatsResponses::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:tunneloffload.v1alpha1.IpTunnelStatsResponses)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .tunneloffload.v1alpha1.IpTunnelStatsResponse responses = 1;
  total_size += 1UL * this->_internal_responses_size();
  for (const auto& msg : this->responses_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData IpTunnelStatsResponses::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    IpTunnelStatsResponses::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*IpTunnelStatsResponses::GetClassData() const { return &_class_data_; }

void IpTunnelStatsResponses::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<IpTunnelStatsResponses *>(to)->MergeFrom(
      static_cast<const IpTunnelStatsResponses &>(from));
}


void IpTunnelStatsResponses::MergeFrom(const IpTunnelStatsResponses& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:tunneloffload.v1alpha1.IpTunnelStatsResponses)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  responses_.MergeFrom(from.responses_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void IpTunnelStatsResponses::CopyFrom(const IpTunnelStatsResponses& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tunneloffload.v1alpha1.IpTunnelStatsResponses)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IpTunnelStatsResponses::IsInitialized() const {
  return true;
}

void IpTunnelStatsResponses::InternalSwap(IpTunnelStatsResponses* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  responses_.InternalSwap(&other->responses_);
}

::PROTOBUF_NAMESPACE_ID::Metadata IpTunnelStatsResponses::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_tunneloffload_2eproto_getter, &descriptor_table_tunneloffload_2eproto_once,
      file_level_metadata_tunneloffload_2eproto[32]);
}

// ===================================================================

class IpTunnelStatsResponse::_Internal {
 public:
  static const ::tunneloffload::v1alpha1::Counters& tunnel_counters(const IpTunnelStatsResponse* msg);
  static const ::tunneloffload::v1alpha1::Error& error(const IpTunnelStatsResponse* msg);
};

const ::tunneloffload::v1alpha1::Counters&
IpTunnelStatsResponse::_Internal::tunnel_counters(const IpTunnelStatsResponse* msg) {
  return *msg->tunnel_counters_;
}
const ::tunneloffload::v1alpha1::Error&
IpTunnelStatsResponse::_Internal::error(const IpTunnelStatsResponse* msg) {
  return *msg->error_;
}
IpTunnelStatsResponse::IpTunnelStatsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:tunneloffload.v1alpha1.IpTunnelStatsResponse)
}
IpTunnelStatsResponse::IpTunnelStatsResponse(const IpTunnelStatsResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_tunnel_counters()) {
    tunnel_counters_ = new ::tunneloffload::v1alpha1::Counters(*from.tunnel_counters_);
  } else {
    tunnel_counters_ = nullptr;
  }
  if (from._internal_has_error()) {
    error_ = new ::tunneloffload::v1alpha1::Error(*from.error_);
  } else {
    error_ = nullptr;
  }
  tunnel_id_ = from.tunnel_id_;
  // @@protoc_insertion_point(copy_constructor:tunneloffload.v1alpha1.IpTunnelStatsResponse)
}

inline void IpTunnelStatsResponse::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&tunnel_counters_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&tunnel_id_) -
    reinterpret_cast<char*>(&tunnel_counters_)) + sizeof(tunnel_id_));
}

IpTunnelStatsResponse::~IpTunnelStatsResponse() {
  // @@protoc_insertion_point(destructor:tunneloffload.v1alpha1.IpTunnelStatsResponse)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void IpTunnelStatsResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete tunnel_counters_;
  if (this != internal_default_instance()) delete error_;
}

void IpTunnelStatsResponse::ArenaDtor(void* object) {
  IpTunnelStatsResponse* _this = reinterpret_cast< IpTunnelStatsResponse* >(object);
  (void)_this;
}
void IpTunnelStatsResponse::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void IpTunnelStatsResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void IpTunnelStatsResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:tunneloffload.v1alpha1.IpTunnelStatsResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && tunnel_counters_ != nullptr) {
    delete tunnel_counters_;
  }
  tunnel_counters_ = nullptr;
  if (GetArenaForAllocation() == nullptr && error_ != nullptr) {
    delete error_;
  }
  error_ = nullptr;
  tunnel_id_ = uint64_t{0u};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* IpTunnelStatsResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 tunnel_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          tunnel_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .tunneloffload.v1alpha1.Counters tunnel_counters = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_tunnel_counters(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .tunneloffload.v1alpha1.Error error = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_error(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IpTunnelStatsResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:tunneloffload.v1alpha1.IpTunnelStatsResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 tunnel_id = 1;
  if (this->_internal_tunnel_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_tunnel_id(), target);
  }

  // .tunneloffload.v1alpha1.Counters tunnel_counters = 2;
  if (this->_internal_has_tunnel_counters()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::tunnel_counters(this), target, stream);
  }

  // .tunneloffload.v1alpha1.Error error = 3;
  if (this->_internal_has_error()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::error(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tunneloffload.v1alpha1.IpTunnelStatsResponse)
  return target;
}

size_t IpTunnelStatsResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:tunneloffload.v1alpha1.IpTunnelStatsResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .tunneloffload.v1alpha1.Counters tunnel_counters = 2;
  if (this->_internal_has_tunnel_counters()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *tunnel_counters_);
  }

  // .tunneloffload.v1alpha1.Error error = 3;
  if (this->_internal_has_error()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *error_);
  }

  // uint64 tunnel_id = 1;
  if (this->_internal_tunnel_id() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_tunnel_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData IpTunnelStatsResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    IpTunnelStatsResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*IpTunnelStatsResponse::GetClassData() const { return &_class_data_; }

void IpTunnelStatsResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<IpTunnelStatsResponse *>(to)->MergeFrom(
      static_cast<const IpTunnelStatsResponse &>(from));
}


void IpTunnelStatsResponse::MergeFrom(const IpTunnelStatsResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:tunneloffload.v1alpha1.IpTunnelStatsResponse)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_tunnel_counters()) {
    _internal_mutable_tunnel_counters()->::tunneloffload::v1alpha1::Counters::MergeFrom(from._internal_tunnel_counters());
  }
  if (from._internal_has_error()) {
    _internal_mutable_error()->::tunneloffload::v1alpha1::Error::MergeFrom(from._internal_error());
  }
  if (from._internal_tunnel_id() != 0) {
    _internal_set_tunnel_id(from._internal_tunnel_id());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void IpTunnelStatsResponse::CopyFrom(const IpTunnelStatsResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tunneloffload.v1alpha1.IpTunnelStatsResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IpTunnelStatsResponse::IsInitialized() const {
  return true;
}

void IpTunnelStatsResponse::InternalSwap(IpTunnelStatsResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(IpTunnelStatsResponse, tunnel_id_)
      + sizeof(IpTunnelStatsResponse::tunnel_id_)
      - PROTOBUF_FIELD_OFFSET(IpTunnelStatsResponse, tunnel_counters_)>(
          reinterpret_cast<char*>(&tunnel_counters_),
          reinterpret_cast<char*>(&other->tunnel_counters_));
}

::PROTOBUF_NAMESPACE_ID::Metadata IpTunnelStatsResponse::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_tunneloffload_2eproto_getter, &descriptor_table_tunneloffload_2eproto_once,
      file_level_metadata_tunneloffload_2eproto[33]);
}

// ===================================================================

class TunnelRequestArgs::_Internal {
 public:
};

TunnelRequestArgs::TunnelRequestArgs(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:tunneloffload.v1alpha1.TunnelRequestArgs)
}
TunnelRequestArgs::TunnelRequestArgs(const TunnelRequestArgs& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  tunnels_per_request_ = from.tunnels_per_request_;
  // @@protoc_insertion_point(copy_constructor:tunneloffload.v1alpha1.TunnelRequestArgs)
}

inline void TunnelRequestArgs::SharedCtor() {
tunnels_per_request_ = 0u;
}

TunnelRequestArgs::~TunnelRequestArgs() {
  // @@protoc_insertion_point(destructor:tunneloffload.v1alpha1.TunnelRequestArgs)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void TunnelRequestArgs::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void TunnelRequestArgs::ArenaDtor(void* object) {
  TunnelRequestArgs* _this = reinterpret_cast< TunnelRequestArgs* >(object);
  (void)_this;
}
void TunnelRequestArgs::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TunnelRequestArgs::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void TunnelRequestArgs::Clear() {
// @@protoc_insertion_point(message_clear_start:tunneloffload.v1alpha1.TunnelRequestArgs)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  tunnels_per_request_ = 0u;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TunnelRequestArgs::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 tunnels_per_request = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          tunnels_per_request_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TunnelRequestArgs::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:tunneloffload.v1alpha1.TunnelRequestArgs)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 tunnels_per_request = 1;
  if (this->_internal_tunnels_per_request() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_tunnels_per_request(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tunneloffload.v1alpha1.TunnelRequestArgs)
  return target;
}

size_t TunnelRequestArgs::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:tunneloffload.v1alpha1.TunnelRequestArgs)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 tunnels_per_request = 1;
  if (this->_internal_tunnels_per_request() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_tunnels_per_request());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TunnelRequestArgs::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    TunnelRequestArgs::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TunnelRequestArgs::GetClassData() const { return &_class_data_; }

void TunnelRequestArgs::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<TunnelRequestArgs *>(to)->MergeFrom(
      static_cast<const TunnelRequestArgs &>(from));
}


void TunnelRequestArgs::MergeFrom(const TunnelRequestArgs& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:tunneloffload.v1alpha1.TunnelRequestArgs)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_tunnels_per_request() != 0) {
    _internal_set_tunnels_per_request(from._internal_tunnels_per_request());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TunnelRequestArgs::CopyFrom(const TunnelRequestArgs& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tunneloffload.v1alpha1.TunnelRequestArgs)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TunnelRequestArgs::IsInitialized() const {
  return true;
}

void TunnelRequestArgs::InternalSwap(TunnelRequestArgs* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(tunnels_per_request_, other->tunnels_per_request_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TunnelRequestArgs::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_tunneloffload_2eproto_getter, &descriptor_table_tunneloffload_2eproto_once,
      file_level_metadata_tunneloffload_2eproto[34]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace v1alpha1
}  // namespace tunneloffload
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::tunneloffload::v1alpha1::CapabilityRequest* Arena::CreateMaybeMessage< ::tunneloffload::v1alpha1::CapabilityRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::tunneloffload::v1alpha1::CapabilityRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::tunneloffload::v1alpha1::CapabilityResponse_MatchCapabilities* Arena::CreateMaybeMessage< ::tunneloffload::v1alpha1::CapabilityResponse_MatchCapabilities >(Arena* arena) {
  return Arena::CreateMessageInternal< ::tunneloffload::v1alpha1::CapabilityResponse_MatchCapabilities >(arena);
}
template<> PROTOBUF_NOINLINE ::tunneloffload::v1alpha1::CapabilityResponse_IPSecCapabilities* Arena::CreateMaybeMessage< ::tunneloffload::v1alpha1::CapabilityResponse_IPSecCapabilities >(Arena* arena) {
  return Arena::CreateMessageInternal< ::tunneloffload::v1alpha1::CapabilityResponse_IPSecCapabilities >(arena);
}
template<> PROTOBUF_NOINLINE ::tunneloffload::v1alpha1::CapabilityResponse_GeneveCapabilities* Arena::CreateMaybeMessage< ::tunneloffload::v1alpha1::CapabilityResponse_GeneveCapabilities >(Arena* arena) {
  return Arena::CreateMessageInternal< ::tunneloffload::v1alpha1::CapabilityResponse_GeneveCapabilities >(arena);
}
template<> PROTOBUF_NOINLINE ::tunneloffload::v1alpha1::CapabilityResponse* Arena::CreateMaybeMessage< ::tunneloffload::v1alpha1::CapabilityResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::tunneloffload::v1alpha1::CapabilityResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::tunneloffload::v1alpha1::TunnelAdditionError* Arena::CreateMaybeMessage< ::tunneloffload::v1alpha1::TunnelAdditionError >(Arena* arena) {
  return Arena::CreateMessageInternal< ::tunneloffload::v1alpha1::TunnelAdditionError >(arena);
}
template<> PROTOBUF_NOINLINE ::tunneloffload::v1alpha1::MatchCriteria_IPSecMatch* Arena::CreateMaybeMessage< ::tunneloffload::v1alpha1::MatchCriteria_IPSecMatch >(Arena* arena) {
  return Arena::CreateMessageInternal< ::tunneloffload::v1alpha1::MatchCriteria_IPSecMatch >(arena);
}
template<> PROTOBUF_NOINLINE ::tunneloffload::v1alpha1::MatchCriteria_GeneveMatch* Arena::CreateMaybeMessage< ::tunneloffload::v1alpha1::MatchCriteria_GeneveMatch >(Arena* arena) {
  return Arena::CreateMessageInternal< ::tunneloffload::v1alpha1::MatchCriteria_GeneveMatch >(arena);
}
template<> PROTOBUF_NOINLINE ::tunneloffload::v1alpha1::MatchCriteria_VXLanMatch* Arena::CreateMaybeMessage< ::tunneloffload::v1alpha1::MatchCriteria_VXLanMatch >(Arena* arena) {
  return Arena::CreateMessageInternal< ::tunneloffload::v1alpha1::MatchCriteria_VXLanMatch >(arena);
}
template<> PROTOBUF_NOINLINE ::tunneloffload::v1alpha1::MatchCriteria* Arena::CreateMaybeMessage< ::tunneloffload::v1alpha1::MatchCriteria >(Arena* arena) {
  return Arena::CreateMessageInternal< ::tunneloffload::v1alpha1::MatchCriteria >(arena);
}
template<> PROTOBUF_NOINLINE ::tunneloffload::v1alpha1::IpTunnelRequest* Arena::CreateMaybeMessage< ::tunneloffload::v1alpha1::IpTunnelRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::tunneloffload::v1alpha1::IpTunnelRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::tunneloffload::v1alpha1::Geneve* Arena::CreateMaybeMessage< ::tunneloffload::v1alpha1::Geneve >(Arena* arena) {
  return Arena::CreateMessageInternal< ::tunneloffload::v1alpha1::Geneve >(arena);
}
template<> PROTOBUF_NOINLINE ::tunneloffload::v1alpha1::GeneveOption* Arena::CreateMaybeMessage< ::tunneloffload::v1alpha1::GeneveOption >(Arena* arena) {
  return Arena::CreateMessageInternal< ::tunneloffload::v1alpha1::GeneveOption >(arena);
}
template<> PROTOBUF_NOINLINE ::tunneloffload::v1alpha1::GeneveEncap* Arena::CreateMaybeMessage< ::tunneloffload::v1alpha1::GeneveEncap >(Arena* arena) {
  return Arena::CreateMessageInternal< ::tunneloffload::v1alpha1::GeneveEncap >(arena);
}
template<> PROTOBUF_NOINLINE ::tunneloffload::v1alpha1::GeneveDecap* Arena::CreateMaybeMessage< ::tunneloffload::v1alpha1::GeneveDecap >(Arena* arena) {
  return Arena::CreateMessageInternal< ::tunneloffload::v1alpha1::GeneveDecap >(arena);
}
template<> PROTOBUF_NOINLINE ::tunneloffload::v1alpha1::MacPair* Arena::CreateMaybeMessage< ::tunneloffload::v1alpha1::MacPair >(Arena* arena) {
  return Arena::CreateMessageInternal< ::tunneloffload::v1alpha1::MacPair >(arena);
}
template<> PROTOBUF_NOINLINE ::tunneloffload::v1alpha1::IPV4Pair* Arena::CreateMaybeMessage< ::tunneloffload::v1alpha1::IPV4Pair >(Arena* arena) {
  return Arena::CreateMessageInternal< ::tunneloffload::v1alpha1::IPV4Pair >(arena);
}
template<> PROTOBUF_NOINLINE ::tunneloffload::v1alpha1::IPV6Pair* Arena::CreateMaybeMessage< ::tunneloffload::v1alpha1::IPV6Pair >(Arena* arena) {
  return Arena::CreateMessageInternal< ::tunneloffload::v1alpha1::IPV6Pair >(arena);
}
template<> PROTOBUF_NOINLINE ::tunneloffload::v1alpha1::IPV4Match* Arena::CreateMaybeMessage< ::tunneloffload::v1alpha1::IPV4Match >(Arena* arena) {
  return Arena::CreateMessageInternal< ::tunneloffload::v1alpha1::IPV4Match >(arena);
}
template<> PROTOBUF_NOINLINE ::tunneloffload::v1alpha1::IPV6Match* Arena::CreateMaybeMessage< ::tunneloffload::v1alpha1::IPV6Match >(Arena* arena) {
  return Arena::CreateMessageInternal< ::tunneloffload::v1alpha1::IPV6Match >(arena);
}
template<> PROTOBUF_NOINLINE ::tunneloffload::v1alpha1::Nat* Arena::CreateMaybeMessage< ::tunneloffload::v1alpha1::Nat >(Arena* arena) {
  return Arena::CreateMessageInternal< ::tunneloffload::v1alpha1::Nat >(arena);
}
template<> PROTOBUF_NOINLINE ::tunneloffload::v1alpha1::IPSecEnc* Arena::CreateMaybeMessage< ::tunneloffload::v1alpha1::IPSecEnc >(Arena* arena) {
  return Arena::CreateMessageInternal< ::tunneloffload::v1alpha1::IPSecEnc >(arena);
}
template<> PROTOBUF_NOINLINE ::tunneloffload::v1alpha1::IPSecDec* Arena::CreateMaybeMessage< ::tunneloffload::v1alpha1::IPSecDec >(Arena* arena) {
  return Arena::CreateMessageInternal< ::tunneloffload::v1alpha1::IPSecDec >(arena);
}
template<> PROTOBUF_NOINLINE ::tunneloffload::v1alpha1::IPSecSAParams* Arena::CreateMaybeMessage< ::tunneloffload::v1alpha1::IPSecSAParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::tunneloffload::v1alpha1::IPSecSAParams >(arena);
}
template<> PROTOBUF_NOINLINE ::tunneloffload::v1alpha1::IPSecTunnel* Arena::CreateMaybeMessage< ::tunneloffload::v1alpha1::IPSecTunnel >(Arena* arena) {
  return Arena::CreateMessageInternal< ::tunneloffload::v1alpha1::IPSecTunnel >(arena);
}
template<> PROTOBUF_NOINLINE ::tunneloffload::v1alpha1::TunnelId* Arena::CreateMaybeMessage< ::tunneloffload::v1alpha1::TunnelId >(Arena* arena) {
  return Arena::CreateMessageInternal< ::tunneloffload::v1alpha1::TunnelId >(arena);
}
template<> PROTOBUF_NOINLINE ::tunneloffload::v1alpha1::Counters* Arena::CreateMaybeMessage< ::tunneloffload::v1alpha1::Counters >(Arena* arena) {
  return Arena::CreateMessageInternal< ::tunneloffload::v1alpha1::Counters >(arena);
}
template<> PROTOBUF_NOINLINE ::tunneloffload::v1alpha1::CreateIpTunnelResponses* Arena::CreateMaybeMessage< ::tunneloffload::v1alpha1::CreateIpTunnelResponses >(Arena* arena) {
  return Arena::CreateMessageInternal< ::tunneloffload::v1alpha1::CreateIpTunnelResponses >(arena);
}
template<> PROTOBUF_NOINLINE ::tunneloffload::v1alpha1::CreateIpTunnelResponse* Arena::CreateMaybeMessage< ::tunneloffload::v1alpha1::CreateIpTunnelResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::tunneloffload::v1alpha1::CreateIpTunnelResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::tunneloffload::v1alpha1::Error* Arena::CreateMaybeMessage< ::tunneloffload::v1alpha1::Error >(Arena* arena) {
  return Arena::CreateMessageInternal< ::tunneloffload::v1alpha1::Error >(arena);
}
template<> PROTOBUF_NOINLINE ::tunneloffload::v1alpha1::IpTunnelResponses* Arena::CreateMaybeMessage< ::tunneloffload::v1alpha1::IpTunnelResponses >(Arena* arena) {
  return Arena::CreateMessageInternal< ::tunneloffload::v1alpha1::IpTunnelResponses >(arena);
}
template<> PROTOBUF_NOINLINE ::tunneloffload::v1alpha1::IpTunnelResponse* Arena::CreateMaybeMessage< ::tunneloffload::v1alpha1::IpTunnelResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::tunneloffload::v1alpha1::IpTunnelResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::tunneloffload::v1alpha1::IpTunnelStatsResponses* Arena::CreateMaybeMessage< ::tunneloffload::v1alpha1::IpTunnelStatsResponses >(Arena* arena) {
  return Arena::CreateMessageInternal< ::tunneloffload::v1alpha1::IpTunnelStatsResponses >(arena);
}
template<> PROTOBUF_NOINLINE ::tunneloffload::v1alpha1::IpTunnelStatsResponse* Arena::CreateMaybeMessage< ::tunneloffload::v1alpha1::IpTunnelStatsResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::tunneloffload::v1alpha1::IpTunnelStatsResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::tunneloffload::v1alpha1::TunnelRequestArgs* Arena::CreateMaybeMessage< ::tunneloffload::v1alpha1::TunnelRequestArgs >(Arena* arena) {
  return Arena::CreateMessageInternal< ::tunneloffload::v1alpha1::TunnelRequestArgs >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
