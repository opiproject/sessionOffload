// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tunneloffload.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_tunneloffload_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_tunneloffload_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_tunneloffload_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_tunneloffload_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[35]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_tunneloffload_2eproto;
namespace tunneloffload {
namespace v1alpha1 {
class CapabilityRequest;
struct CapabilityRequestDefaultTypeInternal;
extern CapabilityRequestDefaultTypeInternal _CapabilityRequest_default_instance_;
class CapabilityResponse;
struct CapabilityResponseDefaultTypeInternal;
extern CapabilityResponseDefaultTypeInternal _CapabilityResponse_default_instance_;
class CapabilityResponse_GeneveCapabilities;
struct CapabilityResponse_GeneveCapabilitiesDefaultTypeInternal;
extern CapabilityResponse_GeneveCapabilitiesDefaultTypeInternal _CapabilityResponse_GeneveCapabilities_default_instance_;
class CapabilityResponse_IPSecCapabilities;
struct CapabilityResponse_IPSecCapabilitiesDefaultTypeInternal;
extern CapabilityResponse_IPSecCapabilitiesDefaultTypeInternal _CapabilityResponse_IPSecCapabilities_default_instance_;
class CapabilityResponse_MatchCapabilities;
struct CapabilityResponse_MatchCapabilitiesDefaultTypeInternal;
extern CapabilityResponse_MatchCapabilitiesDefaultTypeInternal _CapabilityResponse_MatchCapabilities_default_instance_;
class Counters;
struct CountersDefaultTypeInternal;
extern CountersDefaultTypeInternal _Counters_default_instance_;
class CreateIpTunnelResponse;
struct CreateIpTunnelResponseDefaultTypeInternal;
extern CreateIpTunnelResponseDefaultTypeInternal _CreateIpTunnelResponse_default_instance_;
class CreateIpTunnelResponses;
struct CreateIpTunnelResponsesDefaultTypeInternal;
extern CreateIpTunnelResponsesDefaultTypeInternal _CreateIpTunnelResponses_default_instance_;
class Error;
struct ErrorDefaultTypeInternal;
extern ErrorDefaultTypeInternal _Error_default_instance_;
class Geneve;
struct GeneveDefaultTypeInternal;
extern GeneveDefaultTypeInternal _Geneve_default_instance_;
class GeneveDecap;
struct GeneveDecapDefaultTypeInternal;
extern GeneveDecapDefaultTypeInternal _GeneveDecap_default_instance_;
class GeneveEncap;
struct GeneveEncapDefaultTypeInternal;
extern GeneveEncapDefaultTypeInternal _GeneveEncap_default_instance_;
class GeneveOption;
struct GeneveOptionDefaultTypeInternal;
extern GeneveOptionDefaultTypeInternal _GeneveOption_default_instance_;
class IPSecDec;
struct IPSecDecDefaultTypeInternal;
extern IPSecDecDefaultTypeInternal _IPSecDec_default_instance_;
class IPSecEnc;
struct IPSecEncDefaultTypeInternal;
extern IPSecEncDefaultTypeInternal _IPSecEnc_default_instance_;
class IPSecSAParams;
struct IPSecSAParamsDefaultTypeInternal;
extern IPSecSAParamsDefaultTypeInternal _IPSecSAParams_default_instance_;
class IPSecTunnel;
struct IPSecTunnelDefaultTypeInternal;
extern IPSecTunnelDefaultTypeInternal _IPSecTunnel_default_instance_;
class IPV4Match;
struct IPV4MatchDefaultTypeInternal;
extern IPV4MatchDefaultTypeInternal _IPV4Match_default_instance_;
class IPV4Pair;
struct IPV4PairDefaultTypeInternal;
extern IPV4PairDefaultTypeInternal _IPV4Pair_default_instance_;
class IPV6Match;
struct IPV6MatchDefaultTypeInternal;
extern IPV6MatchDefaultTypeInternal _IPV6Match_default_instance_;
class IPV6Pair;
struct IPV6PairDefaultTypeInternal;
extern IPV6PairDefaultTypeInternal _IPV6Pair_default_instance_;
class IpTunnelRequest;
struct IpTunnelRequestDefaultTypeInternal;
extern IpTunnelRequestDefaultTypeInternal _IpTunnelRequest_default_instance_;
class IpTunnelResponse;
struct IpTunnelResponseDefaultTypeInternal;
extern IpTunnelResponseDefaultTypeInternal _IpTunnelResponse_default_instance_;
class IpTunnelResponses;
struct IpTunnelResponsesDefaultTypeInternal;
extern IpTunnelResponsesDefaultTypeInternal _IpTunnelResponses_default_instance_;
class IpTunnelStatsResponse;
struct IpTunnelStatsResponseDefaultTypeInternal;
extern IpTunnelStatsResponseDefaultTypeInternal _IpTunnelStatsResponse_default_instance_;
class IpTunnelStatsResponses;
struct IpTunnelStatsResponsesDefaultTypeInternal;
extern IpTunnelStatsResponsesDefaultTypeInternal _IpTunnelStatsResponses_default_instance_;
class MacPair;
struct MacPairDefaultTypeInternal;
extern MacPairDefaultTypeInternal _MacPair_default_instance_;
class MatchCriteria;
struct MatchCriteriaDefaultTypeInternal;
extern MatchCriteriaDefaultTypeInternal _MatchCriteria_default_instance_;
class MatchCriteria_GeneveMatch;
struct MatchCriteria_GeneveMatchDefaultTypeInternal;
extern MatchCriteria_GeneveMatchDefaultTypeInternal _MatchCriteria_GeneveMatch_default_instance_;
class MatchCriteria_IPSecMatch;
struct MatchCriteria_IPSecMatchDefaultTypeInternal;
extern MatchCriteria_IPSecMatchDefaultTypeInternal _MatchCriteria_IPSecMatch_default_instance_;
class MatchCriteria_VXLanMatch;
struct MatchCriteria_VXLanMatchDefaultTypeInternal;
extern MatchCriteria_VXLanMatchDefaultTypeInternal _MatchCriteria_VXLanMatch_default_instance_;
class Nat;
struct NatDefaultTypeInternal;
extern NatDefaultTypeInternal _Nat_default_instance_;
class TunnelAdditionError;
struct TunnelAdditionErrorDefaultTypeInternal;
extern TunnelAdditionErrorDefaultTypeInternal _TunnelAdditionError_default_instance_;
class TunnelId;
struct TunnelIdDefaultTypeInternal;
extern TunnelIdDefaultTypeInternal _TunnelId_default_instance_;
class TunnelRequestArgs;
struct TunnelRequestArgsDefaultTypeInternal;
extern TunnelRequestArgsDefaultTypeInternal _TunnelRequestArgs_default_instance_;
}  // namespace v1alpha1
}  // namespace tunneloffload
PROTOBUF_NAMESPACE_OPEN
template<> ::tunneloffload::v1alpha1::CapabilityRequest* Arena::CreateMaybeMessage<::tunneloffload::v1alpha1::CapabilityRequest>(Arena*);
template<> ::tunneloffload::v1alpha1::CapabilityResponse* Arena::CreateMaybeMessage<::tunneloffload::v1alpha1::CapabilityResponse>(Arena*);
template<> ::tunneloffload::v1alpha1::CapabilityResponse_GeneveCapabilities* Arena::CreateMaybeMessage<::tunneloffload::v1alpha1::CapabilityResponse_GeneveCapabilities>(Arena*);
template<> ::tunneloffload::v1alpha1::CapabilityResponse_IPSecCapabilities* Arena::CreateMaybeMessage<::tunneloffload::v1alpha1::CapabilityResponse_IPSecCapabilities>(Arena*);
template<> ::tunneloffload::v1alpha1::CapabilityResponse_MatchCapabilities* Arena::CreateMaybeMessage<::tunneloffload::v1alpha1::CapabilityResponse_MatchCapabilities>(Arena*);
template<> ::tunneloffload::v1alpha1::Counters* Arena::CreateMaybeMessage<::tunneloffload::v1alpha1::Counters>(Arena*);
template<> ::tunneloffload::v1alpha1::CreateIpTunnelResponse* Arena::CreateMaybeMessage<::tunneloffload::v1alpha1::CreateIpTunnelResponse>(Arena*);
template<> ::tunneloffload::v1alpha1::CreateIpTunnelResponses* Arena::CreateMaybeMessage<::tunneloffload::v1alpha1::CreateIpTunnelResponses>(Arena*);
template<> ::tunneloffload::v1alpha1::Error* Arena::CreateMaybeMessage<::tunneloffload::v1alpha1::Error>(Arena*);
template<> ::tunneloffload::v1alpha1::Geneve* Arena::CreateMaybeMessage<::tunneloffload::v1alpha1::Geneve>(Arena*);
template<> ::tunneloffload::v1alpha1::GeneveDecap* Arena::CreateMaybeMessage<::tunneloffload::v1alpha1::GeneveDecap>(Arena*);
template<> ::tunneloffload::v1alpha1::GeneveEncap* Arena::CreateMaybeMessage<::tunneloffload::v1alpha1::GeneveEncap>(Arena*);
template<> ::tunneloffload::v1alpha1::GeneveOption* Arena::CreateMaybeMessage<::tunneloffload::v1alpha1::GeneveOption>(Arena*);
template<> ::tunneloffload::v1alpha1::IPSecDec* Arena::CreateMaybeMessage<::tunneloffload::v1alpha1::IPSecDec>(Arena*);
template<> ::tunneloffload::v1alpha1::IPSecEnc* Arena::CreateMaybeMessage<::tunneloffload::v1alpha1::IPSecEnc>(Arena*);
template<> ::tunneloffload::v1alpha1::IPSecSAParams* Arena::CreateMaybeMessage<::tunneloffload::v1alpha1::IPSecSAParams>(Arena*);
template<> ::tunneloffload::v1alpha1::IPSecTunnel* Arena::CreateMaybeMessage<::tunneloffload::v1alpha1::IPSecTunnel>(Arena*);
template<> ::tunneloffload::v1alpha1::IPV4Match* Arena::CreateMaybeMessage<::tunneloffload::v1alpha1::IPV4Match>(Arena*);
template<> ::tunneloffload::v1alpha1::IPV4Pair* Arena::CreateMaybeMessage<::tunneloffload::v1alpha1::IPV4Pair>(Arena*);
template<> ::tunneloffload::v1alpha1::IPV6Match* Arena::CreateMaybeMessage<::tunneloffload::v1alpha1::IPV6Match>(Arena*);
template<> ::tunneloffload::v1alpha1::IPV6Pair* Arena::CreateMaybeMessage<::tunneloffload::v1alpha1::IPV6Pair>(Arena*);
template<> ::tunneloffload::v1alpha1::IpTunnelRequest* Arena::CreateMaybeMessage<::tunneloffload::v1alpha1::IpTunnelRequest>(Arena*);
template<> ::tunneloffload::v1alpha1::IpTunnelResponse* Arena::CreateMaybeMessage<::tunneloffload::v1alpha1::IpTunnelResponse>(Arena*);
template<> ::tunneloffload::v1alpha1::IpTunnelResponses* Arena::CreateMaybeMessage<::tunneloffload::v1alpha1::IpTunnelResponses>(Arena*);
template<> ::tunneloffload::v1alpha1::IpTunnelStatsResponse* Arena::CreateMaybeMessage<::tunneloffload::v1alpha1::IpTunnelStatsResponse>(Arena*);
template<> ::tunneloffload::v1alpha1::IpTunnelStatsResponses* Arena::CreateMaybeMessage<::tunneloffload::v1alpha1::IpTunnelStatsResponses>(Arena*);
template<> ::tunneloffload::v1alpha1::MacPair* Arena::CreateMaybeMessage<::tunneloffload::v1alpha1::MacPair>(Arena*);
template<> ::tunneloffload::v1alpha1::MatchCriteria* Arena::CreateMaybeMessage<::tunneloffload::v1alpha1::MatchCriteria>(Arena*);
template<> ::tunneloffload::v1alpha1::MatchCriteria_GeneveMatch* Arena::CreateMaybeMessage<::tunneloffload::v1alpha1::MatchCriteria_GeneveMatch>(Arena*);
template<> ::tunneloffload::v1alpha1::MatchCriteria_IPSecMatch* Arena::CreateMaybeMessage<::tunneloffload::v1alpha1::MatchCriteria_IPSecMatch>(Arena*);
template<> ::tunneloffload::v1alpha1::MatchCriteria_VXLanMatch* Arena::CreateMaybeMessage<::tunneloffload::v1alpha1::MatchCriteria_VXLanMatch>(Arena*);
template<> ::tunneloffload::v1alpha1::Nat* Arena::CreateMaybeMessage<::tunneloffload::v1alpha1::Nat>(Arena*);
template<> ::tunneloffload::v1alpha1::TunnelAdditionError* Arena::CreateMaybeMessage<::tunneloffload::v1alpha1::TunnelAdditionError>(Arena*);
template<> ::tunneloffload::v1alpha1::TunnelId* Arena::CreateMaybeMessage<::tunneloffload::v1alpha1::TunnelId>(Arena*);
template<> ::tunneloffload::v1alpha1::TunnelRequestArgs* Arena::CreateMaybeMessage<::tunneloffload::v1alpha1::TunnelRequestArgs>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace tunneloffload {
namespace v1alpha1 {

enum AddTunnelStatus : int {
  _TUNNEL_ACCEPTED = 0,
  _TUNNEL_REJECTED = 1,
  _TUNNEL_TABLE_FULL = 2,
  _TUNNEL_TABLE_UNAVAILABLE = 3,
  _TUNNEL_ALREADY_EXISTS = 4,
  AddTunnelStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  AddTunnelStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool AddTunnelStatus_IsValid(int value);
constexpr AddTunnelStatus AddTunnelStatus_MIN = _TUNNEL_ACCEPTED;
constexpr AddTunnelStatus AddTunnelStatus_MAX = _TUNNEL_ALREADY_EXISTS;
constexpr int AddTunnelStatus_ARRAYSIZE = AddTunnelStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AddTunnelStatus_descriptor();
template<typename T>
inline const std::string& AddTunnelStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AddTunnelStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AddTunnelStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AddTunnelStatus_descriptor(), enum_t_value);
}
inline bool AddTunnelStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AddTunnelStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AddTunnelStatus>(
    AddTunnelStatus_descriptor(), name, value);
}
enum Operation : int {
  _NONE = 0,
  _CREATE = 1,
  _UPDATE = 2,
  _DELETE = 3,
  Operation_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Operation_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Operation_IsValid(int value);
constexpr Operation Operation_MIN = _NONE;
constexpr Operation Operation_MAX = _DELETE;
constexpr int Operation_ARRAYSIZE = Operation_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Operation_descriptor();
template<typename T>
inline const std::string& Operation_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Operation>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Operation_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Operation_descriptor(), enum_t_value);
}
inline bool Operation_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Operation* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Operation>(
    Operation_descriptor(), name, value);
}
enum EncType : int {
  _AES256GCM64 = 0,
  _AES256GCM96 = 1,
  _AES256GCM128 = 2,
  _AES128GCM64 = 3,
  _AES128GCM96 = 4,
  _AES128GCM128 = 5,
  _AES256CCM64 = 6,
  _AES256CCM96 = 7,
  _AES256CCM128 = 8,
  _AES128CCM64 = 9,
  _AES128CCM96 = 10,
  _AES128CCM128 = 11,
  EncType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  EncType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool EncType_IsValid(int value);
constexpr EncType EncType_MIN = _AES256GCM64;
constexpr EncType EncType_MAX = _AES128CCM128;
constexpr int EncType_ARRAYSIZE = EncType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EncType_descriptor();
template<typename T>
inline const std::string& EncType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EncType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EncType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EncType_descriptor(), enum_t_value);
}
inline bool EncType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EncType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EncType>(
    EncType_descriptor(), name, value);
}
enum Action : int {
  NONE = 0,
  FORWARD = 1,
  RECIRCULATE = 2,
  Action_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Action_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Action_IsValid(int value);
constexpr Action Action_MIN = NONE;
constexpr Action Action_MAX = RECIRCULATE;
constexpr int Action_ARRAYSIZE = Action_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Action_descriptor();
template<typename T>
inline const std::string& Action_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Action>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Action_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Action_descriptor(), enum_t_value);
}
inline bool Action_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Action* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Action>(
    Action_descriptor(), name, value);
}
enum MatchError : int {
  MISING_FIELDS = 0,
  INVALID_TUNNEL_ID = 1,
  INVALID_CAPABILITIES = 2,
  INVALID_FIELD = 3,
  MatchError_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  MatchError_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool MatchError_IsValid(int value);
constexpr MatchError MatchError_MIN = MISING_FIELDS;
constexpr MatchError MatchError_MAX = INVALID_FIELD;
constexpr int MatchError_ARRAYSIZE = MatchError_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MatchError_descriptor();
template<typename T>
inline const std::string& MatchError_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MatchError>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MatchError_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MatchError_descriptor(), enum_t_value);
}
inline bool MatchError_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MatchError* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MatchError>(
    MatchError_descriptor(), name, value);
}
enum TunnelError : int {
  NOT_SUPPORTED_TUNNEL = 0,
  TunnelError_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  TunnelError_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool TunnelError_IsValid(int value);
constexpr TunnelError TunnelError_MIN = NOT_SUPPORTED_TUNNEL;
constexpr TunnelError TunnelError_MAX = NOT_SUPPORTED_TUNNEL;
constexpr int TunnelError_ARRAYSIZE = TunnelError_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TunnelError_descriptor();
template<typename T>
inline const std::string& TunnelError_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TunnelError>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TunnelError_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TunnelError_descriptor(), enum_t_value);
}
inline bool TunnelError_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TunnelError* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TunnelError>(
    TunnelError_descriptor(), name, value);
}
enum IPSecError : int {
  INVALID_KEY = 0,
  NON_SUPPORTED_ENCRYPTION = 1,
  NON_SUPPORTED_TUNNEL_TYPE = 2,
  IPSEC_MISSING_FIELDS = 3,
  IPSecError_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  IPSecError_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool IPSecError_IsValid(int value);
constexpr IPSecError IPSecError_MIN = INVALID_KEY;
constexpr IPSecError IPSecError_MAX = IPSEC_MISSING_FIELDS;
constexpr int IPSecError_ARRAYSIZE = IPSecError_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* IPSecError_descriptor();
template<typename T>
inline const std::string& IPSecError_Name(T enum_t_value) {
  static_assert(::std::is_same<T, IPSecError>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function IPSecError_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    IPSecError_descriptor(), enum_t_value);
}
inline bool IPSecError_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, IPSecError* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<IPSecError>(
    IPSecError_descriptor(), name, value);
}
enum GeneveError : int {
  INVALID_OPTION = 0,
  TOO_MANY_OPTIONS = 1,
  INVALID_GENEVE_FIELD = 2,
  GeneveError_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  GeneveError_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool GeneveError_IsValid(int value);
constexpr GeneveError GeneveError_MIN = INVALID_OPTION;
constexpr GeneveError GeneveError_MAX = INVALID_GENEVE_FIELD;
constexpr int GeneveError_ARRAYSIZE = GeneveError_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GeneveError_descriptor();
template<typename T>
inline const std::string& GeneveError_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GeneveError>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GeneveError_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    GeneveError_descriptor(), enum_t_value);
}
inline bool GeneveError_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GeneveError* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GeneveError>(
    GeneveError_descriptor(), name, value);
}
enum IPSecTunnelType : int {
  TRANSPORT = 0,
  TUNNEL = 1,
  TRANSPORT_NAT_TRAVERSAL = 2,
  TUNNEL_NAT_TRAVERSAL = 3,
  IPSecTunnelType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  IPSecTunnelType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool IPSecTunnelType_IsValid(int value);
constexpr IPSecTunnelType IPSecTunnelType_MIN = TRANSPORT;
constexpr IPSecTunnelType IPSecTunnelType_MAX = TUNNEL_NAT_TRAVERSAL;
constexpr int IPSecTunnelType_ARRAYSIZE = IPSecTunnelType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* IPSecTunnelType_descriptor();
template<typename T>
inline const std::string& IPSecTunnelType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, IPSecTunnelType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function IPSecTunnelType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    IPSecTunnelType_descriptor(), enum_t_value);
}
inline bool IPSecTunnelType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, IPSecTunnelType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<IPSecTunnelType>(
    IPSecTunnelType_descriptor(), name, value);
}
// ===================================================================

class CapabilityRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:tunneloffload.v1alpha1.CapabilityRequest) */ {
 public:
  inline CapabilityRequest() : CapabilityRequest(nullptr) {}
  explicit constexpr CapabilityRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CapabilityRequest(const CapabilityRequest& from);
  CapabilityRequest(CapabilityRequest&& from) noexcept
    : CapabilityRequest() {
    *this = ::std::move(from);
  }

  inline CapabilityRequest& operator=(const CapabilityRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CapabilityRequest& operator=(CapabilityRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CapabilityRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CapabilityRequest* internal_default_instance() {
    return reinterpret_cast<const CapabilityRequest*>(
               &_CapabilityRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(CapabilityRequest& a, CapabilityRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CapabilityRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CapabilityRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CapabilityRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CapabilityRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CapabilityRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CapabilityRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tunneloffload.v1alpha1.CapabilityRequest";
  }
  protected:
  explicit CapabilityRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:tunneloffload.v1alpha1.CapabilityRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tunneloffload_2eproto;
};
// -------------------------------------------------------------------

class CapabilityResponse_MatchCapabilities final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tunneloffload.v1alpha1.CapabilityResponse.MatchCapabilities) */ {
 public:
  inline CapabilityResponse_MatchCapabilities() : CapabilityResponse_MatchCapabilities(nullptr) {}
  ~CapabilityResponse_MatchCapabilities() override;
  explicit constexpr CapabilityResponse_MatchCapabilities(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CapabilityResponse_MatchCapabilities(const CapabilityResponse_MatchCapabilities& from);
  CapabilityResponse_MatchCapabilities(CapabilityResponse_MatchCapabilities&& from) noexcept
    : CapabilityResponse_MatchCapabilities() {
    *this = ::std::move(from);
  }

  inline CapabilityResponse_MatchCapabilities& operator=(const CapabilityResponse_MatchCapabilities& from) {
    CopyFrom(from);
    return *this;
  }
  inline CapabilityResponse_MatchCapabilities& operator=(CapabilityResponse_MatchCapabilities&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CapabilityResponse_MatchCapabilities& default_instance() {
    return *internal_default_instance();
  }
  static inline const CapabilityResponse_MatchCapabilities* internal_default_instance() {
    return reinterpret_cast<const CapabilityResponse_MatchCapabilities*>(
               &_CapabilityResponse_MatchCapabilities_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(CapabilityResponse_MatchCapabilities& a, CapabilityResponse_MatchCapabilities& b) {
    a.Swap(&b);
  }
  inline void Swap(CapabilityResponse_MatchCapabilities* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CapabilityResponse_MatchCapabilities* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CapabilityResponse_MatchCapabilities* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CapabilityResponse_MatchCapabilities>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CapabilityResponse_MatchCapabilities& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CapabilityResponse_MatchCapabilities& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CapabilityResponse_MatchCapabilities* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tunneloffload.v1alpha1.CapabilityResponse.MatchCapabilities";
  }
  protected:
  explicit CapabilityResponse_MatchCapabilities(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIngressInterfaceMatchingFieldNumber = 1,
    kVxlanMatchingFieldNumber = 2,
    kGeneveMatchingFieldNumber = 3,
    kTunnelMatchingFieldNumber = 4,
    kSpiMatchingFieldNumber = 5,
  };
  // bool ingress_interface_matching = 1;
  void clear_ingress_interface_matching();
  bool ingress_interface_matching() const;
  void set_ingress_interface_matching(bool value);
  private:
  bool _internal_ingress_interface_matching() const;
  void _internal_set_ingress_interface_matching(bool value);
  public:

  // bool vxlan_matching = 2;
  void clear_vxlan_matching();
  bool vxlan_matching() const;
  void set_vxlan_matching(bool value);
  private:
  bool _internal_vxlan_matching() const;
  void _internal_set_vxlan_matching(bool value);
  public:

  // bool geneve_matching = 3;
  void clear_geneve_matching();
  bool geneve_matching() const;
  void set_geneve_matching(bool value);
  private:
  bool _internal_geneve_matching() const;
  void _internal_set_geneve_matching(bool value);
  public:

  // bool tunnel_matching = 4;
  void clear_tunnel_matching();
  bool tunnel_matching() const;
  void set_tunnel_matching(bool value);
  private:
  bool _internal_tunnel_matching() const;
  void _internal_set_tunnel_matching(bool value);
  public:

  // bool spi_matching = 5;
  void clear_spi_matching();
  bool spi_matching() const;
  void set_spi_matching(bool value);
  private:
  bool _internal_spi_matching() const;
  void _internal_set_spi_matching(bool value);
  public:

  // @@protoc_insertion_point(class_scope:tunneloffload.v1alpha1.CapabilityResponse.MatchCapabilities)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool ingress_interface_matching_;
  bool vxlan_matching_;
  bool geneve_matching_;
  bool tunnel_matching_;
  bool spi_matching_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tunneloffload_2eproto;
};
// -------------------------------------------------------------------

class CapabilityResponse_IPSecCapabilities final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tunneloffload.v1alpha1.CapabilityResponse.IPSecCapabilities) */ {
 public:
  inline CapabilityResponse_IPSecCapabilities() : CapabilityResponse_IPSecCapabilities(nullptr) {}
  ~CapabilityResponse_IPSecCapabilities() override;
  explicit constexpr CapabilityResponse_IPSecCapabilities(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CapabilityResponse_IPSecCapabilities(const CapabilityResponse_IPSecCapabilities& from);
  CapabilityResponse_IPSecCapabilities(CapabilityResponse_IPSecCapabilities&& from) noexcept
    : CapabilityResponse_IPSecCapabilities() {
    *this = ::std::move(from);
  }

  inline CapabilityResponse_IPSecCapabilities& operator=(const CapabilityResponse_IPSecCapabilities& from) {
    CopyFrom(from);
    return *this;
  }
  inline CapabilityResponse_IPSecCapabilities& operator=(CapabilityResponse_IPSecCapabilities&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CapabilityResponse_IPSecCapabilities& default_instance() {
    return *internal_default_instance();
  }
  static inline const CapabilityResponse_IPSecCapabilities* internal_default_instance() {
    return reinterpret_cast<const CapabilityResponse_IPSecCapabilities*>(
               &_CapabilityResponse_IPSecCapabilities_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(CapabilityResponse_IPSecCapabilities& a, CapabilityResponse_IPSecCapabilities& b) {
    a.Swap(&b);
  }
  inline void Swap(CapabilityResponse_IPSecCapabilities* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CapabilityResponse_IPSecCapabilities* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CapabilityResponse_IPSecCapabilities* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CapabilityResponse_IPSecCapabilities>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CapabilityResponse_IPSecCapabilities& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CapabilityResponse_IPSecCapabilities& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CapabilityResponse_IPSecCapabilities* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tunneloffload.v1alpha1.CapabilityResponse.IPSecCapabilities";
  }
  protected:
  explicit CapabilityResponse_IPSecCapabilities(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTunnelTypeSupportedFieldNumber = 1,
    kEncryptionSupportedFieldNumber = 2,
  };
  // repeated .tunneloffload.v1alpha1.IPSecTunnelType tunnel_type_supported = 1;
  int tunnel_type_supported_size() const;
  private:
  int _internal_tunnel_type_supported_size() const;
  public:
  void clear_tunnel_type_supported();
  private:
  ::tunneloffload::v1alpha1::IPSecTunnelType _internal_tunnel_type_supported(int index) const;
  void _internal_add_tunnel_type_supported(::tunneloffload::v1alpha1::IPSecTunnelType value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_tunnel_type_supported();
  public:
  ::tunneloffload::v1alpha1::IPSecTunnelType tunnel_type_supported(int index) const;
  void set_tunnel_type_supported(int index, ::tunneloffload::v1alpha1::IPSecTunnelType value);
  void add_tunnel_type_supported(::tunneloffload::v1alpha1::IPSecTunnelType value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& tunnel_type_supported() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_tunnel_type_supported();

  // repeated .tunneloffload.v1alpha1.EncType encryption_supported = 2;
  int encryption_supported_size() const;
  private:
  int _internal_encryption_supported_size() const;
  public:
  void clear_encryption_supported();
  private:
  ::tunneloffload::v1alpha1::EncType _internal_encryption_supported(int index) const;
  void _internal_add_encryption_supported(::tunneloffload::v1alpha1::EncType value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_encryption_supported();
  public:
  ::tunneloffload::v1alpha1::EncType encryption_supported(int index) const;
  void set_encryption_supported(int index, ::tunneloffload::v1alpha1::EncType value);
  void add_encryption_supported(::tunneloffload::v1alpha1::EncType value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& encryption_supported() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_encryption_supported();

  // @@protoc_insertion_point(class_scope:tunneloffload.v1alpha1.CapabilityResponse.IPSecCapabilities)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> tunnel_type_supported_;
  mutable std::atomic<int> _tunnel_type_supported_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> encryption_supported_;
  mutable std::atomic<int> _encryption_supported_cached_byte_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tunneloffload_2eproto;
};
// -------------------------------------------------------------------

class CapabilityResponse_GeneveCapabilities final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tunneloffload.v1alpha1.CapabilityResponse.GeneveCapabilities) */ {
 public:
  inline CapabilityResponse_GeneveCapabilities() : CapabilityResponse_GeneveCapabilities(nullptr) {}
  ~CapabilityResponse_GeneveCapabilities() override;
  explicit constexpr CapabilityResponse_GeneveCapabilities(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CapabilityResponse_GeneveCapabilities(const CapabilityResponse_GeneveCapabilities& from);
  CapabilityResponse_GeneveCapabilities(CapabilityResponse_GeneveCapabilities&& from) noexcept
    : CapabilityResponse_GeneveCapabilities() {
    *this = ::std::move(from);
  }

  inline CapabilityResponse_GeneveCapabilities& operator=(const CapabilityResponse_GeneveCapabilities& from) {
    CopyFrom(from);
    return *this;
  }
  inline CapabilityResponse_GeneveCapabilities& operator=(CapabilityResponse_GeneveCapabilities&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CapabilityResponse_GeneveCapabilities& default_instance() {
    return *internal_default_instance();
  }
  static inline const CapabilityResponse_GeneveCapabilities* internal_default_instance() {
    return reinterpret_cast<const CapabilityResponse_GeneveCapabilities*>(
               &_CapabilityResponse_GeneveCapabilities_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(CapabilityResponse_GeneveCapabilities& a, CapabilityResponse_GeneveCapabilities& b) {
    a.Swap(&b);
  }
  inline void Swap(CapabilityResponse_GeneveCapabilities* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CapabilityResponse_GeneveCapabilities* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CapabilityResponse_GeneveCapabilities* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CapabilityResponse_GeneveCapabilities>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CapabilityResponse_GeneveCapabilities& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CapabilityResponse_GeneveCapabilities& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CapabilityResponse_GeneveCapabilities* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tunneloffload.v1alpha1.CapabilityResponse.GeneveCapabilities";
  }
  protected:
  explicit CapabilityResponse_GeneveCapabilities(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNumberGeneveOptionsSupportedFieldNumber = 1,
  };
  // uint32 number_geneve_options_supported = 1;
  void clear_number_geneve_options_supported();
  uint32_t number_geneve_options_supported() const;
  void set_number_geneve_options_supported(uint32_t value);
  private:
  uint32_t _internal_number_geneve_options_supported() const;
  void _internal_set_number_geneve_options_supported(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:tunneloffload.v1alpha1.CapabilityResponse.GeneveCapabilities)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t number_geneve_options_supported_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tunneloffload_2eproto;
};
// -------------------------------------------------------------------

class CapabilityResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tunneloffload.v1alpha1.CapabilityResponse) */ {
 public:
  inline CapabilityResponse() : CapabilityResponse(nullptr) {}
  ~CapabilityResponse() override;
  explicit constexpr CapabilityResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CapabilityResponse(const CapabilityResponse& from);
  CapabilityResponse(CapabilityResponse&& from) noexcept
    : CapabilityResponse() {
    *this = ::std::move(from);
  }

  inline CapabilityResponse& operator=(const CapabilityResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CapabilityResponse& operator=(CapabilityResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CapabilityResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CapabilityResponse* internal_default_instance() {
    return reinterpret_cast<const CapabilityResponse*>(
               &_CapabilityResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(CapabilityResponse& a, CapabilityResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CapabilityResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CapabilityResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CapabilityResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CapabilityResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CapabilityResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CapabilityResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CapabilityResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tunneloffload.v1alpha1.CapabilityResponse";
  }
  protected:
  explicit CapabilityResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CapabilityResponse_MatchCapabilities MatchCapabilities;
  typedef CapabilityResponse_IPSecCapabilities IPSecCapabilities;
  typedef CapabilityResponse_GeneveCapabilities GeneveCapabilities;

  // accessors -------------------------------------------------------

  enum : int {
    kMatchCapabilitiesFieldNumber = 1,
    kIpsecCapabilitiesFieldNumber = 2,
    kGeneveCapabilitiesFieldNumber = 3,
  };
  // .tunneloffload.v1alpha1.CapabilityResponse.MatchCapabilities match_capabilities = 1;
  bool has_match_capabilities() const;
  private:
  bool _internal_has_match_capabilities() const;
  public:
  void clear_match_capabilities();
  const ::tunneloffload::v1alpha1::CapabilityResponse_MatchCapabilities& match_capabilities() const;
  PROTOBUF_NODISCARD ::tunneloffload::v1alpha1::CapabilityResponse_MatchCapabilities* release_match_capabilities();
  ::tunneloffload::v1alpha1::CapabilityResponse_MatchCapabilities* mutable_match_capabilities();
  void set_allocated_match_capabilities(::tunneloffload::v1alpha1::CapabilityResponse_MatchCapabilities* match_capabilities);
  private:
  const ::tunneloffload::v1alpha1::CapabilityResponse_MatchCapabilities& _internal_match_capabilities() const;
  ::tunneloffload::v1alpha1::CapabilityResponse_MatchCapabilities* _internal_mutable_match_capabilities();
  public:
  void unsafe_arena_set_allocated_match_capabilities(
      ::tunneloffload::v1alpha1::CapabilityResponse_MatchCapabilities* match_capabilities);
  ::tunneloffload::v1alpha1::CapabilityResponse_MatchCapabilities* unsafe_arena_release_match_capabilities();

  // .tunneloffload.v1alpha1.CapabilityResponse.IPSecCapabilities ipsec_capabilities = 2;
  bool has_ipsec_capabilities() const;
  private:
  bool _internal_has_ipsec_capabilities() const;
  public:
  void clear_ipsec_capabilities();
  const ::tunneloffload::v1alpha1::CapabilityResponse_IPSecCapabilities& ipsec_capabilities() const;
  PROTOBUF_NODISCARD ::tunneloffload::v1alpha1::CapabilityResponse_IPSecCapabilities* release_ipsec_capabilities();
  ::tunneloffload::v1alpha1::CapabilityResponse_IPSecCapabilities* mutable_ipsec_capabilities();
  void set_allocated_ipsec_capabilities(::tunneloffload::v1alpha1::CapabilityResponse_IPSecCapabilities* ipsec_capabilities);
  private:
  const ::tunneloffload::v1alpha1::CapabilityResponse_IPSecCapabilities& _internal_ipsec_capabilities() const;
  ::tunneloffload::v1alpha1::CapabilityResponse_IPSecCapabilities* _internal_mutable_ipsec_capabilities();
  public:
  void unsafe_arena_set_allocated_ipsec_capabilities(
      ::tunneloffload::v1alpha1::CapabilityResponse_IPSecCapabilities* ipsec_capabilities);
  ::tunneloffload::v1alpha1::CapabilityResponse_IPSecCapabilities* unsafe_arena_release_ipsec_capabilities();

  // .tunneloffload.v1alpha1.CapabilityResponse.GeneveCapabilities geneve_capabilities = 3;
  bool has_geneve_capabilities() const;
  private:
  bool _internal_has_geneve_capabilities() const;
  public:
  void clear_geneve_capabilities();
  const ::tunneloffload::v1alpha1::CapabilityResponse_GeneveCapabilities& geneve_capabilities() const;
  PROTOBUF_NODISCARD ::tunneloffload::v1alpha1::CapabilityResponse_GeneveCapabilities* release_geneve_capabilities();
  ::tunneloffload::v1alpha1::CapabilityResponse_GeneveCapabilities* mutable_geneve_capabilities();
  void set_allocated_geneve_capabilities(::tunneloffload::v1alpha1::CapabilityResponse_GeneveCapabilities* geneve_capabilities);
  private:
  const ::tunneloffload::v1alpha1::CapabilityResponse_GeneveCapabilities& _internal_geneve_capabilities() const;
  ::tunneloffload::v1alpha1::CapabilityResponse_GeneveCapabilities* _internal_mutable_geneve_capabilities();
  public:
  void unsafe_arena_set_allocated_geneve_capabilities(
      ::tunneloffload::v1alpha1::CapabilityResponse_GeneveCapabilities* geneve_capabilities);
  ::tunneloffload::v1alpha1::CapabilityResponse_GeneveCapabilities* unsafe_arena_release_geneve_capabilities();

  // @@protoc_insertion_point(class_scope:tunneloffload.v1alpha1.CapabilityResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::tunneloffload::v1alpha1::CapabilityResponse_MatchCapabilities* match_capabilities_;
  ::tunneloffload::v1alpha1::CapabilityResponse_IPSecCapabilities* ipsec_capabilities_;
  ::tunneloffload::v1alpha1::CapabilityResponse_GeneveCapabilities* geneve_capabilities_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tunneloffload_2eproto;
};
// -------------------------------------------------------------------

class TunnelAdditionError final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tunneloffload.v1alpha1.TunnelAdditionError) */ {
 public:
  inline TunnelAdditionError() : TunnelAdditionError(nullptr) {}
  ~TunnelAdditionError() override;
  explicit constexpr TunnelAdditionError(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TunnelAdditionError(const TunnelAdditionError& from);
  TunnelAdditionError(TunnelAdditionError&& from) noexcept
    : TunnelAdditionError() {
    *this = ::std::move(from);
  }

  inline TunnelAdditionError& operator=(const TunnelAdditionError& from) {
    CopyFrom(from);
    return *this;
  }
  inline TunnelAdditionError& operator=(TunnelAdditionError&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TunnelAdditionError& default_instance() {
    return *internal_default_instance();
  }
  static inline const TunnelAdditionError* internal_default_instance() {
    return reinterpret_cast<const TunnelAdditionError*>(
               &_TunnelAdditionError_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(TunnelAdditionError& a, TunnelAdditionError& b) {
    a.Swap(&b);
  }
  inline void Swap(TunnelAdditionError* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TunnelAdditionError* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TunnelAdditionError* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TunnelAdditionError>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TunnelAdditionError& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TunnelAdditionError& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TunnelAdditionError* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tunneloffload.v1alpha1.TunnelAdditionError";
  }
  protected:
  explicit TunnelAdditionError(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMatchErrorFieldNumber = 1,
    kTunnelErrorFieldNumber = 2,
    kIpsecErrorFieldNumber = 3,
    kGeneveErrorFieldNumber = 4,
  };
  // .tunneloffload.v1alpha1.MatchError match_error = 1;
  void clear_match_error();
  ::tunneloffload::v1alpha1::MatchError match_error() const;
  void set_match_error(::tunneloffload::v1alpha1::MatchError value);
  private:
  ::tunneloffload::v1alpha1::MatchError _internal_match_error() const;
  void _internal_set_match_error(::tunneloffload::v1alpha1::MatchError value);
  public:

  // .tunneloffload.v1alpha1.TunnelError tunnel_error = 2;
  void clear_tunnel_error();
  ::tunneloffload::v1alpha1::TunnelError tunnel_error() const;
  void set_tunnel_error(::tunneloffload::v1alpha1::TunnelError value);
  private:
  ::tunneloffload::v1alpha1::TunnelError _internal_tunnel_error() const;
  void _internal_set_tunnel_error(::tunneloffload::v1alpha1::TunnelError value);
  public:

  // .tunneloffload.v1alpha1.IPSecError ipsec_error = 3;
  void clear_ipsec_error();
  ::tunneloffload::v1alpha1::IPSecError ipsec_error() const;
  void set_ipsec_error(::tunneloffload::v1alpha1::IPSecError value);
  private:
  ::tunneloffload::v1alpha1::IPSecError _internal_ipsec_error() const;
  void _internal_set_ipsec_error(::tunneloffload::v1alpha1::IPSecError value);
  public:

  // .tunneloffload.v1alpha1.GeneveError geneve_error = 4;
  void clear_geneve_error();
  ::tunneloffload::v1alpha1::GeneveError geneve_error() const;
  void set_geneve_error(::tunneloffload::v1alpha1::GeneveError value);
  private:
  ::tunneloffload::v1alpha1::GeneveError _internal_geneve_error() const;
  void _internal_set_geneve_error(::tunneloffload::v1alpha1::GeneveError value);
  public:

  // @@protoc_insertion_point(class_scope:tunneloffload.v1alpha1.TunnelAdditionError)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int match_error_;
  int tunnel_error_;
  int ipsec_error_;
  int geneve_error_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tunneloffload_2eproto;
};
// -------------------------------------------------------------------

class MatchCriteria_IPSecMatch final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tunneloffload.v1alpha1.MatchCriteria.IPSecMatch) */ {
 public:
  inline MatchCriteria_IPSecMatch() : MatchCriteria_IPSecMatch(nullptr) {}
  ~MatchCriteria_IPSecMatch() override;
  explicit constexpr MatchCriteria_IPSecMatch(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MatchCriteria_IPSecMatch(const MatchCriteria_IPSecMatch& from);
  MatchCriteria_IPSecMatch(MatchCriteria_IPSecMatch&& from) noexcept
    : MatchCriteria_IPSecMatch() {
    *this = ::std::move(from);
  }

  inline MatchCriteria_IPSecMatch& operator=(const MatchCriteria_IPSecMatch& from) {
    CopyFrom(from);
    return *this;
  }
  inline MatchCriteria_IPSecMatch& operator=(MatchCriteria_IPSecMatch&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MatchCriteria_IPSecMatch& default_instance() {
    return *internal_default_instance();
  }
  static inline const MatchCriteria_IPSecMatch* internal_default_instance() {
    return reinterpret_cast<const MatchCriteria_IPSecMatch*>(
               &_MatchCriteria_IPSecMatch_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(MatchCriteria_IPSecMatch& a, MatchCriteria_IPSecMatch& b) {
    a.Swap(&b);
  }
  inline void Swap(MatchCriteria_IPSecMatch* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MatchCriteria_IPSecMatch* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MatchCriteria_IPSecMatch* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MatchCriteria_IPSecMatch>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MatchCriteria_IPSecMatch& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MatchCriteria_IPSecMatch& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MatchCriteria_IPSecMatch* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tunneloffload.v1alpha1.MatchCriteria.IPSecMatch";
  }
  protected:
  explicit MatchCriteria_IPSecMatch(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpiFieldNumber = 1,
    kSnFieldNumber = 2,
  };
  // uint32 spi = 1;
  void clear_spi();
  uint32_t spi() const;
  void set_spi(uint32_t value);
  private:
  uint32_t _internal_spi() const;
  void _internal_set_spi(uint32_t value);
  public:

  // uint32 sn = 2;
  void clear_sn();
  uint32_t sn() const;
  void set_sn(uint32_t value);
  private:
  uint32_t _internal_sn() const;
  void _internal_set_sn(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:tunneloffload.v1alpha1.MatchCriteria.IPSecMatch)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t spi_;
  uint32_t sn_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tunneloffload_2eproto;
};
// -------------------------------------------------------------------

class MatchCriteria_GeneveMatch final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tunneloffload.v1alpha1.MatchCriteria.GeneveMatch) */ {
 public:
  inline MatchCriteria_GeneveMatch() : MatchCriteria_GeneveMatch(nullptr) {}
  ~MatchCriteria_GeneveMatch() override;
  explicit constexpr MatchCriteria_GeneveMatch(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MatchCriteria_GeneveMatch(const MatchCriteria_GeneveMatch& from);
  MatchCriteria_GeneveMatch(MatchCriteria_GeneveMatch&& from) noexcept
    : MatchCriteria_GeneveMatch() {
    *this = ::std::move(from);
  }

  inline MatchCriteria_GeneveMatch& operator=(const MatchCriteria_GeneveMatch& from) {
    CopyFrom(from);
    return *this;
  }
  inline MatchCriteria_GeneveMatch& operator=(MatchCriteria_GeneveMatch&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MatchCriteria_GeneveMatch& default_instance() {
    return *internal_default_instance();
  }
  enum IpMatchCase {
    kIpv4Match = 4,
    kIpv6Match = 5,
    IP_MATCH_NOT_SET = 0,
  };

  static inline const MatchCriteria_GeneveMatch* internal_default_instance() {
    return reinterpret_cast<const MatchCriteria_GeneveMatch*>(
               &_MatchCriteria_GeneveMatch_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(MatchCriteria_GeneveMatch& a, MatchCriteria_GeneveMatch& b) {
    a.Swap(&b);
  }
  inline void Swap(MatchCriteria_GeneveMatch* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MatchCriteria_GeneveMatch* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MatchCriteria_GeneveMatch* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MatchCriteria_GeneveMatch>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MatchCriteria_GeneveMatch& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MatchCriteria_GeneveMatch& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MatchCriteria_GeneveMatch* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tunneloffload.v1alpha1.MatchCriteria.GeneveMatch";
  }
  protected:
  explicit MatchCriteria_GeneveMatch(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMacMatchFieldNumber = 2,
    kVniFieldNumber = 1,
    kProtocolTypeFieldNumber = 3,
    kIpv4MatchFieldNumber = 4,
    kIpv6MatchFieldNumber = 5,
  };
  // .tunneloffload.v1alpha1.MacPair mac_match = 2;
  bool has_mac_match() const;
  private:
  bool _internal_has_mac_match() const;
  public:
  void clear_mac_match();
  const ::tunneloffload::v1alpha1::MacPair& mac_match() const;
  PROTOBUF_NODISCARD ::tunneloffload::v1alpha1::MacPair* release_mac_match();
  ::tunneloffload::v1alpha1::MacPair* mutable_mac_match();
  void set_allocated_mac_match(::tunneloffload::v1alpha1::MacPair* mac_match);
  private:
  const ::tunneloffload::v1alpha1::MacPair& _internal_mac_match() const;
  ::tunneloffload::v1alpha1::MacPair* _internal_mutable_mac_match();
  public:
  void unsafe_arena_set_allocated_mac_match(
      ::tunneloffload::v1alpha1::MacPair* mac_match);
  ::tunneloffload::v1alpha1::MacPair* unsafe_arena_release_mac_match();

  // uint32 vni = 1;
  void clear_vni();
  uint32_t vni() const;
  void set_vni(uint32_t value);
  private:
  uint32_t _internal_vni() const;
  void _internal_set_vni(uint32_t value);
  public:

  // uint32 protocol_type = 3;
  void clear_protocol_type();
  uint32_t protocol_type() const;
  void set_protocol_type(uint32_t value);
  private:
  uint32_t _internal_protocol_type() const;
  void _internal_set_protocol_type(uint32_t value);
  public:

  // .tunneloffload.v1alpha1.IPV4Match ipv4_match = 4;
  bool has_ipv4_match() const;
  private:
  bool _internal_has_ipv4_match() const;
  public:
  void clear_ipv4_match();
  const ::tunneloffload::v1alpha1::IPV4Match& ipv4_match() const;
  PROTOBUF_NODISCARD ::tunneloffload::v1alpha1::IPV4Match* release_ipv4_match();
  ::tunneloffload::v1alpha1::IPV4Match* mutable_ipv4_match();
  void set_allocated_ipv4_match(::tunneloffload::v1alpha1::IPV4Match* ipv4_match);
  private:
  const ::tunneloffload::v1alpha1::IPV4Match& _internal_ipv4_match() const;
  ::tunneloffload::v1alpha1::IPV4Match* _internal_mutable_ipv4_match();
  public:
  void unsafe_arena_set_allocated_ipv4_match(
      ::tunneloffload::v1alpha1::IPV4Match* ipv4_match);
  ::tunneloffload::v1alpha1::IPV4Match* unsafe_arena_release_ipv4_match();

  // .tunneloffload.v1alpha1.IPV6Match ipv6_match = 5;
  bool has_ipv6_match() const;
  private:
  bool _internal_has_ipv6_match() const;
  public:
  void clear_ipv6_match();
  const ::tunneloffload::v1alpha1::IPV6Match& ipv6_match() const;
  PROTOBUF_NODISCARD ::tunneloffload::v1alpha1::IPV6Match* release_ipv6_match();
  ::tunneloffload::v1alpha1::IPV6Match* mutable_ipv6_match();
  void set_allocated_ipv6_match(::tunneloffload::v1alpha1::IPV6Match* ipv6_match);
  private:
  const ::tunneloffload::v1alpha1::IPV6Match& _internal_ipv6_match() const;
  ::tunneloffload::v1alpha1::IPV6Match* _internal_mutable_ipv6_match();
  public:
  void unsafe_arena_set_allocated_ipv6_match(
      ::tunneloffload::v1alpha1::IPV6Match* ipv6_match);
  ::tunneloffload::v1alpha1::IPV6Match* unsafe_arena_release_ipv6_match();

  void clear_ip_match();
  IpMatchCase ip_match_case() const;
  // @@protoc_insertion_point(class_scope:tunneloffload.v1alpha1.MatchCriteria.GeneveMatch)
 private:
  class _Internal;
  void set_has_ipv4_match();
  void set_has_ipv6_match();

  inline bool has_ip_match() const;
  inline void clear_has_ip_match();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::tunneloffload::v1alpha1::MacPair* mac_match_;
  uint32_t vni_;
  uint32_t protocol_type_;
  union IpMatchUnion {
    constexpr IpMatchUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::tunneloffload::v1alpha1::IPV4Match* ipv4_match_;
    ::tunneloffload::v1alpha1::IPV6Match* ipv6_match_;
  } ip_match_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_tunneloffload_2eproto;
};
// -------------------------------------------------------------------

class MatchCriteria_VXLanMatch final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tunneloffload.v1alpha1.MatchCriteria.VXLanMatch) */ {
 public:
  inline MatchCriteria_VXLanMatch() : MatchCriteria_VXLanMatch(nullptr) {}
  ~MatchCriteria_VXLanMatch() override;
  explicit constexpr MatchCriteria_VXLanMatch(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MatchCriteria_VXLanMatch(const MatchCriteria_VXLanMatch& from);
  MatchCriteria_VXLanMatch(MatchCriteria_VXLanMatch&& from) noexcept
    : MatchCriteria_VXLanMatch() {
    *this = ::std::move(from);
  }

  inline MatchCriteria_VXLanMatch& operator=(const MatchCriteria_VXLanMatch& from) {
    CopyFrom(from);
    return *this;
  }
  inline MatchCriteria_VXLanMatch& operator=(MatchCriteria_VXLanMatch&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MatchCriteria_VXLanMatch& default_instance() {
    return *internal_default_instance();
  }
  enum IpMatchCase {
    kIpv4Match = 3,
    kIpv6Match = 4,
    IP_MATCH_NOT_SET = 0,
  };

  static inline const MatchCriteria_VXLanMatch* internal_default_instance() {
    return reinterpret_cast<const MatchCriteria_VXLanMatch*>(
               &_MatchCriteria_VXLanMatch_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(MatchCriteria_VXLanMatch& a, MatchCriteria_VXLanMatch& b) {
    a.Swap(&b);
  }
  inline void Swap(MatchCriteria_VXLanMatch* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MatchCriteria_VXLanMatch* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MatchCriteria_VXLanMatch* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MatchCriteria_VXLanMatch>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MatchCriteria_VXLanMatch& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MatchCriteria_VXLanMatch& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MatchCriteria_VXLanMatch* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tunneloffload.v1alpha1.MatchCriteria.VXLanMatch";
  }
  protected:
  explicit MatchCriteria_VXLanMatch(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMacMatchFieldNumber = 2,
    kVniFieldNumber = 1,
    kIpv4MatchFieldNumber = 3,
    kIpv6MatchFieldNumber = 4,
  };
  // .tunneloffload.v1alpha1.MacPair mac_match = 2;
  bool has_mac_match() const;
  private:
  bool _internal_has_mac_match() const;
  public:
  void clear_mac_match();
  const ::tunneloffload::v1alpha1::MacPair& mac_match() const;
  PROTOBUF_NODISCARD ::tunneloffload::v1alpha1::MacPair* release_mac_match();
  ::tunneloffload::v1alpha1::MacPair* mutable_mac_match();
  void set_allocated_mac_match(::tunneloffload::v1alpha1::MacPair* mac_match);
  private:
  const ::tunneloffload::v1alpha1::MacPair& _internal_mac_match() const;
  ::tunneloffload::v1alpha1::MacPair* _internal_mutable_mac_match();
  public:
  void unsafe_arena_set_allocated_mac_match(
      ::tunneloffload::v1alpha1::MacPair* mac_match);
  ::tunneloffload::v1alpha1::MacPair* unsafe_arena_release_mac_match();

  // uint32 vni = 1;
  void clear_vni();
  uint32_t vni() const;
  void set_vni(uint32_t value);
  private:
  uint32_t _internal_vni() const;
  void _internal_set_vni(uint32_t value);
  public:

  // .tunneloffload.v1alpha1.IPV4Match ipv4_match = 3;
  bool has_ipv4_match() const;
  private:
  bool _internal_has_ipv4_match() const;
  public:
  void clear_ipv4_match();
  const ::tunneloffload::v1alpha1::IPV4Match& ipv4_match() const;
  PROTOBUF_NODISCARD ::tunneloffload::v1alpha1::IPV4Match* release_ipv4_match();
  ::tunneloffload::v1alpha1::IPV4Match* mutable_ipv4_match();
  void set_allocated_ipv4_match(::tunneloffload::v1alpha1::IPV4Match* ipv4_match);
  private:
  const ::tunneloffload::v1alpha1::IPV4Match& _internal_ipv4_match() const;
  ::tunneloffload::v1alpha1::IPV4Match* _internal_mutable_ipv4_match();
  public:
  void unsafe_arena_set_allocated_ipv4_match(
      ::tunneloffload::v1alpha1::IPV4Match* ipv4_match);
  ::tunneloffload::v1alpha1::IPV4Match* unsafe_arena_release_ipv4_match();

  // .tunneloffload.v1alpha1.IPV6Match ipv6_match = 4;
  bool has_ipv6_match() const;
  private:
  bool _internal_has_ipv6_match() const;
  public:
  void clear_ipv6_match();
  const ::tunneloffload::v1alpha1::IPV6Match& ipv6_match() const;
  PROTOBUF_NODISCARD ::tunneloffload::v1alpha1::IPV6Match* release_ipv6_match();
  ::tunneloffload::v1alpha1::IPV6Match* mutable_ipv6_match();
  void set_allocated_ipv6_match(::tunneloffload::v1alpha1::IPV6Match* ipv6_match);
  private:
  const ::tunneloffload::v1alpha1::IPV6Match& _internal_ipv6_match() const;
  ::tunneloffload::v1alpha1::IPV6Match* _internal_mutable_ipv6_match();
  public:
  void unsafe_arena_set_allocated_ipv6_match(
      ::tunneloffload::v1alpha1::IPV6Match* ipv6_match);
  ::tunneloffload::v1alpha1::IPV6Match* unsafe_arena_release_ipv6_match();

  void clear_ip_match();
  IpMatchCase ip_match_case() const;
  // @@protoc_insertion_point(class_scope:tunneloffload.v1alpha1.MatchCriteria.VXLanMatch)
 private:
  class _Internal;
  void set_has_ipv4_match();
  void set_has_ipv6_match();

  inline bool has_ip_match() const;
  inline void clear_has_ip_match();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::tunneloffload::v1alpha1::MacPair* mac_match_;
  uint32_t vni_;
  union IpMatchUnion {
    constexpr IpMatchUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::tunneloffload::v1alpha1::IPV4Match* ipv4_match_;
    ::tunneloffload::v1alpha1::IPV6Match* ipv6_match_;
  } ip_match_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_tunneloffload_2eproto;
};
// -------------------------------------------------------------------

class MatchCriteria final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tunneloffload.v1alpha1.MatchCriteria) */ {
 public:
  inline MatchCriteria() : MatchCriteria(nullptr) {}
  ~MatchCriteria() override;
  explicit constexpr MatchCriteria(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MatchCriteria(const MatchCriteria& from);
  MatchCriteria(MatchCriteria&& from) noexcept
    : MatchCriteria() {
    *this = ::std::move(from);
  }

  inline MatchCriteria& operator=(const MatchCriteria& from) {
    CopyFrom(from);
    return *this;
  }
  inline MatchCriteria& operator=(MatchCriteria&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MatchCriteria& default_instance() {
    return *internal_default_instance();
  }
  enum IpMatchCase {
    kIpv4Match = 3,
    kIpv6Match = 4,
    IP_MATCH_NOT_SET = 0,
  };

  enum MatchCase {
    kIpsecMatch = 6,
    kGeneveMatch = 7,
    kVxlanMatch = 8,
    MATCH_NOT_SET = 0,
  };

  static inline const MatchCriteria* internal_default_instance() {
    return reinterpret_cast<const MatchCriteria*>(
               &_MatchCriteria_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(MatchCriteria& a, MatchCriteria& b) {
    a.Swap(&b);
  }
  inline void Swap(MatchCriteria* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MatchCriteria* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MatchCriteria* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MatchCriteria>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MatchCriteria& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MatchCriteria& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MatchCriteria* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tunneloffload.v1alpha1.MatchCriteria";
  }
  protected:
  explicit MatchCriteria(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef MatchCriteria_IPSecMatch IPSecMatch;
  typedef MatchCriteria_GeneveMatch GeneveMatch;
  typedef MatchCriteria_VXLanMatch VXLanMatch;

  // accessors -------------------------------------------------------

  enum : int {
    kIngressInterfaceFieldNumber = 1,
    kMacMatchFieldNumber = 2,
    kTunnelIdFieldNumber = 5,
    kIpv4MatchFieldNumber = 3,
    kIpv6MatchFieldNumber = 4,
    kIpsecMatchFieldNumber = 6,
    kGeneveMatchFieldNumber = 7,
    kVxlanMatchFieldNumber = 8,
  };
  // string ingress_interface = 1;
  void clear_ingress_interface();
  const std::string& ingress_interface() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ingress_interface(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ingress_interface();
  PROTOBUF_NODISCARD std::string* release_ingress_interface();
  void set_allocated_ingress_interface(std::string* ingress_interface);
  private:
  const std::string& _internal_ingress_interface() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ingress_interface(const std::string& value);
  std::string* _internal_mutable_ingress_interface();
  public:

  // .tunneloffload.v1alpha1.MacPair mac_match = 2;
  bool has_mac_match() const;
  private:
  bool _internal_has_mac_match() const;
  public:
  void clear_mac_match();
  const ::tunneloffload::v1alpha1::MacPair& mac_match() const;
  PROTOBUF_NODISCARD ::tunneloffload::v1alpha1::MacPair* release_mac_match();
  ::tunneloffload::v1alpha1::MacPair* mutable_mac_match();
  void set_allocated_mac_match(::tunneloffload::v1alpha1::MacPair* mac_match);
  private:
  const ::tunneloffload::v1alpha1::MacPair& _internal_mac_match() const;
  ::tunneloffload::v1alpha1::MacPair* _internal_mutable_mac_match();
  public:
  void unsafe_arena_set_allocated_mac_match(
      ::tunneloffload::v1alpha1::MacPair* mac_match);
  ::tunneloffload::v1alpha1::MacPair* unsafe_arena_release_mac_match();

  // uint64 tunnel_id = 5;
  void clear_tunnel_id();
  uint64_t tunnel_id() const;
  void set_tunnel_id(uint64_t value);
  private:
  uint64_t _internal_tunnel_id() const;
  void _internal_set_tunnel_id(uint64_t value);
  public:

  // .tunneloffload.v1alpha1.IPV4Match ipv4_match = 3;
  bool has_ipv4_match() const;
  private:
  bool _internal_has_ipv4_match() const;
  public:
  void clear_ipv4_match();
  const ::tunneloffload::v1alpha1::IPV4Match& ipv4_match() const;
  PROTOBUF_NODISCARD ::tunneloffload::v1alpha1::IPV4Match* release_ipv4_match();
  ::tunneloffload::v1alpha1::IPV4Match* mutable_ipv4_match();
  void set_allocated_ipv4_match(::tunneloffload::v1alpha1::IPV4Match* ipv4_match);
  private:
  const ::tunneloffload::v1alpha1::IPV4Match& _internal_ipv4_match() const;
  ::tunneloffload::v1alpha1::IPV4Match* _internal_mutable_ipv4_match();
  public:
  void unsafe_arena_set_allocated_ipv4_match(
      ::tunneloffload::v1alpha1::IPV4Match* ipv4_match);
  ::tunneloffload::v1alpha1::IPV4Match* unsafe_arena_release_ipv4_match();

  // .tunneloffload.v1alpha1.IPV6Match ipv6_match = 4;
  bool has_ipv6_match() const;
  private:
  bool _internal_has_ipv6_match() const;
  public:
  void clear_ipv6_match();
  const ::tunneloffload::v1alpha1::IPV6Match& ipv6_match() const;
  PROTOBUF_NODISCARD ::tunneloffload::v1alpha1::IPV6Match* release_ipv6_match();
  ::tunneloffload::v1alpha1::IPV6Match* mutable_ipv6_match();
  void set_allocated_ipv6_match(::tunneloffload::v1alpha1::IPV6Match* ipv6_match);
  private:
  const ::tunneloffload::v1alpha1::IPV6Match& _internal_ipv6_match() const;
  ::tunneloffload::v1alpha1::IPV6Match* _internal_mutable_ipv6_match();
  public:
  void unsafe_arena_set_allocated_ipv6_match(
      ::tunneloffload::v1alpha1::IPV6Match* ipv6_match);
  ::tunneloffload::v1alpha1::IPV6Match* unsafe_arena_release_ipv6_match();

  // .tunneloffload.v1alpha1.MatchCriteria.IPSecMatch ipsec_match = 6;
  bool has_ipsec_match() const;
  private:
  bool _internal_has_ipsec_match() const;
  public:
  void clear_ipsec_match();
  const ::tunneloffload::v1alpha1::MatchCriteria_IPSecMatch& ipsec_match() const;
  PROTOBUF_NODISCARD ::tunneloffload::v1alpha1::MatchCriteria_IPSecMatch* release_ipsec_match();
  ::tunneloffload::v1alpha1::MatchCriteria_IPSecMatch* mutable_ipsec_match();
  void set_allocated_ipsec_match(::tunneloffload::v1alpha1::MatchCriteria_IPSecMatch* ipsec_match);
  private:
  const ::tunneloffload::v1alpha1::MatchCriteria_IPSecMatch& _internal_ipsec_match() const;
  ::tunneloffload::v1alpha1::MatchCriteria_IPSecMatch* _internal_mutable_ipsec_match();
  public:
  void unsafe_arena_set_allocated_ipsec_match(
      ::tunneloffload::v1alpha1::MatchCriteria_IPSecMatch* ipsec_match);
  ::tunneloffload::v1alpha1::MatchCriteria_IPSecMatch* unsafe_arena_release_ipsec_match();

  // .tunneloffload.v1alpha1.MatchCriteria.GeneveMatch geneve_match = 7;
  bool has_geneve_match() const;
  private:
  bool _internal_has_geneve_match() const;
  public:
  void clear_geneve_match();
  const ::tunneloffload::v1alpha1::MatchCriteria_GeneveMatch& geneve_match() const;
  PROTOBUF_NODISCARD ::tunneloffload::v1alpha1::MatchCriteria_GeneveMatch* release_geneve_match();
  ::tunneloffload::v1alpha1::MatchCriteria_GeneveMatch* mutable_geneve_match();
  void set_allocated_geneve_match(::tunneloffload::v1alpha1::MatchCriteria_GeneveMatch* geneve_match);
  private:
  const ::tunneloffload::v1alpha1::MatchCriteria_GeneveMatch& _internal_geneve_match() const;
  ::tunneloffload::v1alpha1::MatchCriteria_GeneveMatch* _internal_mutable_geneve_match();
  public:
  void unsafe_arena_set_allocated_geneve_match(
      ::tunneloffload::v1alpha1::MatchCriteria_GeneveMatch* geneve_match);
  ::tunneloffload::v1alpha1::MatchCriteria_GeneveMatch* unsafe_arena_release_geneve_match();

  // .tunneloffload.v1alpha1.MatchCriteria.VXLanMatch vxlan_match = 8;
  bool has_vxlan_match() const;
  private:
  bool _internal_has_vxlan_match() const;
  public:
  void clear_vxlan_match();
  const ::tunneloffload::v1alpha1::MatchCriteria_VXLanMatch& vxlan_match() const;
  PROTOBUF_NODISCARD ::tunneloffload::v1alpha1::MatchCriteria_VXLanMatch* release_vxlan_match();
  ::tunneloffload::v1alpha1::MatchCriteria_VXLanMatch* mutable_vxlan_match();
  void set_allocated_vxlan_match(::tunneloffload::v1alpha1::MatchCriteria_VXLanMatch* vxlan_match);
  private:
  const ::tunneloffload::v1alpha1::MatchCriteria_VXLanMatch& _internal_vxlan_match() const;
  ::tunneloffload::v1alpha1::MatchCriteria_VXLanMatch* _internal_mutable_vxlan_match();
  public:
  void unsafe_arena_set_allocated_vxlan_match(
      ::tunneloffload::v1alpha1::MatchCriteria_VXLanMatch* vxlan_match);
  ::tunneloffload::v1alpha1::MatchCriteria_VXLanMatch* unsafe_arena_release_vxlan_match();

  void clear_ip_match();
  IpMatchCase ip_match_case() const;
  void clear_match();
  MatchCase match_case() const;
  // @@protoc_insertion_point(class_scope:tunneloffload.v1alpha1.MatchCriteria)
 private:
  class _Internal;
  void set_has_ipv4_match();
  void set_has_ipv6_match();
  void set_has_ipsec_match();
  void set_has_geneve_match();
  void set_has_vxlan_match();

  inline bool has_ip_match() const;
  inline void clear_has_ip_match();

  inline bool has_match() const;
  inline void clear_has_match();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ingress_interface_;
  ::tunneloffload::v1alpha1::MacPair* mac_match_;
  uint64_t tunnel_id_;
  union IpMatchUnion {
    constexpr IpMatchUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::tunneloffload::v1alpha1::IPV4Match* ipv4_match_;
    ::tunneloffload::v1alpha1::IPV6Match* ipv6_match_;
  } ip_match_;
  union MatchUnion {
    constexpr MatchUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::tunneloffload::v1alpha1::MatchCriteria_IPSecMatch* ipsec_match_;
    ::tunneloffload::v1alpha1::MatchCriteria_GeneveMatch* geneve_match_;
    ::tunneloffload::v1alpha1::MatchCriteria_VXLanMatch* vxlan_match_;
  } match_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[2];

  friend struct ::TableStruct_tunneloffload_2eproto;
};
// -------------------------------------------------------------------

class IpTunnelRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tunneloffload.v1alpha1.IpTunnelRequest) */ {
 public:
  inline IpTunnelRequest() : IpTunnelRequest(nullptr) {}
  ~IpTunnelRequest() override;
  explicit constexpr IpTunnelRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IpTunnelRequest(const IpTunnelRequest& from);
  IpTunnelRequest(IpTunnelRequest&& from) noexcept
    : IpTunnelRequest() {
    *this = ::std::move(from);
  }

  inline IpTunnelRequest& operator=(const IpTunnelRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline IpTunnelRequest& operator=(IpTunnelRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IpTunnelRequest& default_instance() {
    return *internal_default_instance();
  }
  enum TunnelCase {
    kIpsecTunnel = 5,
    kGeneve = 6,
    kNat = 7,
    TUNNEL_NOT_SET = 0,
  };

  static inline const IpTunnelRequest* internal_default_instance() {
    return reinterpret_cast<const IpTunnelRequest*>(
               &_IpTunnelRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(IpTunnelRequest& a, IpTunnelRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(IpTunnelRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IpTunnelRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IpTunnelRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IpTunnelRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IpTunnelRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const IpTunnelRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IpTunnelRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tunneloffload.v1alpha1.IpTunnelRequest";
  }
  protected:
  explicit IpTunnelRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMatchCriteriaFieldNumber = 3,
    kTunnelIdFieldNumber = 1,
    kOperationFieldNumber = 2,
    kNextActionFieldNumber = 4,
    kIpsecTunnelFieldNumber = 5,
    kGeneveFieldNumber = 6,
    kNatFieldNumber = 7,
  };
  // .tunneloffload.v1alpha1.MatchCriteria match_criteria = 3;
  bool has_match_criteria() const;
  private:
  bool _internal_has_match_criteria() const;
  public:
  void clear_match_criteria();
  const ::tunneloffload::v1alpha1::MatchCriteria& match_criteria() const;
  PROTOBUF_NODISCARD ::tunneloffload::v1alpha1::MatchCriteria* release_match_criteria();
  ::tunneloffload::v1alpha1::MatchCriteria* mutable_match_criteria();
  void set_allocated_match_criteria(::tunneloffload::v1alpha1::MatchCriteria* match_criteria);
  private:
  const ::tunneloffload::v1alpha1::MatchCriteria& _internal_match_criteria() const;
  ::tunneloffload::v1alpha1::MatchCriteria* _internal_mutable_match_criteria();
  public:
  void unsafe_arena_set_allocated_match_criteria(
      ::tunneloffload::v1alpha1::MatchCriteria* match_criteria);
  ::tunneloffload::v1alpha1::MatchCriteria* unsafe_arena_release_match_criteria();

  // uint64 tunnel_id = 1;
  void clear_tunnel_id();
  uint64_t tunnel_id() const;
  void set_tunnel_id(uint64_t value);
  private:
  uint64_t _internal_tunnel_id() const;
  void _internal_set_tunnel_id(uint64_t value);
  public:

  // .tunneloffload.v1alpha1.Operation operation = 2;
  void clear_operation();
  ::tunneloffload::v1alpha1::Operation operation() const;
  void set_operation(::tunneloffload::v1alpha1::Operation value);
  private:
  ::tunneloffload::v1alpha1::Operation _internal_operation() const;
  void _internal_set_operation(::tunneloffload::v1alpha1::Operation value);
  public:

  // .tunneloffload.v1alpha1.Action next_action = 4;
  void clear_next_action();
  ::tunneloffload::v1alpha1::Action next_action() const;
  void set_next_action(::tunneloffload::v1alpha1::Action value);
  private:
  ::tunneloffload::v1alpha1::Action _internal_next_action() const;
  void _internal_set_next_action(::tunneloffload::v1alpha1::Action value);
  public:

  // .tunneloffload.v1alpha1.IPSecTunnel ipsec_tunnel = 5;
  bool has_ipsec_tunnel() const;
  private:
  bool _internal_has_ipsec_tunnel() const;
  public:
  void clear_ipsec_tunnel();
  const ::tunneloffload::v1alpha1::IPSecTunnel& ipsec_tunnel() const;
  PROTOBUF_NODISCARD ::tunneloffload::v1alpha1::IPSecTunnel* release_ipsec_tunnel();
  ::tunneloffload::v1alpha1::IPSecTunnel* mutable_ipsec_tunnel();
  void set_allocated_ipsec_tunnel(::tunneloffload::v1alpha1::IPSecTunnel* ipsec_tunnel);
  private:
  const ::tunneloffload::v1alpha1::IPSecTunnel& _internal_ipsec_tunnel() const;
  ::tunneloffload::v1alpha1::IPSecTunnel* _internal_mutable_ipsec_tunnel();
  public:
  void unsafe_arena_set_allocated_ipsec_tunnel(
      ::tunneloffload::v1alpha1::IPSecTunnel* ipsec_tunnel);
  ::tunneloffload::v1alpha1::IPSecTunnel* unsafe_arena_release_ipsec_tunnel();

  // .tunneloffload.v1alpha1.Geneve geneve = 6;
  bool has_geneve() const;
  private:
  bool _internal_has_geneve() const;
  public:
  void clear_geneve();
  const ::tunneloffload::v1alpha1::Geneve& geneve() const;
  PROTOBUF_NODISCARD ::tunneloffload::v1alpha1::Geneve* release_geneve();
  ::tunneloffload::v1alpha1::Geneve* mutable_geneve();
  void set_allocated_geneve(::tunneloffload::v1alpha1::Geneve* geneve);
  private:
  const ::tunneloffload::v1alpha1::Geneve& _internal_geneve() const;
  ::tunneloffload::v1alpha1::Geneve* _internal_mutable_geneve();
  public:
  void unsafe_arena_set_allocated_geneve(
      ::tunneloffload::v1alpha1::Geneve* geneve);
  ::tunneloffload::v1alpha1::Geneve* unsafe_arena_release_geneve();

  // .tunneloffload.v1alpha1.Nat nat = 7;
  bool has_nat() const;
  private:
  bool _internal_has_nat() const;
  public:
  void clear_nat();
  const ::tunneloffload::v1alpha1::Nat& nat() const;
  PROTOBUF_NODISCARD ::tunneloffload::v1alpha1::Nat* release_nat();
  ::tunneloffload::v1alpha1::Nat* mutable_nat();
  void set_allocated_nat(::tunneloffload::v1alpha1::Nat* nat);
  private:
  const ::tunneloffload::v1alpha1::Nat& _internal_nat() const;
  ::tunneloffload::v1alpha1::Nat* _internal_mutable_nat();
  public:
  void unsafe_arena_set_allocated_nat(
      ::tunneloffload::v1alpha1::Nat* nat);
  ::tunneloffload::v1alpha1::Nat* unsafe_arena_release_nat();

  void clear_tunnel();
  TunnelCase tunnel_case() const;
  // @@protoc_insertion_point(class_scope:tunneloffload.v1alpha1.IpTunnelRequest)
 private:
  class _Internal;
  void set_has_ipsec_tunnel();
  void set_has_geneve();
  void set_has_nat();

  inline bool has_tunnel() const;
  inline void clear_has_tunnel();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::tunneloffload::v1alpha1::MatchCriteria* match_criteria_;
  uint64_t tunnel_id_;
  int operation_;
  int next_action_;
  union TunnelUnion {
    constexpr TunnelUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::tunneloffload::v1alpha1::IPSecTunnel* ipsec_tunnel_;
    ::tunneloffload::v1alpha1::Geneve* geneve_;
    ::tunneloffload::v1alpha1::Nat* nat_;
  } tunnel_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_tunneloffload_2eproto;
};
// -------------------------------------------------------------------

class Geneve final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tunneloffload.v1alpha1.Geneve) */ {
 public:
  inline Geneve() : Geneve(nullptr) {}
  ~Geneve() override;
  explicit constexpr Geneve(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Geneve(const Geneve& from);
  Geneve(Geneve&& from) noexcept
    : Geneve() {
    *this = ::std::move(from);
  }

  inline Geneve& operator=(const Geneve& from) {
    CopyFrom(from);
    return *this;
  }
  inline Geneve& operator=(Geneve&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Geneve& default_instance() {
    return *internal_default_instance();
  }
  enum EncapDecapCase {
    kGeneveEncap = 1,
    kGeneveDecap = 2,
    ENCAP_DECAP_NOT_SET = 0,
  };

  static inline const Geneve* internal_default_instance() {
    return reinterpret_cast<const Geneve*>(
               &_Geneve_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Geneve& a, Geneve& b) {
    a.Swap(&b);
  }
  inline void Swap(Geneve* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Geneve* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Geneve* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Geneve>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Geneve& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Geneve& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Geneve* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tunneloffload.v1alpha1.Geneve";
  }
  protected:
  explicit Geneve(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGeneveEncapFieldNumber = 1,
    kGeneveDecapFieldNumber = 2,
  };
  // .tunneloffload.v1alpha1.GeneveEncap geneve_encap = 1;
  bool has_geneve_encap() const;
  private:
  bool _internal_has_geneve_encap() const;
  public:
  void clear_geneve_encap();
  const ::tunneloffload::v1alpha1::GeneveEncap& geneve_encap() const;
  PROTOBUF_NODISCARD ::tunneloffload::v1alpha1::GeneveEncap* release_geneve_encap();
  ::tunneloffload::v1alpha1::GeneveEncap* mutable_geneve_encap();
  void set_allocated_geneve_encap(::tunneloffload::v1alpha1::GeneveEncap* geneve_encap);
  private:
  const ::tunneloffload::v1alpha1::GeneveEncap& _internal_geneve_encap() const;
  ::tunneloffload::v1alpha1::GeneveEncap* _internal_mutable_geneve_encap();
  public:
  void unsafe_arena_set_allocated_geneve_encap(
      ::tunneloffload::v1alpha1::GeneveEncap* geneve_encap);
  ::tunneloffload::v1alpha1::GeneveEncap* unsafe_arena_release_geneve_encap();

  // .tunneloffload.v1alpha1.GeneveDecap geneve_decap = 2;
  bool has_geneve_decap() const;
  private:
  bool _internal_has_geneve_decap() const;
  public:
  void clear_geneve_decap();
  const ::tunneloffload::v1alpha1::GeneveDecap& geneve_decap() const;
  PROTOBUF_NODISCARD ::tunneloffload::v1alpha1::GeneveDecap* release_geneve_decap();
  ::tunneloffload::v1alpha1::GeneveDecap* mutable_geneve_decap();
  void set_allocated_geneve_decap(::tunneloffload::v1alpha1::GeneveDecap* geneve_decap);
  private:
  const ::tunneloffload::v1alpha1::GeneveDecap& _internal_geneve_decap() const;
  ::tunneloffload::v1alpha1::GeneveDecap* _internal_mutable_geneve_decap();
  public:
  void unsafe_arena_set_allocated_geneve_decap(
      ::tunneloffload::v1alpha1::GeneveDecap* geneve_decap);
  ::tunneloffload::v1alpha1::GeneveDecap* unsafe_arena_release_geneve_decap();

  void clear_encap_decap();
  EncapDecapCase encap_decap_case() const;
  // @@protoc_insertion_point(class_scope:tunneloffload.v1alpha1.Geneve)
 private:
  class _Internal;
  void set_has_geneve_encap();
  void set_has_geneve_decap();

  inline bool has_encap_decap() const;
  inline void clear_has_encap_decap();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union EncapDecapUnion {
    constexpr EncapDecapUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::tunneloffload::v1alpha1::GeneveEncap* geneve_encap_;
    ::tunneloffload::v1alpha1::GeneveDecap* geneve_decap_;
  } encap_decap_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_tunneloffload_2eproto;
};
// -------------------------------------------------------------------

class GeneveOption final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tunneloffload.v1alpha1.GeneveOption) */ {
 public:
  inline GeneveOption() : GeneveOption(nullptr) {}
  ~GeneveOption() override;
  explicit constexpr GeneveOption(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GeneveOption(const GeneveOption& from);
  GeneveOption(GeneveOption&& from) noexcept
    : GeneveOption() {
    *this = ::std::move(from);
  }

  inline GeneveOption& operator=(const GeneveOption& from) {
    CopyFrom(from);
    return *this;
  }
  inline GeneveOption& operator=(GeneveOption&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GeneveOption& default_instance() {
    return *internal_default_instance();
  }
  static inline const GeneveOption* internal_default_instance() {
    return reinterpret_cast<const GeneveOption*>(
               &_GeneveOption_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(GeneveOption& a, GeneveOption& b) {
    a.Swap(&b);
  }
  inline void Swap(GeneveOption* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GeneveOption* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GeneveOption* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GeneveOption>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GeneveOption& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GeneveOption& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GeneveOption* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tunneloffload.v1alpha1.GeneveOption";
  }
  protected:
  explicit GeneveOption(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 4,
    kOptionClassFieldNumber = 1,
    kTypeFieldNumber = 2,
    kLengthFieldNumber = 3,
  };
  // bytes data = 4;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // uint32 option_class = 1;
  void clear_option_class();
  uint32_t option_class() const;
  void set_option_class(uint32_t value);
  private:
  uint32_t _internal_option_class() const;
  void _internal_set_option_class(uint32_t value);
  public:

  // uint32 type = 2;
  void clear_type();
  uint32_t type() const;
  void set_type(uint32_t value);
  private:
  uint32_t _internal_type() const;
  void _internal_set_type(uint32_t value);
  public:

  // uint32 length = 3;
  void clear_length();
  uint32_t length() const;
  void set_length(uint32_t value);
  private:
  uint32_t _internal_length() const;
  void _internal_set_length(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:tunneloffload.v1alpha1.GeneveOption)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  uint32_t option_class_;
  uint32_t type_;
  uint32_t length_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tunneloffload_2eproto;
};
// -------------------------------------------------------------------

class GeneveEncap final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tunneloffload.v1alpha1.GeneveEncap) */ {
 public:
  inline GeneveEncap() : GeneveEncap(nullptr) {}
  ~GeneveEncap() override;
  explicit constexpr GeneveEncap(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GeneveEncap(const GeneveEncap& from);
  GeneveEncap(GeneveEncap&& from) noexcept
    : GeneveEncap() {
    *this = ::std::move(from);
  }

  inline GeneveEncap& operator=(const GeneveEncap& from) {
    CopyFrom(from);
    return *this;
  }
  inline GeneveEncap& operator=(GeneveEncap&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GeneveEncap& default_instance() {
    return *internal_default_instance();
  }
  enum IpCase {
    kOuterIpv4Pair = 1,
    kOuterIpv6Pair = 2,
    IP_NOT_SET = 0,
  };

  static inline const GeneveEncap* internal_default_instance() {
    return reinterpret_cast<const GeneveEncap*>(
               &_GeneveEncap_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(GeneveEncap& a, GeneveEncap& b) {
    a.Swap(&b);
  }
  inline void Swap(GeneveEncap* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GeneveEncap* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GeneveEncap* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GeneveEncap>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GeneveEncap& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GeneveEncap& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GeneveEncap* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tunneloffload.v1alpha1.GeneveEncap";
  }
  protected:
  explicit GeneveEncap(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGeneveOptionFieldNumber = 9,
    kInnerMacPairFieldNumber = 3,
    kOptionLengthFieldNumber = 4,
    kControlPacketFieldNumber = 5,
    kCriticalOptionPresentFieldNumber = 6,
    kVniFieldNumber = 7,
    kProtocolTypeFieldNumber = 8,
    kOuterIpv4PairFieldNumber = 1,
    kOuterIpv6PairFieldNumber = 2,
  };
  // repeated .tunneloffload.v1alpha1.GeneveOption geneve_option = 9;
  int geneve_option_size() const;
  private:
  int _internal_geneve_option_size() const;
  public:
  void clear_geneve_option();
  ::tunneloffload::v1alpha1::GeneveOption* mutable_geneve_option(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tunneloffload::v1alpha1::GeneveOption >*
      mutable_geneve_option();
  private:
  const ::tunneloffload::v1alpha1::GeneveOption& _internal_geneve_option(int index) const;
  ::tunneloffload::v1alpha1::GeneveOption* _internal_add_geneve_option();
  public:
  const ::tunneloffload::v1alpha1::GeneveOption& geneve_option(int index) const;
  ::tunneloffload::v1alpha1::GeneveOption* add_geneve_option();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tunneloffload::v1alpha1::GeneveOption >&
      geneve_option() const;

  // .tunneloffload.v1alpha1.MacPair inner_mac_pair = 3;
  bool has_inner_mac_pair() const;
  private:
  bool _internal_has_inner_mac_pair() const;
  public:
  void clear_inner_mac_pair();
  const ::tunneloffload::v1alpha1::MacPair& inner_mac_pair() const;
  PROTOBUF_NODISCARD ::tunneloffload::v1alpha1::MacPair* release_inner_mac_pair();
  ::tunneloffload::v1alpha1::MacPair* mutable_inner_mac_pair();
  void set_allocated_inner_mac_pair(::tunneloffload::v1alpha1::MacPair* inner_mac_pair);
  private:
  const ::tunneloffload::v1alpha1::MacPair& _internal_inner_mac_pair() const;
  ::tunneloffload::v1alpha1::MacPair* _internal_mutable_inner_mac_pair();
  public:
  void unsafe_arena_set_allocated_inner_mac_pair(
      ::tunneloffload::v1alpha1::MacPair* inner_mac_pair);
  ::tunneloffload::v1alpha1::MacPair* unsafe_arena_release_inner_mac_pair();

  // uint32 option_length = 4;
  void clear_option_length();
  uint32_t option_length() const;
  void set_option_length(uint32_t value);
  private:
  uint32_t _internal_option_length() const;
  void _internal_set_option_length(uint32_t value);
  public:

  // bool control_packet = 5;
  void clear_control_packet();
  bool control_packet() const;
  void set_control_packet(bool value);
  private:
  bool _internal_control_packet() const;
  void _internal_set_control_packet(bool value);
  public:

  // bool critical_option_present = 6;
  void clear_critical_option_present();
  bool critical_option_present() const;
  void set_critical_option_present(bool value);
  private:
  bool _internal_critical_option_present() const;
  void _internal_set_critical_option_present(bool value);
  public:

  // uint32 vni = 7;
  void clear_vni();
  uint32_t vni() const;
  void set_vni(uint32_t value);
  private:
  uint32_t _internal_vni() const;
  void _internal_set_vni(uint32_t value);
  public:

  // uint32 protocol_type = 8;
  void clear_protocol_type();
  uint32_t protocol_type() const;
  void set_protocol_type(uint32_t value);
  private:
  uint32_t _internal_protocol_type() const;
  void _internal_set_protocol_type(uint32_t value);
  public:

  // .tunneloffload.v1alpha1.IPV4Pair outer_ipv4_pair = 1;
  bool has_outer_ipv4_pair() const;
  private:
  bool _internal_has_outer_ipv4_pair() const;
  public:
  void clear_outer_ipv4_pair();
  const ::tunneloffload::v1alpha1::IPV4Pair& outer_ipv4_pair() const;
  PROTOBUF_NODISCARD ::tunneloffload::v1alpha1::IPV4Pair* release_outer_ipv4_pair();
  ::tunneloffload::v1alpha1::IPV4Pair* mutable_outer_ipv4_pair();
  void set_allocated_outer_ipv4_pair(::tunneloffload::v1alpha1::IPV4Pair* outer_ipv4_pair);
  private:
  const ::tunneloffload::v1alpha1::IPV4Pair& _internal_outer_ipv4_pair() const;
  ::tunneloffload::v1alpha1::IPV4Pair* _internal_mutable_outer_ipv4_pair();
  public:
  void unsafe_arena_set_allocated_outer_ipv4_pair(
      ::tunneloffload::v1alpha1::IPV4Pair* outer_ipv4_pair);
  ::tunneloffload::v1alpha1::IPV4Pair* unsafe_arena_release_outer_ipv4_pair();

  // .tunneloffload.v1alpha1.IPV6Pair outer_ipv6_pair = 2;
  bool has_outer_ipv6_pair() const;
  private:
  bool _internal_has_outer_ipv6_pair() const;
  public:
  void clear_outer_ipv6_pair();
  const ::tunneloffload::v1alpha1::IPV6Pair& outer_ipv6_pair() const;
  PROTOBUF_NODISCARD ::tunneloffload::v1alpha1::IPV6Pair* release_outer_ipv6_pair();
  ::tunneloffload::v1alpha1::IPV6Pair* mutable_outer_ipv6_pair();
  void set_allocated_outer_ipv6_pair(::tunneloffload::v1alpha1::IPV6Pair* outer_ipv6_pair);
  private:
  const ::tunneloffload::v1alpha1::IPV6Pair& _internal_outer_ipv6_pair() const;
  ::tunneloffload::v1alpha1::IPV6Pair* _internal_mutable_outer_ipv6_pair();
  public:
  void unsafe_arena_set_allocated_outer_ipv6_pair(
      ::tunneloffload::v1alpha1::IPV6Pair* outer_ipv6_pair);
  ::tunneloffload::v1alpha1::IPV6Pair* unsafe_arena_release_outer_ipv6_pair();

  void clear_ip();
  IpCase ip_case() const;
  // @@protoc_insertion_point(class_scope:tunneloffload.v1alpha1.GeneveEncap)
 private:
  class _Internal;
  void set_has_outer_ipv4_pair();
  void set_has_outer_ipv6_pair();

  inline bool has_ip() const;
  inline void clear_has_ip();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tunneloffload::v1alpha1::GeneveOption > geneve_option_;
  ::tunneloffload::v1alpha1::MacPair* inner_mac_pair_;
  uint32_t option_length_;
  bool control_packet_;
  bool critical_option_present_;
  uint32_t vni_;
  uint32_t protocol_type_;
  union IpUnion {
    constexpr IpUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::tunneloffload::v1alpha1::IPV4Pair* outer_ipv4_pair_;
    ::tunneloffload::v1alpha1::IPV6Pair* outer_ipv6_pair_;
  } ip_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_tunneloffload_2eproto;
};
// -------------------------------------------------------------------

class GeneveDecap final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:tunneloffload.v1alpha1.GeneveDecap) */ {
 public:
  inline GeneveDecap() : GeneveDecap(nullptr) {}
  explicit constexpr GeneveDecap(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GeneveDecap(const GeneveDecap& from);
  GeneveDecap(GeneveDecap&& from) noexcept
    : GeneveDecap() {
    *this = ::std::move(from);
  }

  inline GeneveDecap& operator=(const GeneveDecap& from) {
    CopyFrom(from);
    return *this;
  }
  inline GeneveDecap& operator=(GeneveDecap&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GeneveDecap& default_instance() {
    return *internal_default_instance();
  }
  static inline const GeneveDecap* internal_default_instance() {
    return reinterpret_cast<const GeneveDecap*>(
               &_GeneveDecap_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(GeneveDecap& a, GeneveDecap& b) {
    a.Swap(&b);
  }
  inline void Swap(GeneveDecap* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GeneveDecap* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GeneveDecap* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GeneveDecap>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GeneveDecap& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GeneveDecap& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tunneloffload.v1alpha1.GeneveDecap";
  }
  protected:
  explicit GeneveDecap(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:tunneloffload.v1alpha1.GeneveDecap)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tunneloffload_2eproto;
};
// -------------------------------------------------------------------

class MacPair final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tunneloffload.v1alpha1.MacPair) */ {
 public:
  inline MacPair() : MacPair(nullptr) {}
  ~MacPair() override;
  explicit constexpr MacPair(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MacPair(const MacPair& from);
  MacPair(MacPair&& from) noexcept
    : MacPair() {
    *this = ::std::move(from);
  }

  inline MacPair& operator=(const MacPair& from) {
    CopyFrom(from);
    return *this;
  }
  inline MacPair& operator=(MacPair&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MacPair& default_instance() {
    return *internal_default_instance();
  }
  static inline const MacPair* internal_default_instance() {
    return reinterpret_cast<const MacPair*>(
               &_MacPair_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(MacPair& a, MacPair& b) {
    a.Swap(&b);
  }
  inline void Swap(MacPair* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MacPair* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MacPair* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MacPair>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MacPair& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MacPair& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MacPair* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tunneloffload.v1alpha1.MacPair";
  }
  protected:
  explicit MacPair(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDestinationMacFieldNumber = 1,
    kSourceMacFieldNumber = 2,
  };
  // bytes destination_mac = 1;
  void clear_destination_mac();
  const std::string& destination_mac() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_destination_mac(ArgT0&& arg0, ArgT... args);
  std::string* mutable_destination_mac();
  PROTOBUF_NODISCARD std::string* release_destination_mac();
  void set_allocated_destination_mac(std::string* destination_mac);
  private:
  const std::string& _internal_destination_mac() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_destination_mac(const std::string& value);
  std::string* _internal_mutable_destination_mac();
  public:

  // bytes source_mac = 2;
  void clear_source_mac();
  const std::string& source_mac() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_source_mac(ArgT0&& arg0, ArgT... args);
  std::string* mutable_source_mac();
  PROTOBUF_NODISCARD std::string* release_source_mac();
  void set_allocated_source_mac(std::string* source_mac);
  private:
  const std::string& _internal_source_mac() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_source_mac(const std::string& value);
  std::string* _internal_mutable_source_mac();
  public:

  // @@protoc_insertion_point(class_scope:tunneloffload.v1alpha1.MacPair)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr destination_mac_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr source_mac_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tunneloffload_2eproto;
};
// -------------------------------------------------------------------

class IPV4Pair final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tunneloffload.v1alpha1.IPV4Pair) */ {
 public:
  inline IPV4Pair() : IPV4Pair(nullptr) {}
  ~IPV4Pair() override;
  explicit constexpr IPV4Pair(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IPV4Pair(const IPV4Pair& from);
  IPV4Pair(IPV4Pair&& from) noexcept
    : IPV4Pair() {
    *this = ::std::move(from);
  }

  inline IPV4Pair& operator=(const IPV4Pair& from) {
    CopyFrom(from);
    return *this;
  }
  inline IPV4Pair& operator=(IPV4Pair&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IPV4Pair& default_instance() {
    return *internal_default_instance();
  }
  static inline const IPV4Pair* internal_default_instance() {
    return reinterpret_cast<const IPV4Pair*>(
               &_IPV4Pair_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(IPV4Pair& a, IPV4Pair& b) {
    a.Swap(&b);
  }
  inline void Swap(IPV4Pair* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IPV4Pair* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IPV4Pair* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IPV4Pair>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IPV4Pair& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const IPV4Pair& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IPV4Pair* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tunneloffload.v1alpha1.IPV4Pair";
  }
  protected:
  explicit IPV4Pair(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSourceIpFieldNumber = 1,
    kDestinationIpFieldNumber = 2,
  };
  // fixed32 source_ip = 1;
  void clear_source_ip();
  uint32_t source_ip() const;
  void set_source_ip(uint32_t value);
  private:
  uint32_t _internal_source_ip() const;
  void _internal_set_source_ip(uint32_t value);
  public:

  // fixed32 destination_ip = 2;
  void clear_destination_ip();
  uint32_t destination_ip() const;
  void set_destination_ip(uint32_t value);
  private:
  uint32_t _internal_destination_ip() const;
  void _internal_set_destination_ip(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:tunneloffload.v1alpha1.IPV4Pair)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t source_ip_;
  uint32_t destination_ip_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tunneloffload_2eproto;
};
// -------------------------------------------------------------------

class IPV6Pair final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tunneloffload.v1alpha1.IPV6Pair) */ {
 public:
  inline IPV6Pair() : IPV6Pair(nullptr) {}
  ~IPV6Pair() override;
  explicit constexpr IPV6Pair(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IPV6Pair(const IPV6Pair& from);
  IPV6Pair(IPV6Pair&& from) noexcept
    : IPV6Pair() {
    *this = ::std::move(from);
  }

  inline IPV6Pair& operator=(const IPV6Pair& from) {
    CopyFrom(from);
    return *this;
  }
  inline IPV6Pair& operator=(IPV6Pair&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IPV6Pair& default_instance() {
    return *internal_default_instance();
  }
  static inline const IPV6Pair* internal_default_instance() {
    return reinterpret_cast<const IPV6Pair*>(
               &_IPV6Pair_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(IPV6Pair& a, IPV6Pair& b) {
    a.Swap(&b);
  }
  inline void Swap(IPV6Pair* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IPV6Pair* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IPV6Pair* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IPV6Pair>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IPV6Pair& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const IPV6Pair& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IPV6Pair* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tunneloffload.v1alpha1.IPV6Pair";
  }
  protected:
  explicit IPV6Pair(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSourceIpFieldNumber = 1,
    kDestinationIpFieldNumber = 2,
  };
  // bytes source_ip = 1;
  void clear_source_ip();
  const std::string& source_ip() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_source_ip(ArgT0&& arg0, ArgT... args);
  std::string* mutable_source_ip();
  PROTOBUF_NODISCARD std::string* release_source_ip();
  void set_allocated_source_ip(std::string* source_ip);
  private:
  const std::string& _internal_source_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_source_ip(const std::string& value);
  std::string* _internal_mutable_source_ip();
  public:

  // bytes destination_ip = 2;
  void clear_destination_ip();
  const std::string& destination_ip() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_destination_ip(ArgT0&& arg0, ArgT... args);
  std::string* mutable_destination_ip();
  PROTOBUF_NODISCARD std::string* release_destination_ip();
  void set_allocated_destination_ip(std::string* destination_ip);
  private:
  const std::string& _internal_destination_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_destination_ip(const std::string& value);
  std::string* _internal_mutable_destination_ip();
  public:

  // @@protoc_insertion_point(class_scope:tunneloffload.v1alpha1.IPV6Pair)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr source_ip_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr destination_ip_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tunneloffload_2eproto;
};
// -------------------------------------------------------------------

class IPV4Match final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tunneloffload.v1alpha1.IPV4Match) */ {
 public:
  inline IPV4Match() : IPV4Match(nullptr) {}
  ~IPV4Match() override;
  explicit constexpr IPV4Match(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IPV4Match(const IPV4Match& from);
  IPV4Match(IPV4Match&& from) noexcept
    : IPV4Match() {
    *this = ::std::move(from);
  }

  inline IPV4Match& operator=(const IPV4Match& from) {
    CopyFrom(from);
    return *this;
  }
  inline IPV4Match& operator=(IPV4Match&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IPV4Match& default_instance() {
    return *internal_default_instance();
  }
  static inline const IPV4Match* internal_default_instance() {
    return reinterpret_cast<const IPV4Match*>(
               &_IPV4Match_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(IPV4Match& a, IPV4Match& b) {
    a.Swap(&b);
  }
  inline void Swap(IPV4Match* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IPV4Match* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IPV4Match* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IPV4Match>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IPV4Match& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const IPV4Match& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IPV4Match* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tunneloffload.v1alpha1.IPV4Match";
  }
  protected:
  explicit IPV4Match(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSourceIpFieldNumber = 1,
    kSourceIpPrefixFieldNumber = 2,
    kDestinationIpFieldNumber = 3,
    kDestinationIpPrefixFieldNumber = 4,
  };
  // fixed32 source_ip = 1;
  void clear_source_ip();
  uint32_t source_ip() const;
  void set_source_ip(uint32_t value);
  private:
  uint32_t _internal_source_ip() const;
  void _internal_set_source_ip(uint32_t value);
  public:

  // uint32 source_ip_prefix = 2;
  void clear_source_ip_prefix();
  uint32_t source_ip_prefix() const;
  void set_source_ip_prefix(uint32_t value);
  private:
  uint32_t _internal_source_ip_prefix() const;
  void _internal_set_source_ip_prefix(uint32_t value);
  public:

  // fixed32 destination_ip = 3;
  void clear_destination_ip();
  uint32_t destination_ip() const;
  void set_destination_ip(uint32_t value);
  private:
  uint32_t _internal_destination_ip() const;
  void _internal_set_destination_ip(uint32_t value);
  public:

  // uint32 destination_ip_prefix = 4;
  void clear_destination_ip_prefix();
  uint32_t destination_ip_prefix() const;
  void set_destination_ip_prefix(uint32_t value);
  private:
  uint32_t _internal_destination_ip_prefix() const;
  void _internal_set_destination_ip_prefix(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:tunneloffload.v1alpha1.IPV4Match)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t source_ip_;
  uint32_t source_ip_prefix_;
  uint32_t destination_ip_;
  uint32_t destination_ip_prefix_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tunneloffload_2eproto;
};
// -------------------------------------------------------------------

class IPV6Match final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tunneloffload.v1alpha1.IPV6Match) */ {
 public:
  inline IPV6Match() : IPV6Match(nullptr) {}
  ~IPV6Match() override;
  explicit constexpr IPV6Match(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IPV6Match(const IPV6Match& from);
  IPV6Match(IPV6Match&& from) noexcept
    : IPV6Match() {
    *this = ::std::move(from);
  }

  inline IPV6Match& operator=(const IPV6Match& from) {
    CopyFrom(from);
    return *this;
  }
  inline IPV6Match& operator=(IPV6Match&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IPV6Match& default_instance() {
    return *internal_default_instance();
  }
  static inline const IPV6Match* internal_default_instance() {
    return reinterpret_cast<const IPV6Match*>(
               &_IPV6Match_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(IPV6Match& a, IPV6Match& b) {
    a.Swap(&b);
  }
  inline void Swap(IPV6Match* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IPV6Match* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IPV6Match* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IPV6Match>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IPV6Match& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const IPV6Match& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IPV6Match* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tunneloffload.v1alpha1.IPV6Match";
  }
  protected:
  explicit IPV6Match(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSourceIpFieldNumber = 1,
    kDestinationIpFieldNumber = 3,
    kSourceIpPrefixFieldNumber = 2,
    kDestinationIpPrefixFieldNumber = 4,
  };
  // bytes source_ip = 1;
  void clear_source_ip();
  const std::string& source_ip() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_source_ip(ArgT0&& arg0, ArgT... args);
  std::string* mutable_source_ip();
  PROTOBUF_NODISCARD std::string* release_source_ip();
  void set_allocated_source_ip(std::string* source_ip);
  private:
  const std::string& _internal_source_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_source_ip(const std::string& value);
  std::string* _internal_mutable_source_ip();
  public:

  // bytes destination_ip = 3;
  void clear_destination_ip();
  const std::string& destination_ip() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_destination_ip(ArgT0&& arg0, ArgT... args);
  std::string* mutable_destination_ip();
  PROTOBUF_NODISCARD std::string* release_destination_ip();
  void set_allocated_destination_ip(std::string* destination_ip);
  private:
  const std::string& _internal_destination_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_destination_ip(const std::string& value);
  std::string* _internal_mutable_destination_ip();
  public:

  // uint32 source_ip_prefix = 2;
  void clear_source_ip_prefix();
  uint32_t source_ip_prefix() const;
  void set_source_ip_prefix(uint32_t value);
  private:
  uint32_t _internal_source_ip_prefix() const;
  void _internal_set_source_ip_prefix(uint32_t value);
  public:

  // uint32 destination_ip_prefix = 4;
  void clear_destination_ip_prefix();
  uint32_t destination_ip_prefix() const;
  void set_destination_ip_prefix(uint32_t value);
  private:
  uint32_t _internal_destination_ip_prefix() const;
  void _internal_set_destination_ip_prefix(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:tunneloffload.v1alpha1.IPV6Match)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr source_ip_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr destination_ip_;
  uint32_t source_ip_prefix_;
  uint32_t destination_ip_prefix_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tunneloffload_2eproto;
};
// -------------------------------------------------------------------

class Nat final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tunneloffload.v1alpha1.Nat) */ {
 public:
  inline Nat() : Nat(nullptr) {}
  ~Nat() override;
  explicit constexpr Nat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Nat(const Nat& from);
  Nat(Nat&& from) noexcept
    : Nat() {
    *this = ::std::move(from);
  }

  inline Nat& operator=(const Nat& from) {
    CopyFrom(from);
    return *this;
  }
  inline Nat& operator=(Nat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Nat& default_instance() {
    return *internal_default_instance();
  }
  static inline const Nat* internal_default_instance() {
    return reinterpret_cast<const Nat*>(
               &_Nat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(Nat& a, Nat& b) {
    a.Swap(&b);
  }
  inline void Swap(Nat* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Nat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Nat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Nat>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Nat& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Nat& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Nat* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tunneloffload.v1alpha1.Nat";
  }
  protected:
  explicit Nat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSourceIpFieldNumber = 1,
  };
  // uint32 source_ip = 1;
  void clear_source_ip();
  uint32_t source_ip() const;
  void set_source_ip(uint32_t value);
  private:
  uint32_t _internal_source_ip() const;
  void _internal_set_source_ip(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:tunneloffload.v1alpha1.Nat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t source_ip_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tunneloffload_2eproto;
};
// -------------------------------------------------------------------

class IPSecEnc final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tunneloffload.v1alpha1.IPSecEnc) */ {
 public:
  inline IPSecEnc() : IPSecEnc(nullptr) {}
  ~IPSecEnc() override;
  explicit constexpr IPSecEnc(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IPSecEnc(const IPSecEnc& from);
  IPSecEnc(IPSecEnc&& from) noexcept
    : IPSecEnc() {
    *this = ::std::move(from);
  }

  inline IPSecEnc& operator=(const IPSecEnc& from) {
    CopyFrom(from);
    return *this;
  }
  inline IPSecEnc& operator=(IPSecEnc&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IPSecEnc& default_instance() {
    return *internal_default_instance();
  }
  enum TunnelIpsCase {
    kIpv4Tunnel = 4,
    kIpv6Tunnel = 5,
    TUNNELIPS_NOT_SET = 0,
  };

  static inline const IPSecEnc* internal_default_instance() {
    return reinterpret_cast<const IPSecEnc*>(
               &_IPSecEnc_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(IPSecEnc& a, IPSecEnc& b) {
    a.Swap(&b);
  }
  inline void Swap(IPSecEnc* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IPSecEnc* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IPSecEnc* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IPSecEnc>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IPSecEnc& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const IPSecEnc& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IPSecEnc* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tunneloffload.v1alpha1.IPSecEnc";
  }
  protected:
  explicit IPSecEnc(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIpsecSaFieldNumber = 3,
    kTunnelTypeFieldNumber = 1,
    kEncryptionTypeFieldNumber = 2,
    kIpv4TunnelFieldNumber = 4,
    kIpv6TunnelFieldNumber = 5,
  };
  // .tunneloffload.v1alpha1.IPSecSAParams ipsec_sa = 3;
  bool has_ipsec_sa() const;
  private:
  bool _internal_has_ipsec_sa() const;
  public:
  void clear_ipsec_sa();
  const ::tunneloffload::v1alpha1::IPSecSAParams& ipsec_sa() const;
  PROTOBUF_NODISCARD ::tunneloffload::v1alpha1::IPSecSAParams* release_ipsec_sa();
  ::tunneloffload::v1alpha1::IPSecSAParams* mutable_ipsec_sa();
  void set_allocated_ipsec_sa(::tunneloffload::v1alpha1::IPSecSAParams* ipsec_sa);
  private:
  const ::tunneloffload::v1alpha1::IPSecSAParams& _internal_ipsec_sa() const;
  ::tunneloffload::v1alpha1::IPSecSAParams* _internal_mutable_ipsec_sa();
  public:
  void unsafe_arena_set_allocated_ipsec_sa(
      ::tunneloffload::v1alpha1::IPSecSAParams* ipsec_sa);
  ::tunneloffload::v1alpha1::IPSecSAParams* unsafe_arena_release_ipsec_sa();

  // .tunneloffload.v1alpha1.IPSecTunnelType tunnel_type = 1;
  void clear_tunnel_type();
  ::tunneloffload::v1alpha1::IPSecTunnelType tunnel_type() const;
  void set_tunnel_type(::tunneloffload::v1alpha1::IPSecTunnelType value);
  private:
  ::tunneloffload::v1alpha1::IPSecTunnelType _internal_tunnel_type() const;
  void _internal_set_tunnel_type(::tunneloffload::v1alpha1::IPSecTunnelType value);
  public:

  // .tunneloffload.v1alpha1.EncType encryption_type = 2;
  void clear_encryption_type();
  ::tunneloffload::v1alpha1::EncType encryption_type() const;
  void set_encryption_type(::tunneloffload::v1alpha1::EncType value);
  private:
  ::tunneloffload::v1alpha1::EncType _internal_encryption_type() const;
  void _internal_set_encryption_type(::tunneloffload::v1alpha1::EncType value);
  public:

  // .tunneloffload.v1alpha1.IPV4Pair ipv4_tunnel = 4;
  bool has_ipv4_tunnel() const;
  private:
  bool _internal_has_ipv4_tunnel() const;
  public:
  void clear_ipv4_tunnel();
  const ::tunneloffload::v1alpha1::IPV4Pair& ipv4_tunnel() const;
  PROTOBUF_NODISCARD ::tunneloffload::v1alpha1::IPV4Pair* release_ipv4_tunnel();
  ::tunneloffload::v1alpha1::IPV4Pair* mutable_ipv4_tunnel();
  void set_allocated_ipv4_tunnel(::tunneloffload::v1alpha1::IPV4Pair* ipv4_tunnel);
  private:
  const ::tunneloffload::v1alpha1::IPV4Pair& _internal_ipv4_tunnel() const;
  ::tunneloffload::v1alpha1::IPV4Pair* _internal_mutable_ipv4_tunnel();
  public:
  void unsafe_arena_set_allocated_ipv4_tunnel(
      ::tunneloffload::v1alpha1::IPV4Pair* ipv4_tunnel);
  ::tunneloffload::v1alpha1::IPV4Pair* unsafe_arena_release_ipv4_tunnel();

  // .tunneloffload.v1alpha1.IPV6Pair ipv6_tunnel = 5;
  bool has_ipv6_tunnel() const;
  private:
  bool _internal_has_ipv6_tunnel() const;
  public:
  void clear_ipv6_tunnel();
  const ::tunneloffload::v1alpha1::IPV6Pair& ipv6_tunnel() const;
  PROTOBUF_NODISCARD ::tunneloffload::v1alpha1::IPV6Pair* release_ipv6_tunnel();
  ::tunneloffload::v1alpha1::IPV6Pair* mutable_ipv6_tunnel();
  void set_allocated_ipv6_tunnel(::tunneloffload::v1alpha1::IPV6Pair* ipv6_tunnel);
  private:
  const ::tunneloffload::v1alpha1::IPV6Pair& _internal_ipv6_tunnel() const;
  ::tunneloffload::v1alpha1::IPV6Pair* _internal_mutable_ipv6_tunnel();
  public:
  void unsafe_arena_set_allocated_ipv6_tunnel(
      ::tunneloffload::v1alpha1::IPV6Pair* ipv6_tunnel);
  ::tunneloffload::v1alpha1::IPV6Pair* unsafe_arena_release_ipv6_tunnel();

  void clear_tunnelIps();
  TunnelIpsCase tunnelIps_case() const;
  // @@protoc_insertion_point(class_scope:tunneloffload.v1alpha1.IPSecEnc)
 private:
  class _Internal;
  void set_has_ipv4_tunnel();
  void set_has_ipv6_tunnel();

  inline bool has_tunnelIps() const;
  inline void clear_has_tunnelIps();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::tunneloffload::v1alpha1::IPSecSAParams* ipsec_sa_;
  int tunnel_type_;
  int encryption_type_;
  union TunnelIpsUnion {
    constexpr TunnelIpsUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::tunneloffload::v1alpha1::IPV4Pair* ipv4_tunnel_;
    ::tunneloffload::v1alpha1::IPV6Pair* ipv6_tunnel_;
  } tunnelIps_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_tunneloffload_2eproto;
};
// -------------------------------------------------------------------

class IPSecDec final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tunneloffload.v1alpha1.IPSecDec) */ {
 public:
  inline IPSecDec() : IPSecDec(nullptr) {}
  ~IPSecDec() override;
  explicit constexpr IPSecDec(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IPSecDec(const IPSecDec& from);
  IPSecDec(IPSecDec&& from) noexcept
    : IPSecDec() {
    *this = ::std::move(from);
  }

  inline IPSecDec& operator=(const IPSecDec& from) {
    CopyFrom(from);
    return *this;
  }
  inline IPSecDec& operator=(IPSecDec&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IPSecDec& default_instance() {
    return *internal_default_instance();
  }
  static inline const IPSecDec* internal_default_instance() {
    return reinterpret_cast<const IPSecDec*>(
               &_IPSecDec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(IPSecDec& a, IPSecDec& b) {
    a.Swap(&b);
  }
  inline void Swap(IPSecDec* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IPSecDec* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IPSecDec* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IPSecDec>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IPSecDec& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const IPSecDec& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IPSecDec* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tunneloffload.v1alpha1.IPSecDec";
  }
  protected:
  explicit IPSecDec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIpsecSasFieldNumber = 3,
    kTunnelTypeFieldNumber = 1,
    kEncryptionTypeFieldNumber = 2,
  };
  // repeated .tunneloffload.v1alpha1.IPSecSAParams ipsec_sas = 3;
  int ipsec_sas_size() const;
  private:
  int _internal_ipsec_sas_size() const;
  public:
  void clear_ipsec_sas();
  ::tunneloffload::v1alpha1::IPSecSAParams* mutable_ipsec_sas(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tunneloffload::v1alpha1::IPSecSAParams >*
      mutable_ipsec_sas();
  private:
  const ::tunneloffload::v1alpha1::IPSecSAParams& _internal_ipsec_sas(int index) const;
  ::tunneloffload::v1alpha1::IPSecSAParams* _internal_add_ipsec_sas();
  public:
  const ::tunneloffload::v1alpha1::IPSecSAParams& ipsec_sas(int index) const;
  ::tunneloffload::v1alpha1::IPSecSAParams* add_ipsec_sas();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tunneloffload::v1alpha1::IPSecSAParams >&
      ipsec_sas() const;

  // .tunneloffload.v1alpha1.IPSecTunnelType tunnel_type = 1;
  void clear_tunnel_type();
  ::tunneloffload::v1alpha1::IPSecTunnelType tunnel_type() const;
  void set_tunnel_type(::tunneloffload::v1alpha1::IPSecTunnelType value);
  private:
  ::tunneloffload::v1alpha1::IPSecTunnelType _internal_tunnel_type() const;
  void _internal_set_tunnel_type(::tunneloffload::v1alpha1::IPSecTunnelType value);
  public:

  // .tunneloffload.v1alpha1.EncType encryption_type = 2;
  void clear_encryption_type();
  ::tunneloffload::v1alpha1::EncType encryption_type() const;
  void set_encryption_type(::tunneloffload::v1alpha1::EncType value);
  private:
  ::tunneloffload::v1alpha1::EncType _internal_encryption_type() const;
  void _internal_set_encryption_type(::tunneloffload::v1alpha1::EncType value);
  public:

  // @@protoc_insertion_point(class_scope:tunneloffload.v1alpha1.IPSecDec)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tunneloffload::v1alpha1::IPSecSAParams > ipsec_sas_;
  int tunnel_type_;
  int encryption_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tunneloffload_2eproto;
};
// -------------------------------------------------------------------

class IPSecSAParams final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tunneloffload.v1alpha1.IPSecSAParams) */ {
 public:
  inline IPSecSAParams() : IPSecSAParams(nullptr) {}
  ~IPSecSAParams() override;
  explicit constexpr IPSecSAParams(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IPSecSAParams(const IPSecSAParams& from);
  IPSecSAParams(IPSecSAParams&& from) noexcept
    : IPSecSAParams() {
    *this = ::std::move(from);
  }

  inline IPSecSAParams& operator=(const IPSecSAParams& from) {
    CopyFrom(from);
    return *this;
  }
  inline IPSecSAParams& operator=(IPSecSAParams&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IPSecSAParams& default_instance() {
    return *internal_default_instance();
  }
  static inline const IPSecSAParams* internal_default_instance() {
    return reinterpret_cast<const IPSecSAParams*>(
               &_IPSecSAParams_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(IPSecSAParams& a, IPSecSAParams& b) {
    a.Swap(&b);
  }
  inline void Swap(IPSecSAParams* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IPSecSAParams* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IPSecSAParams* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IPSecSAParams>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IPSecSAParams& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const IPSecSAParams& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IPSecSAParams* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tunneloffload.v1alpha1.IPSecSAParams";
  }
  protected:
  explicit IPSecSAParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEncryptionKeyFieldNumber = 2,
    kSpiFieldNumber = 1,
    kOperationFieldNumber = 3,
  };
  // bytes encryption_key = 2;
  void clear_encryption_key();
  const std::string& encryption_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_encryption_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_encryption_key();
  PROTOBUF_NODISCARD std::string* release_encryption_key();
  void set_allocated_encryption_key(std::string* encryption_key);
  private:
  const std::string& _internal_encryption_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_encryption_key(const std::string& value);
  std::string* _internal_mutable_encryption_key();
  public:

  // uint32 spi = 1;
  void clear_spi();
  uint32_t spi() const;
  void set_spi(uint32_t value);
  private:
  uint32_t _internal_spi() const;
  void _internal_set_spi(uint32_t value);
  public:

  // .tunneloffload.v1alpha1.Operation operation = 3;
  void clear_operation();
  ::tunneloffload::v1alpha1::Operation operation() const;
  void set_operation(::tunneloffload::v1alpha1::Operation value);
  private:
  ::tunneloffload::v1alpha1::Operation _internal_operation() const;
  void _internal_set_operation(::tunneloffload::v1alpha1::Operation value);
  public:

  // @@protoc_insertion_point(class_scope:tunneloffload.v1alpha1.IPSecSAParams)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr encryption_key_;
  uint32_t spi_;
  int operation_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tunneloffload_2eproto;
};
// -------------------------------------------------------------------

class IPSecTunnel final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tunneloffload.v1alpha1.IPSecTunnel) */ {
 public:
  inline IPSecTunnel() : IPSecTunnel(nullptr) {}
  ~IPSecTunnel() override;
  explicit constexpr IPSecTunnel(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IPSecTunnel(const IPSecTunnel& from);
  IPSecTunnel(IPSecTunnel&& from) noexcept
    : IPSecTunnel() {
    *this = ::std::move(from);
  }

  inline IPSecTunnel& operator=(const IPSecTunnel& from) {
    CopyFrom(from);
    return *this;
  }
  inline IPSecTunnel& operator=(IPSecTunnel&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IPSecTunnel& default_instance() {
    return *internal_default_instance();
  }
  enum IpsecCase {
    kIpsecEnc = 1,
    kIpsecDec = 2,
    IPSEC_NOT_SET = 0,
  };

  static inline const IPSecTunnel* internal_default_instance() {
    return reinterpret_cast<const IPSecTunnel*>(
               &_IPSecTunnel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(IPSecTunnel& a, IPSecTunnel& b) {
    a.Swap(&b);
  }
  inline void Swap(IPSecTunnel* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IPSecTunnel* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IPSecTunnel* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IPSecTunnel>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IPSecTunnel& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const IPSecTunnel& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IPSecTunnel* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tunneloffload.v1alpha1.IPSecTunnel";
  }
  protected:
  explicit IPSecTunnel(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIpsecEncFieldNumber = 1,
    kIpsecDecFieldNumber = 2,
  };
  // .tunneloffload.v1alpha1.IPSecEnc ipsec_enc = 1;
  bool has_ipsec_enc() const;
  private:
  bool _internal_has_ipsec_enc() const;
  public:
  void clear_ipsec_enc();
  const ::tunneloffload::v1alpha1::IPSecEnc& ipsec_enc() const;
  PROTOBUF_NODISCARD ::tunneloffload::v1alpha1::IPSecEnc* release_ipsec_enc();
  ::tunneloffload::v1alpha1::IPSecEnc* mutable_ipsec_enc();
  void set_allocated_ipsec_enc(::tunneloffload::v1alpha1::IPSecEnc* ipsec_enc);
  private:
  const ::tunneloffload::v1alpha1::IPSecEnc& _internal_ipsec_enc() const;
  ::tunneloffload::v1alpha1::IPSecEnc* _internal_mutable_ipsec_enc();
  public:
  void unsafe_arena_set_allocated_ipsec_enc(
      ::tunneloffload::v1alpha1::IPSecEnc* ipsec_enc);
  ::tunneloffload::v1alpha1::IPSecEnc* unsafe_arena_release_ipsec_enc();

  // .tunneloffload.v1alpha1.IPSecDec ipsec_dec = 2;
  bool has_ipsec_dec() const;
  private:
  bool _internal_has_ipsec_dec() const;
  public:
  void clear_ipsec_dec();
  const ::tunneloffload::v1alpha1::IPSecDec& ipsec_dec() const;
  PROTOBUF_NODISCARD ::tunneloffload::v1alpha1::IPSecDec* release_ipsec_dec();
  ::tunneloffload::v1alpha1::IPSecDec* mutable_ipsec_dec();
  void set_allocated_ipsec_dec(::tunneloffload::v1alpha1::IPSecDec* ipsec_dec);
  private:
  const ::tunneloffload::v1alpha1::IPSecDec& _internal_ipsec_dec() const;
  ::tunneloffload::v1alpha1::IPSecDec* _internal_mutable_ipsec_dec();
  public:
  void unsafe_arena_set_allocated_ipsec_dec(
      ::tunneloffload::v1alpha1::IPSecDec* ipsec_dec);
  ::tunneloffload::v1alpha1::IPSecDec* unsafe_arena_release_ipsec_dec();

  void clear_ipsec();
  IpsecCase ipsec_case() const;
  // @@protoc_insertion_point(class_scope:tunneloffload.v1alpha1.IPSecTunnel)
 private:
  class _Internal;
  void set_has_ipsec_enc();
  void set_has_ipsec_dec();

  inline bool has_ipsec() const;
  inline void clear_has_ipsec();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union IpsecUnion {
    constexpr IpsecUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::tunneloffload::v1alpha1::IPSecEnc* ipsec_enc_;
    ::tunneloffload::v1alpha1::IPSecDec* ipsec_dec_;
  } ipsec_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_tunneloffload_2eproto;
};
// -------------------------------------------------------------------

class TunnelId final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tunneloffload.v1alpha1.TunnelId) */ {
 public:
  inline TunnelId() : TunnelId(nullptr) {}
  ~TunnelId() override;
  explicit constexpr TunnelId(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TunnelId(const TunnelId& from);
  TunnelId(TunnelId&& from) noexcept
    : TunnelId() {
    *this = ::std::move(from);
  }

  inline TunnelId& operator=(const TunnelId& from) {
    CopyFrom(from);
    return *this;
  }
  inline TunnelId& operator=(TunnelId&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TunnelId& default_instance() {
    return *internal_default_instance();
  }
  static inline const TunnelId* internal_default_instance() {
    return reinterpret_cast<const TunnelId*>(
               &_TunnelId_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(TunnelId& a, TunnelId& b) {
    a.Swap(&b);
  }
  inline void Swap(TunnelId* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TunnelId* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TunnelId* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TunnelId>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TunnelId& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TunnelId& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TunnelId* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tunneloffload.v1alpha1.TunnelId";
  }
  protected:
  explicit TunnelId(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTunnelIdFieldNumber = 1,
  };
  // uint64 tunnel_id = 1;
  void clear_tunnel_id();
  uint64_t tunnel_id() const;
  void set_tunnel_id(uint64_t value);
  private:
  uint64_t _internal_tunnel_id() const;
  void _internal_set_tunnel_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:tunneloffload.v1alpha1.TunnelId)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint64_t tunnel_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tunneloffload_2eproto;
};
// -------------------------------------------------------------------

class Counters final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tunneloffload.v1alpha1.Counters) */ {
 public:
  inline Counters() : Counters(nullptr) {}
  ~Counters() override;
  explicit constexpr Counters(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Counters(const Counters& from);
  Counters(Counters&& from) noexcept
    : Counters() {
    *this = ::std::move(from);
  }

  inline Counters& operator=(const Counters& from) {
    CopyFrom(from);
    return *this;
  }
  inline Counters& operator=(Counters&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Counters& default_instance() {
    return *internal_default_instance();
  }
  static inline const Counters* internal_default_instance() {
    return reinterpret_cast<const Counters*>(
               &_Counters_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(Counters& a, Counters& b) {
    a.Swap(&b);
  }
  inline void Swap(Counters* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Counters* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Counters* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Counters>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Counters& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Counters& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Counters* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tunneloffload.v1alpha1.Counters";
  }
  protected:
  explicit Counters(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInPacketsFieldNumber = 1,
    kOutPacketsFieldNumber = 2,
    kInBytesFieldNumber = 3,
    kOutBytesFieldNumber = 4,
    kInPacketsDropsFieldNumber = 5,
    kOutPacketsDropsFieldNumber = 6,
    kInBytesDropsFieldNumber = 7,
    kOutBytesDropsFieldNumber = 8,
  };
  // uint64 in_packets = 1;
  void clear_in_packets();
  uint64_t in_packets() const;
  void set_in_packets(uint64_t value);
  private:
  uint64_t _internal_in_packets() const;
  void _internal_set_in_packets(uint64_t value);
  public:

  // uint64 out_packets = 2;
  void clear_out_packets();
  uint64_t out_packets() const;
  void set_out_packets(uint64_t value);
  private:
  uint64_t _internal_out_packets() const;
  void _internal_set_out_packets(uint64_t value);
  public:

  // uint64 in_bytes = 3;
  void clear_in_bytes();
  uint64_t in_bytes() const;
  void set_in_bytes(uint64_t value);
  private:
  uint64_t _internal_in_bytes() const;
  void _internal_set_in_bytes(uint64_t value);
  public:

  // uint64 out_bytes = 4;
  void clear_out_bytes();
  uint64_t out_bytes() const;
  void set_out_bytes(uint64_t value);
  private:
  uint64_t _internal_out_bytes() const;
  void _internal_set_out_bytes(uint64_t value);
  public:

  // uint64 in_packets_drops = 5;
  void clear_in_packets_drops();
  uint64_t in_packets_drops() const;
  void set_in_packets_drops(uint64_t value);
  private:
  uint64_t _internal_in_packets_drops() const;
  void _internal_set_in_packets_drops(uint64_t value);
  public:

  // uint64 out_packets_drops = 6;
  void clear_out_packets_drops();
  uint64_t out_packets_drops() const;
  void set_out_packets_drops(uint64_t value);
  private:
  uint64_t _internal_out_packets_drops() const;
  void _internal_set_out_packets_drops(uint64_t value);
  public:

  // uint64 in_bytes_drops = 7;
  void clear_in_bytes_drops();
  uint64_t in_bytes_drops() const;
  void set_in_bytes_drops(uint64_t value);
  private:
  uint64_t _internal_in_bytes_drops() const;
  void _internal_set_in_bytes_drops(uint64_t value);
  public:

  // uint64 out_bytes_drops = 8;
  void clear_out_bytes_drops();
  uint64_t out_bytes_drops() const;
  void set_out_bytes_drops(uint64_t value);
  private:
  uint64_t _internal_out_bytes_drops() const;
  void _internal_set_out_bytes_drops(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:tunneloffload.v1alpha1.Counters)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint64_t in_packets_;
  uint64_t out_packets_;
  uint64_t in_bytes_;
  uint64_t out_bytes_;
  uint64_t in_packets_drops_;
  uint64_t out_packets_drops_;
  uint64_t in_bytes_drops_;
  uint64_t out_bytes_drops_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tunneloffload_2eproto;
};
// -------------------------------------------------------------------

class CreateIpTunnelResponses final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tunneloffload.v1alpha1.CreateIpTunnelResponses) */ {
 public:
  inline CreateIpTunnelResponses() : CreateIpTunnelResponses(nullptr) {}
  ~CreateIpTunnelResponses() override;
  explicit constexpr CreateIpTunnelResponses(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateIpTunnelResponses(const CreateIpTunnelResponses& from);
  CreateIpTunnelResponses(CreateIpTunnelResponses&& from) noexcept
    : CreateIpTunnelResponses() {
    *this = ::std::move(from);
  }

  inline CreateIpTunnelResponses& operator=(const CreateIpTunnelResponses& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateIpTunnelResponses& operator=(CreateIpTunnelResponses&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateIpTunnelResponses& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateIpTunnelResponses* internal_default_instance() {
    return reinterpret_cast<const CreateIpTunnelResponses*>(
               &_CreateIpTunnelResponses_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(CreateIpTunnelResponses& a, CreateIpTunnelResponses& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateIpTunnelResponses* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateIpTunnelResponses* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateIpTunnelResponses* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateIpTunnelResponses>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateIpTunnelResponses& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateIpTunnelResponses& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateIpTunnelResponses* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tunneloffload.v1alpha1.CreateIpTunnelResponses";
  }
  protected:
  explicit CreateIpTunnelResponses(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponsesFieldNumber = 3,
    kErrorStatusFieldNumber = 2,
    kRequestStatusFieldNumber = 1,
  };
  // repeated .tunneloffload.v1alpha1.CreateIpTunnelResponse responses = 3;
  int responses_size() const;
  private:
  int _internal_responses_size() const;
  public:
  void clear_responses();
  ::tunneloffload::v1alpha1::CreateIpTunnelResponse* mutable_responses(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tunneloffload::v1alpha1::CreateIpTunnelResponse >*
      mutable_responses();
  private:
  const ::tunneloffload::v1alpha1::CreateIpTunnelResponse& _internal_responses(int index) const;
  ::tunneloffload::v1alpha1::CreateIpTunnelResponse* _internal_add_responses();
  public:
  const ::tunneloffload::v1alpha1::CreateIpTunnelResponse& responses(int index) const;
  ::tunneloffload::v1alpha1::CreateIpTunnelResponse* add_responses();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tunneloffload::v1alpha1::CreateIpTunnelResponse >&
      responses() const;

  // uint64 error_status = 2;
  void clear_error_status();
  uint64_t error_status() const;
  void set_error_status(uint64_t value);
  private:
  uint64_t _internal_error_status() const;
  void _internal_set_error_status(uint64_t value);
  public:

  // .tunneloffload.v1alpha1.AddTunnelStatus request_status = 1;
  void clear_request_status();
  ::tunneloffload::v1alpha1::AddTunnelStatus request_status() const;
  void set_request_status(::tunneloffload::v1alpha1::AddTunnelStatus value);
  private:
  ::tunneloffload::v1alpha1::AddTunnelStatus _internal_request_status() const;
  void _internal_set_request_status(::tunneloffload::v1alpha1::AddTunnelStatus value);
  public:

  // @@protoc_insertion_point(class_scope:tunneloffload.v1alpha1.CreateIpTunnelResponses)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tunneloffload::v1alpha1::CreateIpTunnelResponse > responses_;
  uint64_t error_status_;
  int request_status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tunneloffload_2eproto;
};
// -------------------------------------------------------------------

class CreateIpTunnelResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tunneloffload.v1alpha1.CreateIpTunnelResponse) */ {
 public:
  inline CreateIpTunnelResponse() : CreateIpTunnelResponse(nullptr) {}
  ~CreateIpTunnelResponse() override;
  explicit constexpr CreateIpTunnelResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateIpTunnelResponse(const CreateIpTunnelResponse& from);
  CreateIpTunnelResponse(CreateIpTunnelResponse&& from) noexcept
    : CreateIpTunnelResponse() {
    *this = ::std::move(from);
  }

  inline CreateIpTunnelResponse& operator=(const CreateIpTunnelResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateIpTunnelResponse& operator=(CreateIpTunnelResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateIpTunnelResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateIpTunnelResponse* internal_default_instance() {
    return reinterpret_cast<const CreateIpTunnelResponse*>(
               &_CreateIpTunnelResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(CreateIpTunnelResponse& a, CreateIpTunnelResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateIpTunnelResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateIpTunnelResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateIpTunnelResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateIpTunnelResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateIpTunnelResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateIpTunnelResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateIpTunnelResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tunneloffload.v1alpha1.CreateIpTunnelResponse";
  }
  protected:
  explicit CreateIpTunnelResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 2,
    kTunnelIdFieldNumber = 1,
  };
  // .tunneloffload.v1alpha1.Error error = 2;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::tunneloffload::v1alpha1::Error& error() const;
  PROTOBUF_NODISCARD ::tunneloffload::v1alpha1::Error* release_error();
  ::tunneloffload::v1alpha1::Error* mutable_error();
  void set_allocated_error(::tunneloffload::v1alpha1::Error* error);
  private:
  const ::tunneloffload::v1alpha1::Error& _internal_error() const;
  ::tunneloffload::v1alpha1::Error* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::tunneloffload::v1alpha1::Error* error);
  ::tunneloffload::v1alpha1::Error* unsafe_arena_release_error();

  // uint64 tunnel_id = 1;
  void clear_tunnel_id();
  uint64_t tunnel_id() const;
  void set_tunnel_id(uint64_t value);
  private:
  uint64_t _internal_tunnel_id() const;
  void _internal_set_tunnel_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:tunneloffload.v1alpha1.CreateIpTunnelResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::tunneloffload::v1alpha1::Error* error_;
  uint64_t tunnel_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tunneloffload_2eproto;
};
// -------------------------------------------------------------------

class Error final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tunneloffload.v1alpha1.Error) */ {
 public:
  inline Error() : Error(nullptr) {}
  ~Error() override;
  explicit constexpr Error(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Error(const Error& from);
  Error(Error&& from) noexcept
    : Error() {
    *this = ::std::move(from);
  }

  inline Error& operator=(const Error& from) {
    CopyFrom(from);
    return *this;
  }
  inline Error& operator=(Error&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Error& default_instance() {
    return *internal_default_instance();
  }
  static inline const Error* internal_default_instance() {
    return reinterpret_cast<const Error*>(
               &_Error_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(Error& a, Error& b) {
    a.Swap(&b);
  }
  inline void Swap(Error* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Error* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Error* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Error>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Error& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Error& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Error* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tunneloffload.v1alpha1.Error";
  }
  protected:
  explicit Error(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorStringFieldNumber = 2,
    kErrorMessageFieldNumber = 1,
  };
  // string error_string = 2;
  void clear_error_string();
  const std::string& error_string() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_string(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_string();
  PROTOBUF_NODISCARD std::string* release_error_string();
  void set_allocated_error_string(std::string* error_string);
  private:
  const std::string& _internal_error_string() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_string(const std::string& value);
  std::string* _internal_mutable_error_string();
  public:

  // .tunneloffload.v1alpha1.TunnelAdditionError error_message = 1;
  bool has_error_message() const;
  private:
  bool _internal_has_error_message() const;
  public:
  void clear_error_message();
  const ::tunneloffload::v1alpha1::TunnelAdditionError& error_message() const;
  PROTOBUF_NODISCARD ::tunneloffload::v1alpha1::TunnelAdditionError* release_error_message();
  ::tunneloffload::v1alpha1::TunnelAdditionError* mutable_error_message();
  void set_allocated_error_message(::tunneloffload::v1alpha1::TunnelAdditionError* error_message);
  private:
  const ::tunneloffload::v1alpha1::TunnelAdditionError& _internal_error_message() const;
  ::tunneloffload::v1alpha1::TunnelAdditionError* _internal_mutable_error_message();
  public:
  void unsafe_arena_set_allocated_error_message(
      ::tunneloffload::v1alpha1::TunnelAdditionError* error_message);
  ::tunneloffload::v1alpha1::TunnelAdditionError* unsafe_arena_release_error_message();

  // @@protoc_insertion_point(class_scope:tunneloffload.v1alpha1.Error)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_string_;
  ::tunneloffload::v1alpha1::TunnelAdditionError* error_message_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tunneloffload_2eproto;
};
// -------------------------------------------------------------------

class IpTunnelResponses final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tunneloffload.v1alpha1.IpTunnelResponses) */ {
 public:
  inline IpTunnelResponses() : IpTunnelResponses(nullptr) {}
  ~IpTunnelResponses() override;
  explicit constexpr IpTunnelResponses(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IpTunnelResponses(const IpTunnelResponses& from);
  IpTunnelResponses(IpTunnelResponses&& from) noexcept
    : IpTunnelResponses() {
    *this = ::std::move(from);
  }

  inline IpTunnelResponses& operator=(const IpTunnelResponses& from) {
    CopyFrom(from);
    return *this;
  }
  inline IpTunnelResponses& operator=(IpTunnelResponses&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IpTunnelResponses& default_instance() {
    return *internal_default_instance();
  }
  static inline const IpTunnelResponses* internal_default_instance() {
    return reinterpret_cast<const IpTunnelResponses*>(
               &_IpTunnelResponses_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(IpTunnelResponses& a, IpTunnelResponses& b) {
    a.Swap(&b);
  }
  inline void Swap(IpTunnelResponses* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IpTunnelResponses* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IpTunnelResponses* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IpTunnelResponses>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IpTunnelResponses& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const IpTunnelResponses& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IpTunnelResponses* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tunneloffload.v1alpha1.IpTunnelResponses";
  }
  protected:
  explicit IpTunnelResponses(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponsesFieldNumber = 1,
  };
  // repeated .tunneloffload.v1alpha1.IpTunnelResponse responses = 1;
  int responses_size() const;
  private:
  int _internal_responses_size() const;
  public:
  void clear_responses();
  ::tunneloffload::v1alpha1::IpTunnelResponse* mutable_responses(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tunneloffload::v1alpha1::IpTunnelResponse >*
      mutable_responses();
  private:
  const ::tunneloffload::v1alpha1::IpTunnelResponse& _internal_responses(int index) const;
  ::tunneloffload::v1alpha1::IpTunnelResponse* _internal_add_responses();
  public:
  const ::tunneloffload::v1alpha1::IpTunnelResponse& responses(int index) const;
  ::tunneloffload::v1alpha1::IpTunnelResponse* add_responses();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tunneloffload::v1alpha1::IpTunnelResponse >&
      responses() const;

  // @@protoc_insertion_point(class_scope:tunneloffload.v1alpha1.IpTunnelResponses)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tunneloffload::v1alpha1::IpTunnelResponse > responses_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tunneloffload_2eproto;
};
// -------------------------------------------------------------------

class IpTunnelResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tunneloffload.v1alpha1.IpTunnelResponse) */ {
 public:
  inline IpTunnelResponse() : IpTunnelResponse(nullptr) {}
  ~IpTunnelResponse() override;
  explicit constexpr IpTunnelResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IpTunnelResponse(const IpTunnelResponse& from);
  IpTunnelResponse(IpTunnelResponse&& from) noexcept
    : IpTunnelResponse() {
    *this = ::std::move(from);
  }

  inline IpTunnelResponse& operator=(const IpTunnelResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline IpTunnelResponse& operator=(IpTunnelResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IpTunnelResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const IpTunnelResponse* internal_default_instance() {
    return reinterpret_cast<const IpTunnelResponse*>(
               &_IpTunnelResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(IpTunnelResponse& a, IpTunnelResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(IpTunnelResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IpTunnelResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IpTunnelResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IpTunnelResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IpTunnelResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const IpTunnelResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IpTunnelResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tunneloffload.v1alpha1.IpTunnelResponse";
  }
  protected:
  explicit IpTunnelResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIpTunnelFieldNumber = 2,
    kTunnelCountersFieldNumber = 3,
    kErrorFieldNumber = 4,
    kTunnelIdFieldNumber = 1,
  };
  // .tunneloffload.v1alpha1.IpTunnelRequest ip_tunnel = 2;
  bool has_ip_tunnel() const;
  private:
  bool _internal_has_ip_tunnel() const;
  public:
  void clear_ip_tunnel();
  const ::tunneloffload::v1alpha1::IpTunnelRequest& ip_tunnel() const;
  PROTOBUF_NODISCARD ::tunneloffload::v1alpha1::IpTunnelRequest* release_ip_tunnel();
  ::tunneloffload::v1alpha1::IpTunnelRequest* mutable_ip_tunnel();
  void set_allocated_ip_tunnel(::tunneloffload::v1alpha1::IpTunnelRequest* ip_tunnel);
  private:
  const ::tunneloffload::v1alpha1::IpTunnelRequest& _internal_ip_tunnel() const;
  ::tunneloffload::v1alpha1::IpTunnelRequest* _internal_mutable_ip_tunnel();
  public:
  void unsafe_arena_set_allocated_ip_tunnel(
      ::tunneloffload::v1alpha1::IpTunnelRequest* ip_tunnel);
  ::tunneloffload::v1alpha1::IpTunnelRequest* unsafe_arena_release_ip_tunnel();

  // .tunneloffload.v1alpha1.Counters tunnel_counters = 3;
  bool has_tunnel_counters() const;
  private:
  bool _internal_has_tunnel_counters() const;
  public:
  void clear_tunnel_counters();
  const ::tunneloffload::v1alpha1::Counters& tunnel_counters() const;
  PROTOBUF_NODISCARD ::tunneloffload::v1alpha1::Counters* release_tunnel_counters();
  ::tunneloffload::v1alpha1::Counters* mutable_tunnel_counters();
  void set_allocated_tunnel_counters(::tunneloffload::v1alpha1::Counters* tunnel_counters);
  private:
  const ::tunneloffload::v1alpha1::Counters& _internal_tunnel_counters() const;
  ::tunneloffload::v1alpha1::Counters* _internal_mutable_tunnel_counters();
  public:
  void unsafe_arena_set_allocated_tunnel_counters(
      ::tunneloffload::v1alpha1::Counters* tunnel_counters);
  ::tunneloffload::v1alpha1::Counters* unsafe_arena_release_tunnel_counters();

  // .tunneloffload.v1alpha1.Error error = 4;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::tunneloffload::v1alpha1::Error& error() const;
  PROTOBUF_NODISCARD ::tunneloffload::v1alpha1::Error* release_error();
  ::tunneloffload::v1alpha1::Error* mutable_error();
  void set_allocated_error(::tunneloffload::v1alpha1::Error* error);
  private:
  const ::tunneloffload::v1alpha1::Error& _internal_error() const;
  ::tunneloffload::v1alpha1::Error* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::tunneloffload::v1alpha1::Error* error);
  ::tunneloffload::v1alpha1::Error* unsafe_arena_release_error();

  // uint64 tunnel_id = 1;
  void clear_tunnel_id();
  uint64_t tunnel_id() const;
  void set_tunnel_id(uint64_t value);
  private:
  uint64_t _internal_tunnel_id() const;
  void _internal_set_tunnel_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:tunneloffload.v1alpha1.IpTunnelResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::tunneloffload::v1alpha1::IpTunnelRequest* ip_tunnel_;
  ::tunneloffload::v1alpha1::Counters* tunnel_counters_;
  ::tunneloffload::v1alpha1::Error* error_;
  uint64_t tunnel_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tunneloffload_2eproto;
};
// -------------------------------------------------------------------

class IpTunnelStatsResponses final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tunneloffload.v1alpha1.IpTunnelStatsResponses) */ {
 public:
  inline IpTunnelStatsResponses() : IpTunnelStatsResponses(nullptr) {}
  ~IpTunnelStatsResponses() override;
  explicit constexpr IpTunnelStatsResponses(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IpTunnelStatsResponses(const IpTunnelStatsResponses& from);
  IpTunnelStatsResponses(IpTunnelStatsResponses&& from) noexcept
    : IpTunnelStatsResponses() {
    *this = ::std::move(from);
  }

  inline IpTunnelStatsResponses& operator=(const IpTunnelStatsResponses& from) {
    CopyFrom(from);
    return *this;
  }
  inline IpTunnelStatsResponses& operator=(IpTunnelStatsResponses&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IpTunnelStatsResponses& default_instance() {
    return *internal_default_instance();
  }
  static inline const IpTunnelStatsResponses* internal_default_instance() {
    return reinterpret_cast<const IpTunnelStatsResponses*>(
               &_IpTunnelStatsResponses_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(IpTunnelStatsResponses& a, IpTunnelStatsResponses& b) {
    a.Swap(&b);
  }
  inline void Swap(IpTunnelStatsResponses* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IpTunnelStatsResponses* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IpTunnelStatsResponses* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IpTunnelStatsResponses>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IpTunnelStatsResponses& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const IpTunnelStatsResponses& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IpTunnelStatsResponses* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tunneloffload.v1alpha1.IpTunnelStatsResponses";
  }
  protected:
  explicit IpTunnelStatsResponses(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponsesFieldNumber = 1,
  };
  // repeated .tunneloffload.v1alpha1.IpTunnelStatsResponse responses = 1;
  int responses_size() const;
  private:
  int _internal_responses_size() const;
  public:
  void clear_responses();
  ::tunneloffload::v1alpha1::IpTunnelStatsResponse* mutable_responses(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tunneloffload::v1alpha1::IpTunnelStatsResponse >*
      mutable_responses();
  private:
  const ::tunneloffload::v1alpha1::IpTunnelStatsResponse& _internal_responses(int index) const;
  ::tunneloffload::v1alpha1::IpTunnelStatsResponse* _internal_add_responses();
  public:
  const ::tunneloffload::v1alpha1::IpTunnelStatsResponse& responses(int index) const;
  ::tunneloffload::v1alpha1::IpTunnelStatsResponse* add_responses();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tunneloffload::v1alpha1::IpTunnelStatsResponse >&
      responses() const;

  // @@protoc_insertion_point(class_scope:tunneloffload.v1alpha1.IpTunnelStatsResponses)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tunneloffload::v1alpha1::IpTunnelStatsResponse > responses_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tunneloffload_2eproto;
};
// -------------------------------------------------------------------

class IpTunnelStatsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tunneloffload.v1alpha1.IpTunnelStatsResponse) */ {
 public:
  inline IpTunnelStatsResponse() : IpTunnelStatsResponse(nullptr) {}
  ~IpTunnelStatsResponse() override;
  explicit constexpr IpTunnelStatsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IpTunnelStatsResponse(const IpTunnelStatsResponse& from);
  IpTunnelStatsResponse(IpTunnelStatsResponse&& from) noexcept
    : IpTunnelStatsResponse() {
    *this = ::std::move(from);
  }

  inline IpTunnelStatsResponse& operator=(const IpTunnelStatsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline IpTunnelStatsResponse& operator=(IpTunnelStatsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IpTunnelStatsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const IpTunnelStatsResponse* internal_default_instance() {
    return reinterpret_cast<const IpTunnelStatsResponse*>(
               &_IpTunnelStatsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(IpTunnelStatsResponse& a, IpTunnelStatsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(IpTunnelStatsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IpTunnelStatsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IpTunnelStatsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IpTunnelStatsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IpTunnelStatsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const IpTunnelStatsResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IpTunnelStatsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tunneloffload.v1alpha1.IpTunnelStatsResponse";
  }
  protected:
  explicit IpTunnelStatsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTunnelCountersFieldNumber = 2,
    kErrorFieldNumber = 3,
    kTunnelIdFieldNumber = 1,
  };
  // .tunneloffload.v1alpha1.Counters tunnel_counters = 2;
  bool has_tunnel_counters() const;
  private:
  bool _internal_has_tunnel_counters() const;
  public:
  void clear_tunnel_counters();
  const ::tunneloffload::v1alpha1::Counters& tunnel_counters() const;
  PROTOBUF_NODISCARD ::tunneloffload::v1alpha1::Counters* release_tunnel_counters();
  ::tunneloffload::v1alpha1::Counters* mutable_tunnel_counters();
  void set_allocated_tunnel_counters(::tunneloffload::v1alpha1::Counters* tunnel_counters);
  private:
  const ::tunneloffload::v1alpha1::Counters& _internal_tunnel_counters() const;
  ::tunneloffload::v1alpha1::Counters* _internal_mutable_tunnel_counters();
  public:
  void unsafe_arena_set_allocated_tunnel_counters(
      ::tunneloffload::v1alpha1::Counters* tunnel_counters);
  ::tunneloffload::v1alpha1::Counters* unsafe_arena_release_tunnel_counters();

  // .tunneloffload.v1alpha1.Error error = 3;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::tunneloffload::v1alpha1::Error& error() const;
  PROTOBUF_NODISCARD ::tunneloffload::v1alpha1::Error* release_error();
  ::tunneloffload::v1alpha1::Error* mutable_error();
  void set_allocated_error(::tunneloffload::v1alpha1::Error* error);
  private:
  const ::tunneloffload::v1alpha1::Error& _internal_error() const;
  ::tunneloffload::v1alpha1::Error* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::tunneloffload::v1alpha1::Error* error);
  ::tunneloffload::v1alpha1::Error* unsafe_arena_release_error();

  // uint64 tunnel_id = 1;
  void clear_tunnel_id();
  uint64_t tunnel_id() const;
  void set_tunnel_id(uint64_t value);
  private:
  uint64_t _internal_tunnel_id() const;
  void _internal_set_tunnel_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:tunneloffload.v1alpha1.IpTunnelStatsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::tunneloffload::v1alpha1::Counters* tunnel_counters_;
  ::tunneloffload::v1alpha1::Error* error_;
  uint64_t tunnel_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tunneloffload_2eproto;
};
// -------------------------------------------------------------------

class TunnelRequestArgs final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tunneloffload.v1alpha1.TunnelRequestArgs) */ {
 public:
  inline TunnelRequestArgs() : TunnelRequestArgs(nullptr) {}
  ~TunnelRequestArgs() override;
  explicit constexpr TunnelRequestArgs(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TunnelRequestArgs(const TunnelRequestArgs& from);
  TunnelRequestArgs(TunnelRequestArgs&& from) noexcept
    : TunnelRequestArgs() {
    *this = ::std::move(from);
  }

  inline TunnelRequestArgs& operator=(const TunnelRequestArgs& from) {
    CopyFrom(from);
    return *this;
  }
  inline TunnelRequestArgs& operator=(TunnelRequestArgs&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TunnelRequestArgs& default_instance() {
    return *internal_default_instance();
  }
  static inline const TunnelRequestArgs* internal_default_instance() {
    return reinterpret_cast<const TunnelRequestArgs*>(
               &_TunnelRequestArgs_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(TunnelRequestArgs& a, TunnelRequestArgs& b) {
    a.Swap(&b);
  }
  inline void Swap(TunnelRequestArgs* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TunnelRequestArgs* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TunnelRequestArgs* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TunnelRequestArgs>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TunnelRequestArgs& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TunnelRequestArgs& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TunnelRequestArgs* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tunneloffload.v1alpha1.TunnelRequestArgs";
  }
  protected:
  explicit TunnelRequestArgs(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTunnelsPerRequestFieldNumber = 1,
  };
  // uint32 tunnels_per_request = 1;
  void clear_tunnels_per_request();
  uint32_t tunnels_per_request() const;
  void set_tunnels_per_request(uint32_t value);
  private:
  uint32_t _internal_tunnels_per_request() const;
  void _internal_set_tunnels_per_request(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:tunneloffload.v1alpha1.TunnelRequestArgs)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t tunnels_per_request_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tunneloffload_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CapabilityRequest

// -------------------------------------------------------------------

// CapabilityResponse_MatchCapabilities

// bool ingress_interface_matching = 1;
inline void CapabilityResponse_MatchCapabilities::clear_ingress_interface_matching() {
  ingress_interface_matching_ = false;
}
inline bool CapabilityResponse_MatchCapabilities::_internal_ingress_interface_matching() const {
  return ingress_interface_matching_;
}
inline bool CapabilityResponse_MatchCapabilities::ingress_interface_matching() const {
  // @@protoc_insertion_point(field_get:tunneloffload.v1alpha1.CapabilityResponse.MatchCapabilities.ingress_interface_matching)
  return _internal_ingress_interface_matching();
}
inline void CapabilityResponse_MatchCapabilities::_internal_set_ingress_interface_matching(bool value) {
  
  ingress_interface_matching_ = value;
}
inline void CapabilityResponse_MatchCapabilities::set_ingress_interface_matching(bool value) {
  _internal_set_ingress_interface_matching(value);
  // @@protoc_insertion_point(field_set:tunneloffload.v1alpha1.CapabilityResponse.MatchCapabilities.ingress_interface_matching)
}

// bool vxlan_matching = 2;
inline void CapabilityResponse_MatchCapabilities::clear_vxlan_matching() {
  vxlan_matching_ = false;
}
inline bool CapabilityResponse_MatchCapabilities::_internal_vxlan_matching() const {
  return vxlan_matching_;
}
inline bool CapabilityResponse_MatchCapabilities::vxlan_matching() const {
  // @@protoc_insertion_point(field_get:tunneloffload.v1alpha1.CapabilityResponse.MatchCapabilities.vxlan_matching)
  return _internal_vxlan_matching();
}
inline void CapabilityResponse_MatchCapabilities::_internal_set_vxlan_matching(bool value) {
  
  vxlan_matching_ = value;
}
inline void CapabilityResponse_MatchCapabilities::set_vxlan_matching(bool value) {
  _internal_set_vxlan_matching(value);
  // @@protoc_insertion_point(field_set:tunneloffload.v1alpha1.CapabilityResponse.MatchCapabilities.vxlan_matching)
}

// bool geneve_matching = 3;
inline void CapabilityResponse_MatchCapabilities::clear_geneve_matching() {
  geneve_matching_ = false;
}
inline bool CapabilityResponse_MatchCapabilities::_internal_geneve_matching() const {
  return geneve_matching_;
}
inline bool CapabilityResponse_MatchCapabilities::geneve_matching() const {
  // @@protoc_insertion_point(field_get:tunneloffload.v1alpha1.CapabilityResponse.MatchCapabilities.geneve_matching)
  return _internal_geneve_matching();
}
inline void CapabilityResponse_MatchCapabilities::_internal_set_geneve_matching(bool value) {
  
  geneve_matching_ = value;
}
inline void CapabilityResponse_MatchCapabilities::set_geneve_matching(bool value) {
  _internal_set_geneve_matching(value);
  // @@protoc_insertion_point(field_set:tunneloffload.v1alpha1.CapabilityResponse.MatchCapabilities.geneve_matching)
}

// bool tunnel_matching = 4;
inline void CapabilityResponse_MatchCapabilities::clear_tunnel_matching() {
  tunnel_matching_ = false;
}
inline bool CapabilityResponse_MatchCapabilities::_internal_tunnel_matching() const {
  return tunnel_matching_;
}
inline bool CapabilityResponse_MatchCapabilities::tunnel_matching() const {
  // @@protoc_insertion_point(field_get:tunneloffload.v1alpha1.CapabilityResponse.MatchCapabilities.tunnel_matching)
  return _internal_tunnel_matching();
}
inline void CapabilityResponse_MatchCapabilities::_internal_set_tunnel_matching(bool value) {
  
  tunnel_matching_ = value;
}
inline void CapabilityResponse_MatchCapabilities::set_tunnel_matching(bool value) {
  _internal_set_tunnel_matching(value);
  // @@protoc_insertion_point(field_set:tunneloffload.v1alpha1.CapabilityResponse.MatchCapabilities.tunnel_matching)
}

// bool spi_matching = 5;
inline void CapabilityResponse_MatchCapabilities::clear_spi_matching() {
  spi_matching_ = false;
}
inline bool CapabilityResponse_MatchCapabilities::_internal_spi_matching() const {
  return spi_matching_;
}
inline bool CapabilityResponse_MatchCapabilities::spi_matching() const {
  // @@protoc_insertion_point(field_get:tunneloffload.v1alpha1.CapabilityResponse.MatchCapabilities.spi_matching)
  return _internal_spi_matching();
}
inline void CapabilityResponse_MatchCapabilities::_internal_set_spi_matching(bool value) {
  
  spi_matching_ = value;
}
inline void CapabilityResponse_MatchCapabilities::set_spi_matching(bool value) {
  _internal_set_spi_matching(value);
  // @@protoc_insertion_point(field_set:tunneloffload.v1alpha1.CapabilityResponse.MatchCapabilities.spi_matching)
}

// -------------------------------------------------------------------

// CapabilityResponse_IPSecCapabilities

// repeated .tunneloffload.v1alpha1.IPSecTunnelType tunnel_type_supported = 1;
inline int CapabilityResponse_IPSecCapabilities::_internal_tunnel_type_supported_size() const {
  return tunnel_type_supported_.size();
}
inline int CapabilityResponse_IPSecCapabilities::tunnel_type_supported_size() const {
  return _internal_tunnel_type_supported_size();
}
inline void CapabilityResponse_IPSecCapabilities::clear_tunnel_type_supported() {
  tunnel_type_supported_.Clear();
}
inline ::tunneloffload::v1alpha1::IPSecTunnelType CapabilityResponse_IPSecCapabilities::_internal_tunnel_type_supported(int index) const {
  return static_cast< ::tunneloffload::v1alpha1::IPSecTunnelType >(tunnel_type_supported_.Get(index));
}
inline ::tunneloffload::v1alpha1::IPSecTunnelType CapabilityResponse_IPSecCapabilities::tunnel_type_supported(int index) const {
  // @@protoc_insertion_point(field_get:tunneloffload.v1alpha1.CapabilityResponse.IPSecCapabilities.tunnel_type_supported)
  return _internal_tunnel_type_supported(index);
}
inline void CapabilityResponse_IPSecCapabilities::set_tunnel_type_supported(int index, ::tunneloffload::v1alpha1::IPSecTunnelType value) {
  tunnel_type_supported_.Set(index, value);
  // @@protoc_insertion_point(field_set:tunneloffload.v1alpha1.CapabilityResponse.IPSecCapabilities.tunnel_type_supported)
}
inline void CapabilityResponse_IPSecCapabilities::_internal_add_tunnel_type_supported(::tunneloffload::v1alpha1::IPSecTunnelType value) {
  tunnel_type_supported_.Add(value);
}
inline void CapabilityResponse_IPSecCapabilities::add_tunnel_type_supported(::tunneloffload::v1alpha1::IPSecTunnelType value) {
  _internal_add_tunnel_type_supported(value);
  // @@protoc_insertion_point(field_add:tunneloffload.v1alpha1.CapabilityResponse.IPSecCapabilities.tunnel_type_supported)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
CapabilityResponse_IPSecCapabilities::tunnel_type_supported() const {
  // @@protoc_insertion_point(field_list:tunneloffload.v1alpha1.CapabilityResponse.IPSecCapabilities.tunnel_type_supported)
  return tunnel_type_supported_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
CapabilityResponse_IPSecCapabilities::_internal_mutable_tunnel_type_supported() {
  return &tunnel_type_supported_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
CapabilityResponse_IPSecCapabilities::mutable_tunnel_type_supported() {
  // @@protoc_insertion_point(field_mutable_list:tunneloffload.v1alpha1.CapabilityResponse.IPSecCapabilities.tunnel_type_supported)
  return _internal_mutable_tunnel_type_supported();
}

// repeated .tunneloffload.v1alpha1.EncType encryption_supported = 2;
inline int CapabilityResponse_IPSecCapabilities::_internal_encryption_supported_size() const {
  return encryption_supported_.size();
}
inline int CapabilityResponse_IPSecCapabilities::encryption_supported_size() const {
  return _internal_encryption_supported_size();
}
inline void CapabilityResponse_IPSecCapabilities::clear_encryption_supported() {
  encryption_supported_.Clear();
}
inline ::tunneloffload::v1alpha1::EncType CapabilityResponse_IPSecCapabilities::_internal_encryption_supported(int index) const {
  return static_cast< ::tunneloffload::v1alpha1::EncType >(encryption_supported_.Get(index));
}
inline ::tunneloffload::v1alpha1::EncType CapabilityResponse_IPSecCapabilities::encryption_supported(int index) const {
  // @@protoc_insertion_point(field_get:tunneloffload.v1alpha1.CapabilityResponse.IPSecCapabilities.encryption_supported)
  return _internal_encryption_supported(index);
}
inline void CapabilityResponse_IPSecCapabilities::set_encryption_supported(int index, ::tunneloffload::v1alpha1::EncType value) {
  encryption_supported_.Set(index, value);
  // @@protoc_insertion_point(field_set:tunneloffload.v1alpha1.CapabilityResponse.IPSecCapabilities.encryption_supported)
}
inline void CapabilityResponse_IPSecCapabilities::_internal_add_encryption_supported(::tunneloffload::v1alpha1::EncType value) {
  encryption_supported_.Add(value);
}
inline void CapabilityResponse_IPSecCapabilities::add_encryption_supported(::tunneloffload::v1alpha1::EncType value) {
  _internal_add_encryption_supported(value);
  // @@protoc_insertion_point(field_add:tunneloffload.v1alpha1.CapabilityResponse.IPSecCapabilities.encryption_supported)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
CapabilityResponse_IPSecCapabilities::encryption_supported() const {
  // @@protoc_insertion_point(field_list:tunneloffload.v1alpha1.CapabilityResponse.IPSecCapabilities.encryption_supported)
  return encryption_supported_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
CapabilityResponse_IPSecCapabilities::_internal_mutable_encryption_supported() {
  return &encryption_supported_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
CapabilityResponse_IPSecCapabilities::mutable_encryption_supported() {
  // @@protoc_insertion_point(field_mutable_list:tunneloffload.v1alpha1.CapabilityResponse.IPSecCapabilities.encryption_supported)
  return _internal_mutable_encryption_supported();
}

// -------------------------------------------------------------------

// CapabilityResponse_GeneveCapabilities

// uint32 number_geneve_options_supported = 1;
inline void CapabilityResponse_GeneveCapabilities::clear_number_geneve_options_supported() {
  number_geneve_options_supported_ = 0u;
}
inline uint32_t CapabilityResponse_GeneveCapabilities::_internal_number_geneve_options_supported() const {
  return number_geneve_options_supported_;
}
inline uint32_t CapabilityResponse_GeneveCapabilities::number_geneve_options_supported() const {
  // @@protoc_insertion_point(field_get:tunneloffload.v1alpha1.CapabilityResponse.GeneveCapabilities.number_geneve_options_supported)
  return _internal_number_geneve_options_supported();
}
inline void CapabilityResponse_GeneveCapabilities::_internal_set_number_geneve_options_supported(uint32_t value) {
  
  number_geneve_options_supported_ = value;
}
inline void CapabilityResponse_GeneveCapabilities::set_number_geneve_options_supported(uint32_t value) {
  _internal_set_number_geneve_options_supported(value);
  // @@protoc_insertion_point(field_set:tunneloffload.v1alpha1.CapabilityResponse.GeneveCapabilities.number_geneve_options_supported)
}

// -------------------------------------------------------------------

// CapabilityResponse

// .tunneloffload.v1alpha1.CapabilityResponse.MatchCapabilities match_capabilities = 1;
inline bool CapabilityResponse::_internal_has_match_capabilities() const {
  return this != internal_default_instance() && match_capabilities_ != nullptr;
}
inline bool CapabilityResponse::has_match_capabilities() const {
  return _internal_has_match_capabilities();
}
inline void CapabilityResponse::clear_match_capabilities() {
  if (GetArenaForAllocation() == nullptr && match_capabilities_ != nullptr) {
    delete match_capabilities_;
  }
  match_capabilities_ = nullptr;
}
inline const ::tunneloffload::v1alpha1::CapabilityResponse_MatchCapabilities& CapabilityResponse::_internal_match_capabilities() const {
  const ::tunneloffload::v1alpha1::CapabilityResponse_MatchCapabilities* p = match_capabilities_;
  return p != nullptr ? *p : reinterpret_cast<const ::tunneloffload::v1alpha1::CapabilityResponse_MatchCapabilities&>(
      ::tunneloffload::v1alpha1::_CapabilityResponse_MatchCapabilities_default_instance_);
}
inline const ::tunneloffload::v1alpha1::CapabilityResponse_MatchCapabilities& CapabilityResponse::match_capabilities() const {
  // @@protoc_insertion_point(field_get:tunneloffload.v1alpha1.CapabilityResponse.match_capabilities)
  return _internal_match_capabilities();
}
inline void CapabilityResponse::unsafe_arena_set_allocated_match_capabilities(
    ::tunneloffload::v1alpha1::CapabilityResponse_MatchCapabilities* match_capabilities) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(match_capabilities_);
  }
  match_capabilities_ = match_capabilities;
  if (match_capabilities) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tunneloffload.v1alpha1.CapabilityResponse.match_capabilities)
}
inline ::tunneloffload::v1alpha1::CapabilityResponse_MatchCapabilities* CapabilityResponse::release_match_capabilities() {
  
  ::tunneloffload::v1alpha1::CapabilityResponse_MatchCapabilities* temp = match_capabilities_;
  match_capabilities_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tunneloffload::v1alpha1::CapabilityResponse_MatchCapabilities* CapabilityResponse::unsafe_arena_release_match_capabilities() {
  // @@protoc_insertion_point(field_release:tunneloffload.v1alpha1.CapabilityResponse.match_capabilities)
  
  ::tunneloffload::v1alpha1::CapabilityResponse_MatchCapabilities* temp = match_capabilities_;
  match_capabilities_ = nullptr;
  return temp;
}
inline ::tunneloffload::v1alpha1::CapabilityResponse_MatchCapabilities* CapabilityResponse::_internal_mutable_match_capabilities() {
  
  if (match_capabilities_ == nullptr) {
    auto* p = CreateMaybeMessage<::tunneloffload::v1alpha1::CapabilityResponse_MatchCapabilities>(GetArenaForAllocation());
    match_capabilities_ = p;
  }
  return match_capabilities_;
}
inline ::tunneloffload::v1alpha1::CapabilityResponse_MatchCapabilities* CapabilityResponse::mutable_match_capabilities() {
  ::tunneloffload::v1alpha1::CapabilityResponse_MatchCapabilities* _msg = _internal_mutable_match_capabilities();
  // @@protoc_insertion_point(field_mutable:tunneloffload.v1alpha1.CapabilityResponse.match_capabilities)
  return _msg;
}
inline void CapabilityResponse::set_allocated_match_capabilities(::tunneloffload::v1alpha1::CapabilityResponse_MatchCapabilities* match_capabilities) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete match_capabilities_;
  }
  if (match_capabilities) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::tunneloffload::v1alpha1::CapabilityResponse_MatchCapabilities>::GetOwningArena(match_capabilities);
    if (message_arena != submessage_arena) {
      match_capabilities = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, match_capabilities, submessage_arena);
    }
    
  } else {
    
  }
  match_capabilities_ = match_capabilities;
  // @@protoc_insertion_point(field_set_allocated:tunneloffload.v1alpha1.CapabilityResponse.match_capabilities)
}

// .tunneloffload.v1alpha1.CapabilityResponse.IPSecCapabilities ipsec_capabilities = 2;
inline bool CapabilityResponse::_internal_has_ipsec_capabilities() const {
  return this != internal_default_instance() && ipsec_capabilities_ != nullptr;
}
inline bool CapabilityResponse::has_ipsec_capabilities() const {
  return _internal_has_ipsec_capabilities();
}
inline void CapabilityResponse::clear_ipsec_capabilities() {
  if (GetArenaForAllocation() == nullptr && ipsec_capabilities_ != nullptr) {
    delete ipsec_capabilities_;
  }
  ipsec_capabilities_ = nullptr;
}
inline const ::tunneloffload::v1alpha1::CapabilityResponse_IPSecCapabilities& CapabilityResponse::_internal_ipsec_capabilities() const {
  const ::tunneloffload::v1alpha1::CapabilityResponse_IPSecCapabilities* p = ipsec_capabilities_;
  return p != nullptr ? *p : reinterpret_cast<const ::tunneloffload::v1alpha1::CapabilityResponse_IPSecCapabilities&>(
      ::tunneloffload::v1alpha1::_CapabilityResponse_IPSecCapabilities_default_instance_);
}
inline const ::tunneloffload::v1alpha1::CapabilityResponse_IPSecCapabilities& CapabilityResponse::ipsec_capabilities() const {
  // @@protoc_insertion_point(field_get:tunneloffload.v1alpha1.CapabilityResponse.ipsec_capabilities)
  return _internal_ipsec_capabilities();
}
inline void CapabilityResponse::unsafe_arena_set_allocated_ipsec_capabilities(
    ::tunneloffload::v1alpha1::CapabilityResponse_IPSecCapabilities* ipsec_capabilities) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ipsec_capabilities_);
  }
  ipsec_capabilities_ = ipsec_capabilities;
  if (ipsec_capabilities) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tunneloffload.v1alpha1.CapabilityResponse.ipsec_capabilities)
}
inline ::tunneloffload::v1alpha1::CapabilityResponse_IPSecCapabilities* CapabilityResponse::release_ipsec_capabilities() {
  
  ::tunneloffload::v1alpha1::CapabilityResponse_IPSecCapabilities* temp = ipsec_capabilities_;
  ipsec_capabilities_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tunneloffload::v1alpha1::CapabilityResponse_IPSecCapabilities* CapabilityResponse::unsafe_arena_release_ipsec_capabilities() {
  // @@protoc_insertion_point(field_release:tunneloffload.v1alpha1.CapabilityResponse.ipsec_capabilities)
  
  ::tunneloffload::v1alpha1::CapabilityResponse_IPSecCapabilities* temp = ipsec_capabilities_;
  ipsec_capabilities_ = nullptr;
  return temp;
}
inline ::tunneloffload::v1alpha1::CapabilityResponse_IPSecCapabilities* CapabilityResponse::_internal_mutable_ipsec_capabilities() {
  
  if (ipsec_capabilities_ == nullptr) {
    auto* p = CreateMaybeMessage<::tunneloffload::v1alpha1::CapabilityResponse_IPSecCapabilities>(GetArenaForAllocation());
    ipsec_capabilities_ = p;
  }
  return ipsec_capabilities_;
}
inline ::tunneloffload::v1alpha1::CapabilityResponse_IPSecCapabilities* CapabilityResponse::mutable_ipsec_capabilities() {
  ::tunneloffload::v1alpha1::CapabilityResponse_IPSecCapabilities* _msg = _internal_mutable_ipsec_capabilities();
  // @@protoc_insertion_point(field_mutable:tunneloffload.v1alpha1.CapabilityResponse.ipsec_capabilities)
  return _msg;
}
inline void CapabilityResponse::set_allocated_ipsec_capabilities(::tunneloffload::v1alpha1::CapabilityResponse_IPSecCapabilities* ipsec_capabilities) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete ipsec_capabilities_;
  }
  if (ipsec_capabilities) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::tunneloffload::v1alpha1::CapabilityResponse_IPSecCapabilities>::GetOwningArena(ipsec_capabilities);
    if (message_arena != submessage_arena) {
      ipsec_capabilities = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ipsec_capabilities, submessage_arena);
    }
    
  } else {
    
  }
  ipsec_capabilities_ = ipsec_capabilities;
  // @@protoc_insertion_point(field_set_allocated:tunneloffload.v1alpha1.CapabilityResponse.ipsec_capabilities)
}

// .tunneloffload.v1alpha1.CapabilityResponse.GeneveCapabilities geneve_capabilities = 3;
inline bool CapabilityResponse::_internal_has_geneve_capabilities() const {
  return this != internal_default_instance() && geneve_capabilities_ != nullptr;
}
inline bool CapabilityResponse::has_geneve_capabilities() const {
  return _internal_has_geneve_capabilities();
}
inline void CapabilityResponse::clear_geneve_capabilities() {
  if (GetArenaForAllocation() == nullptr && geneve_capabilities_ != nullptr) {
    delete geneve_capabilities_;
  }
  geneve_capabilities_ = nullptr;
}
inline const ::tunneloffload::v1alpha1::CapabilityResponse_GeneveCapabilities& CapabilityResponse::_internal_geneve_capabilities() const {
  const ::tunneloffload::v1alpha1::CapabilityResponse_GeneveCapabilities* p = geneve_capabilities_;
  return p != nullptr ? *p : reinterpret_cast<const ::tunneloffload::v1alpha1::CapabilityResponse_GeneveCapabilities&>(
      ::tunneloffload::v1alpha1::_CapabilityResponse_GeneveCapabilities_default_instance_);
}
inline const ::tunneloffload::v1alpha1::CapabilityResponse_GeneveCapabilities& CapabilityResponse::geneve_capabilities() const {
  // @@protoc_insertion_point(field_get:tunneloffload.v1alpha1.CapabilityResponse.geneve_capabilities)
  return _internal_geneve_capabilities();
}
inline void CapabilityResponse::unsafe_arena_set_allocated_geneve_capabilities(
    ::tunneloffload::v1alpha1::CapabilityResponse_GeneveCapabilities* geneve_capabilities) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(geneve_capabilities_);
  }
  geneve_capabilities_ = geneve_capabilities;
  if (geneve_capabilities) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tunneloffload.v1alpha1.CapabilityResponse.geneve_capabilities)
}
inline ::tunneloffload::v1alpha1::CapabilityResponse_GeneveCapabilities* CapabilityResponse::release_geneve_capabilities() {
  
  ::tunneloffload::v1alpha1::CapabilityResponse_GeneveCapabilities* temp = geneve_capabilities_;
  geneve_capabilities_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tunneloffload::v1alpha1::CapabilityResponse_GeneveCapabilities* CapabilityResponse::unsafe_arena_release_geneve_capabilities() {
  // @@protoc_insertion_point(field_release:tunneloffload.v1alpha1.CapabilityResponse.geneve_capabilities)
  
  ::tunneloffload::v1alpha1::CapabilityResponse_GeneveCapabilities* temp = geneve_capabilities_;
  geneve_capabilities_ = nullptr;
  return temp;
}
inline ::tunneloffload::v1alpha1::CapabilityResponse_GeneveCapabilities* CapabilityResponse::_internal_mutable_geneve_capabilities() {
  
  if (geneve_capabilities_ == nullptr) {
    auto* p = CreateMaybeMessage<::tunneloffload::v1alpha1::CapabilityResponse_GeneveCapabilities>(GetArenaForAllocation());
    geneve_capabilities_ = p;
  }
  return geneve_capabilities_;
}
inline ::tunneloffload::v1alpha1::CapabilityResponse_GeneveCapabilities* CapabilityResponse::mutable_geneve_capabilities() {
  ::tunneloffload::v1alpha1::CapabilityResponse_GeneveCapabilities* _msg = _internal_mutable_geneve_capabilities();
  // @@protoc_insertion_point(field_mutable:tunneloffload.v1alpha1.CapabilityResponse.geneve_capabilities)
  return _msg;
}
inline void CapabilityResponse::set_allocated_geneve_capabilities(::tunneloffload::v1alpha1::CapabilityResponse_GeneveCapabilities* geneve_capabilities) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete geneve_capabilities_;
  }
  if (geneve_capabilities) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::tunneloffload::v1alpha1::CapabilityResponse_GeneveCapabilities>::GetOwningArena(geneve_capabilities);
    if (message_arena != submessage_arena) {
      geneve_capabilities = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, geneve_capabilities, submessage_arena);
    }
    
  } else {
    
  }
  geneve_capabilities_ = geneve_capabilities;
  // @@protoc_insertion_point(field_set_allocated:tunneloffload.v1alpha1.CapabilityResponse.geneve_capabilities)
}

// -------------------------------------------------------------------

// TunnelAdditionError

// .tunneloffload.v1alpha1.MatchError match_error = 1;
inline void TunnelAdditionError::clear_match_error() {
  match_error_ = 0;
}
inline ::tunneloffload::v1alpha1::MatchError TunnelAdditionError::_internal_match_error() const {
  return static_cast< ::tunneloffload::v1alpha1::MatchError >(match_error_);
}
inline ::tunneloffload::v1alpha1::MatchError TunnelAdditionError::match_error() const {
  // @@protoc_insertion_point(field_get:tunneloffload.v1alpha1.TunnelAdditionError.match_error)
  return _internal_match_error();
}
inline void TunnelAdditionError::_internal_set_match_error(::tunneloffload::v1alpha1::MatchError value) {
  
  match_error_ = value;
}
inline void TunnelAdditionError::set_match_error(::tunneloffload::v1alpha1::MatchError value) {
  _internal_set_match_error(value);
  // @@protoc_insertion_point(field_set:tunneloffload.v1alpha1.TunnelAdditionError.match_error)
}

// .tunneloffload.v1alpha1.TunnelError tunnel_error = 2;
inline void TunnelAdditionError::clear_tunnel_error() {
  tunnel_error_ = 0;
}
inline ::tunneloffload::v1alpha1::TunnelError TunnelAdditionError::_internal_tunnel_error() const {
  return static_cast< ::tunneloffload::v1alpha1::TunnelError >(tunnel_error_);
}
inline ::tunneloffload::v1alpha1::TunnelError TunnelAdditionError::tunnel_error() const {
  // @@protoc_insertion_point(field_get:tunneloffload.v1alpha1.TunnelAdditionError.tunnel_error)
  return _internal_tunnel_error();
}
inline void TunnelAdditionError::_internal_set_tunnel_error(::tunneloffload::v1alpha1::TunnelError value) {
  
  tunnel_error_ = value;
}
inline void TunnelAdditionError::set_tunnel_error(::tunneloffload::v1alpha1::TunnelError value) {
  _internal_set_tunnel_error(value);
  // @@protoc_insertion_point(field_set:tunneloffload.v1alpha1.TunnelAdditionError.tunnel_error)
}

// .tunneloffload.v1alpha1.IPSecError ipsec_error = 3;
inline void TunnelAdditionError::clear_ipsec_error() {
  ipsec_error_ = 0;
}
inline ::tunneloffload::v1alpha1::IPSecError TunnelAdditionError::_internal_ipsec_error() const {
  return static_cast< ::tunneloffload::v1alpha1::IPSecError >(ipsec_error_);
}
inline ::tunneloffload::v1alpha1::IPSecError TunnelAdditionError::ipsec_error() const {
  // @@protoc_insertion_point(field_get:tunneloffload.v1alpha1.TunnelAdditionError.ipsec_error)
  return _internal_ipsec_error();
}
inline void TunnelAdditionError::_internal_set_ipsec_error(::tunneloffload::v1alpha1::IPSecError value) {
  
  ipsec_error_ = value;
}
inline void TunnelAdditionError::set_ipsec_error(::tunneloffload::v1alpha1::IPSecError value) {
  _internal_set_ipsec_error(value);
  // @@protoc_insertion_point(field_set:tunneloffload.v1alpha1.TunnelAdditionError.ipsec_error)
}

// .tunneloffload.v1alpha1.GeneveError geneve_error = 4;
inline void TunnelAdditionError::clear_geneve_error() {
  geneve_error_ = 0;
}
inline ::tunneloffload::v1alpha1::GeneveError TunnelAdditionError::_internal_geneve_error() const {
  return static_cast< ::tunneloffload::v1alpha1::GeneveError >(geneve_error_);
}
inline ::tunneloffload::v1alpha1::GeneveError TunnelAdditionError::geneve_error() const {
  // @@protoc_insertion_point(field_get:tunneloffload.v1alpha1.TunnelAdditionError.geneve_error)
  return _internal_geneve_error();
}
inline void TunnelAdditionError::_internal_set_geneve_error(::tunneloffload::v1alpha1::GeneveError value) {
  
  geneve_error_ = value;
}
inline void TunnelAdditionError::set_geneve_error(::tunneloffload::v1alpha1::GeneveError value) {
  _internal_set_geneve_error(value);
  // @@protoc_insertion_point(field_set:tunneloffload.v1alpha1.TunnelAdditionError.geneve_error)
}

// -------------------------------------------------------------------

// MatchCriteria_IPSecMatch

// uint32 spi = 1;
inline void MatchCriteria_IPSecMatch::clear_spi() {
  spi_ = 0u;
}
inline uint32_t MatchCriteria_IPSecMatch::_internal_spi() const {
  return spi_;
}
inline uint32_t MatchCriteria_IPSecMatch::spi() const {
  // @@protoc_insertion_point(field_get:tunneloffload.v1alpha1.MatchCriteria.IPSecMatch.spi)
  return _internal_spi();
}
inline void MatchCriteria_IPSecMatch::_internal_set_spi(uint32_t value) {
  
  spi_ = value;
}
inline void MatchCriteria_IPSecMatch::set_spi(uint32_t value) {
  _internal_set_spi(value);
  // @@protoc_insertion_point(field_set:tunneloffload.v1alpha1.MatchCriteria.IPSecMatch.spi)
}

// uint32 sn = 2;
inline void MatchCriteria_IPSecMatch::clear_sn() {
  sn_ = 0u;
}
inline uint32_t MatchCriteria_IPSecMatch::_internal_sn() const {
  return sn_;
}
inline uint32_t MatchCriteria_IPSecMatch::sn() const {
  // @@protoc_insertion_point(field_get:tunneloffload.v1alpha1.MatchCriteria.IPSecMatch.sn)
  return _internal_sn();
}
inline void MatchCriteria_IPSecMatch::_internal_set_sn(uint32_t value) {
  
  sn_ = value;
}
inline void MatchCriteria_IPSecMatch::set_sn(uint32_t value) {
  _internal_set_sn(value);
  // @@protoc_insertion_point(field_set:tunneloffload.v1alpha1.MatchCriteria.IPSecMatch.sn)
}

// -------------------------------------------------------------------

// MatchCriteria_GeneveMatch

// uint32 vni = 1;
inline void MatchCriteria_GeneveMatch::clear_vni() {
  vni_ = 0u;
}
inline uint32_t MatchCriteria_GeneveMatch::_internal_vni() const {
  return vni_;
}
inline uint32_t MatchCriteria_GeneveMatch::vni() const {
  // @@protoc_insertion_point(field_get:tunneloffload.v1alpha1.MatchCriteria.GeneveMatch.vni)
  return _internal_vni();
}
inline void MatchCriteria_GeneveMatch::_internal_set_vni(uint32_t value) {
  
  vni_ = value;
}
inline void MatchCriteria_GeneveMatch::set_vni(uint32_t value) {
  _internal_set_vni(value);
  // @@protoc_insertion_point(field_set:tunneloffload.v1alpha1.MatchCriteria.GeneveMatch.vni)
}

// .tunneloffload.v1alpha1.MacPair mac_match = 2;
inline bool MatchCriteria_GeneveMatch::_internal_has_mac_match() const {
  return this != internal_default_instance() && mac_match_ != nullptr;
}
inline bool MatchCriteria_GeneveMatch::has_mac_match() const {
  return _internal_has_mac_match();
}
inline void MatchCriteria_GeneveMatch::clear_mac_match() {
  if (GetArenaForAllocation() == nullptr && mac_match_ != nullptr) {
    delete mac_match_;
  }
  mac_match_ = nullptr;
}
inline const ::tunneloffload::v1alpha1::MacPair& MatchCriteria_GeneveMatch::_internal_mac_match() const {
  const ::tunneloffload::v1alpha1::MacPair* p = mac_match_;
  return p != nullptr ? *p : reinterpret_cast<const ::tunneloffload::v1alpha1::MacPair&>(
      ::tunneloffload::v1alpha1::_MacPair_default_instance_);
}
inline const ::tunneloffload::v1alpha1::MacPair& MatchCriteria_GeneveMatch::mac_match() const {
  // @@protoc_insertion_point(field_get:tunneloffload.v1alpha1.MatchCriteria.GeneveMatch.mac_match)
  return _internal_mac_match();
}
inline void MatchCriteria_GeneveMatch::unsafe_arena_set_allocated_mac_match(
    ::tunneloffload::v1alpha1::MacPair* mac_match) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(mac_match_);
  }
  mac_match_ = mac_match;
  if (mac_match) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tunneloffload.v1alpha1.MatchCriteria.GeneveMatch.mac_match)
}
inline ::tunneloffload::v1alpha1::MacPair* MatchCriteria_GeneveMatch::release_mac_match() {
  
  ::tunneloffload::v1alpha1::MacPair* temp = mac_match_;
  mac_match_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tunneloffload::v1alpha1::MacPair* MatchCriteria_GeneveMatch::unsafe_arena_release_mac_match() {
  // @@protoc_insertion_point(field_release:tunneloffload.v1alpha1.MatchCriteria.GeneveMatch.mac_match)
  
  ::tunneloffload::v1alpha1::MacPair* temp = mac_match_;
  mac_match_ = nullptr;
  return temp;
}
inline ::tunneloffload::v1alpha1::MacPair* MatchCriteria_GeneveMatch::_internal_mutable_mac_match() {
  
  if (mac_match_ == nullptr) {
    auto* p = CreateMaybeMessage<::tunneloffload::v1alpha1::MacPair>(GetArenaForAllocation());
    mac_match_ = p;
  }
  return mac_match_;
}
inline ::tunneloffload::v1alpha1::MacPair* MatchCriteria_GeneveMatch::mutable_mac_match() {
  ::tunneloffload::v1alpha1::MacPair* _msg = _internal_mutable_mac_match();
  // @@protoc_insertion_point(field_mutable:tunneloffload.v1alpha1.MatchCriteria.GeneveMatch.mac_match)
  return _msg;
}
inline void MatchCriteria_GeneveMatch::set_allocated_mac_match(::tunneloffload::v1alpha1::MacPair* mac_match) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete mac_match_;
  }
  if (mac_match) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::tunneloffload::v1alpha1::MacPair>::GetOwningArena(mac_match);
    if (message_arena != submessage_arena) {
      mac_match = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mac_match, submessage_arena);
    }
    
  } else {
    
  }
  mac_match_ = mac_match;
  // @@protoc_insertion_point(field_set_allocated:tunneloffload.v1alpha1.MatchCriteria.GeneveMatch.mac_match)
}

// uint32 protocol_type = 3;
inline void MatchCriteria_GeneveMatch::clear_protocol_type() {
  protocol_type_ = 0u;
}
inline uint32_t MatchCriteria_GeneveMatch::_internal_protocol_type() const {
  return protocol_type_;
}
inline uint32_t MatchCriteria_GeneveMatch::protocol_type() const {
  // @@protoc_insertion_point(field_get:tunneloffload.v1alpha1.MatchCriteria.GeneveMatch.protocol_type)
  return _internal_protocol_type();
}
inline void MatchCriteria_GeneveMatch::_internal_set_protocol_type(uint32_t value) {
  
  protocol_type_ = value;
}
inline void MatchCriteria_GeneveMatch::set_protocol_type(uint32_t value) {
  _internal_set_protocol_type(value);
  // @@protoc_insertion_point(field_set:tunneloffload.v1alpha1.MatchCriteria.GeneveMatch.protocol_type)
}

// .tunneloffload.v1alpha1.IPV4Match ipv4_match = 4;
inline bool MatchCriteria_GeneveMatch::_internal_has_ipv4_match() const {
  return ip_match_case() == kIpv4Match;
}
inline bool MatchCriteria_GeneveMatch::has_ipv4_match() const {
  return _internal_has_ipv4_match();
}
inline void MatchCriteria_GeneveMatch::set_has_ipv4_match() {
  _oneof_case_[0] = kIpv4Match;
}
inline void MatchCriteria_GeneveMatch::clear_ipv4_match() {
  if (_internal_has_ipv4_match()) {
    if (GetArenaForAllocation() == nullptr) {
      delete ip_match_.ipv4_match_;
    }
    clear_has_ip_match();
  }
}
inline ::tunneloffload::v1alpha1::IPV4Match* MatchCriteria_GeneveMatch::release_ipv4_match() {
  // @@protoc_insertion_point(field_release:tunneloffload.v1alpha1.MatchCriteria.GeneveMatch.ipv4_match)
  if (_internal_has_ipv4_match()) {
    clear_has_ip_match();
      ::tunneloffload::v1alpha1::IPV4Match* temp = ip_match_.ipv4_match_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    ip_match_.ipv4_match_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tunneloffload::v1alpha1::IPV4Match& MatchCriteria_GeneveMatch::_internal_ipv4_match() const {
  return _internal_has_ipv4_match()
      ? *ip_match_.ipv4_match_
      : reinterpret_cast< ::tunneloffload::v1alpha1::IPV4Match&>(::tunneloffload::v1alpha1::_IPV4Match_default_instance_);
}
inline const ::tunneloffload::v1alpha1::IPV4Match& MatchCriteria_GeneveMatch::ipv4_match() const {
  // @@protoc_insertion_point(field_get:tunneloffload.v1alpha1.MatchCriteria.GeneveMatch.ipv4_match)
  return _internal_ipv4_match();
}
inline ::tunneloffload::v1alpha1::IPV4Match* MatchCriteria_GeneveMatch::unsafe_arena_release_ipv4_match() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tunneloffload.v1alpha1.MatchCriteria.GeneveMatch.ipv4_match)
  if (_internal_has_ipv4_match()) {
    clear_has_ip_match();
    ::tunneloffload::v1alpha1::IPV4Match* temp = ip_match_.ipv4_match_;
    ip_match_.ipv4_match_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MatchCriteria_GeneveMatch::unsafe_arena_set_allocated_ipv4_match(::tunneloffload::v1alpha1::IPV4Match* ipv4_match) {
  clear_ip_match();
  if (ipv4_match) {
    set_has_ipv4_match();
    ip_match_.ipv4_match_ = ipv4_match;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tunneloffload.v1alpha1.MatchCriteria.GeneveMatch.ipv4_match)
}
inline ::tunneloffload::v1alpha1::IPV4Match* MatchCriteria_GeneveMatch::_internal_mutable_ipv4_match() {
  if (!_internal_has_ipv4_match()) {
    clear_ip_match();
    set_has_ipv4_match();
    ip_match_.ipv4_match_ = CreateMaybeMessage< ::tunneloffload::v1alpha1::IPV4Match >(GetArenaForAllocation());
  }
  return ip_match_.ipv4_match_;
}
inline ::tunneloffload::v1alpha1::IPV4Match* MatchCriteria_GeneveMatch::mutable_ipv4_match() {
  ::tunneloffload::v1alpha1::IPV4Match* _msg = _internal_mutable_ipv4_match();
  // @@protoc_insertion_point(field_mutable:tunneloffload.v1alpha1.MatchCriteria.GeneveMatch.ipv4_match)
  return _msg;
}

// .tunneloffload.v1alpha1.IPV6Match ipv6_match = 5;
inline bool MatchCriteria_GeneveMatch::_internal_has_ipv6_match() const {
  return ip_match_case() == kIpv6Match;
}
inline bool MatchCriteria_GeneveMatch::has_ipv6_match() const {
  return _internal_has_ipv6_match();
}
inline void MatchCriteria_GeneveMatch::set_has_ipv6_match() {
  _oneof_case_[0] = kIpv6Match;
}
inline void MatchCriteria_GeneveMatch::clear_ipv6_match() {
  if (_internal_has_ipv6_match()) {
    if (GetArenaForAllocation() == nullptr) {
      delete ip_match_.ipv6_match_;
    }
    clear_has_ip_match();
  }
}
inline ::tunneloffload::v1alpha1::IPV6Match* MatchCriteria_GeneveMatch::release_ipv6_match() {
  // @@protoc_insertion_point(field_release:tunneloffload.v1alpha1.MatchCriteria.GeneveMatch.ipv6_match)
  if (_internal_has_ipv6_match()) {
    clear_has_ip_match();
      ::tunneloffload::v1alpha1::IPV6Match* temp = ip_match_.ipv6_match_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    ip_match_.ipv6_match_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tunneloffload::v1alpha1::IPV6Match& MatchCriteria_GeneveMatch::_internal_ipv6_match() const {
  return _internal_has_ipv6_match()
      ? *ip_match_.ipv6_match_
      : reinterpret_cast< ::tunneloffload::v1alpha1::IPV6Match&>(::tunneloffload::v1alpha1::_IPV6Match_default_instance_);
}
inline const ::tunneloffload::v1alpha1::IPV6Match& MatchCriteria_GeneveMatch::ipv6_match() const {
  // @@protoc_insertion_point(field_get:tunneloffload.v1alpha1.MatchCriteria.GeneveMatch.ipv6_match)
  return _internal_ipv6_match();
}
inline ::tunneloffload::v1alpha1::IPV6Match* MatchCriteria_GeneveMatch::unsafe_arena_release_ipv6_match() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tunneloffload.v1alpha1.MatchCriteria.GeneveMatch.ipv6_match)
  if (_internal_has_ipv6_match()) {
    clear_has_ip_match();
    ::tunneloffload::v1alpha1::IPV6Match* temp = ip_match_.ipv6_match_;
    ip_match_.ipv6_match_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MatchCriteria_GeneveMatch::unsafe_arena_set_allocated_ipv6_match(::tunneloffload::v1alpha1::IPV6Match* ipv6_match) {
  clear_ip_match();
  if (ipv6_match) {
    set_has_ipv6_match();
    ip_match_.ipv6_match_ = ipv6_match;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tunneloffload.v1alpha1.MatchCriteria.GeneveMatch.ipv6_match)
}
inline ::tunneloffload::v1alpha1::IPV6Match* MatchCriteria_GeneveMatch::_internal_mutable_ipv6_match() {
  if (!_internal_has_ipv6_match()) {
    clear_ip_match();
    set_has_ipv6_match();
    ip_match_.ipv6_match_ = CreateMaybeMessage< ::tunneloffload::v1alpha1::IPV6Match >(GetArenaForAllocation());
  }
  return ip_match_.ipv6_match_;
}
inline ::tunneloffload::v1alpha1::IPV6Match* MatchCriteria_GeneveMatch::mutable_ipv6_match() {
  ::tunneloffload::v1alpha1::IPV6Match* _msg = _internal_mutable_ipv6_match();
  // @@protoc_insertion_point(field_mutable:tunneloffload.v1alpha1.MatchCriteria.GeneveMatch.ipv6_match)
  return _msg;
}

inline bool MatchCriteria_GeneveMatch::has_ip_match() const {
  return ip_match_case() != IP_MATCH_NOT_SET;
}
inline void MatchCriteria_GeneveMatch::clear_has_ip_match() {
  _oneof_case_[0] = IP_MATCH_NOT_SET;
}
inline MatchCriteria_GeneveMatch::IpMatchCase MatchCriteria_GeneveMatch::ip_match_case() const {
  return MatchCriteria_GeneveMatch::IpMatchCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// MatchCriteria_VXLanMatch

// uint32 vni = 1;
inline void MatchCriteria_VXLanMatch::clear_vni() {
  vni_ = 0u;
}
inline uint32_t MatchCriteria_VXLanMatch::_internal_vni() const {
  return vni_;
}
inline uint32_t MatchCriteria_VXLanMatch::vni() const {
  // @@protoc_insertion_point(field_get:tunneloffload.v1alpha1.MatchCriteria.VXLanMatch.vni)
  return _internal_vni();
}
inline void MatchCriteria_VXLanMatch::_internal_set_vni(uint32_t value) {
  
  vni_ = value;
}
inline void MatchCriteria_VXLanMatch::set_vni(uint32_t value) {
  _internal_set_vni(value);
  // @@protoc_insertion_point(field_set:tunneloffload.v1alpha1.MatchCriteria.VXLanMatch.vni)
}

// .tunneloffload.v1alpha1.MacPair mac_match = 2;
inline bool MatchCriteria_VXLanMatch::_internal_has_mac_match() const {
  return this != internal_default_instance() && mac_match_ != nullptr;
}
inline bool MatchCriteria_VXLanMatch::has_mac_match() const {
  return _internal_has_mac_match();
}
inline void MatchCriteria_VXLanMatch::clear_mac_match() {
  if (GetArenaForAllocation() == nullptr && mac_match_ != nullptr) {
    delete mac_match_;
  }
  mac_match_ = nullptr;
}
inline const ::tunneloffload::v1alpha1::MacPair& MatchCriteria_VXLanMatch::_internal_mac_match() const {
  const ::tunneloffload::v1alpha1::MacPair* p = mac_match_;
  return p != nullptr ? *p : reinterpret_cast<const ::tunneloffload::v1alpha1::MacPair&>(
      ::tunneloffload::v1alpha1::_MacPair_default_instance_);
}
inline const ::tunneloffload::v1alpha1::MacPair& MatchCriteria_VXLanMatch::mac_match() const {
  // @@protoc_insertion_point(field_get:tunneloffload.v1alpha1.MatchCriteria.VXLanMatch.mac_match)
  return _internal_mac_match();
}
inline void MatchCriteria_VXLanMatch::unsafe_arena_set_allocated_mac_match(
    ::tunneloffload::v1alpha1::MacPair* mac_match) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(mac_match_);
  }
  mac_match_ = mac_match;
  if (mac_match) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tunneloffload.v1alpha1.MatchCriteria.VXLanMatch.mac_match)
}
inline ::tunneloffload::v1alpha1::MacPair* MatchCriteria_VXLanMatch::release_mac_match() {
  
  ::tunneloffload::v1alpha1::MacPair* temp = mac_match_;
  mac_match_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tunneloffload::v1alpha1::MacPair* MatchCriteria_VXLanMatch::unsafe_arena_release_mac_match() {
  // @@protoc_insertion_point(field_release:tunneloffload.v1alpha1.MatchCriteria.VXLanMatch.mac_match)
  
  ::tunneloffload::v1alpha1::MacPair* temp = mac_match_;
  mac_match_ = nullptr;
  return temp;
}
inline ::tunneloffload::v1alpha1::MacPair* MatchCriteria_VXLanMatch::_internal_mutable_mac_match() {
  
  if (mac_match_ == nullptr) {
    auto* p = CreateMaybeMessage<::tunneloffload::v1alpha1::MacPair>(GetArenaForAllocation());
    mac_match_ = p;
  }
  return mac_match_;
}
inline ::tunneloffload::v1alpha1::MacPair* MatchCriteria_VXLanMatch::mutable_mac_match() {
  ::tunneloffload::v1alpha1::MacPair* _msg = _internal_mutable_mac_match();
  // @@protoc_insertion_point(field_mutable:tunneloffload.v1alpha1.MatchCriteria.VXLanMatch.mac_match)
  return _msg;
}
inline void MatchCriteria_VXLanMatch::set_allocated_mac_match(::tunneloffload::v1alpha1::MacPair* mac_match) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete mac_match_;
  }
  if (mac_match) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::tunneloffload::v1alpha1::MacPair>::GetOwningArena(mac_match);
    if (message_arena != submessage_arena) {
      mac_match = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mac_match, submessage_arena);
    }
    
  } else {
    
  }
  mac_match_ = mac_match;
  // @@protoc_insertion_point(field_set_allocated:tunneloffload.v1alpha1.MatchCriteria.VXLanMatch.mac_match)
}

// .tunneloffload.v1alpha1.IPV4Match ipv4_match = 3;
inline bool MatchCriteria_VXLanMatch::_internal_has_ipv4_match() const {
  return ip_match_case() == kIpv4Match;
}
inline bool MatchCriteria_VXLanMatch::has_ipv4_match() const {
  return _internal_has_ipv4_match();
}
inline void MatchCriteria_VXLanMatch::set_has_ipv4_match() {
  _oneof_case_[0] = kIpv4Match;
}
inline void MatchCriteria_VXLanMatch::clear_ipv4_match() {
  if (_internal_has_ipv4_match()) {
    if (GetArenaForAllocation() == nullptr) {
      delete ip_match_.ipv4_match_;
    }
    clear_has_ip_match();
  }
}
inline ::tunneloffload::v1alpha1::IPV4Match* MatchCriteria_VXLanMatch::release_ipv4_match() {
  // @@protoc_insertion_point(field_release:tunneloffload.v1alpha1.MatchCriteria.VXLanMatch.ipv4_match)
  if (_internal_has_ipv4_match()) {
    clear_has_ip_match();
      ::tunneloffload::v1alpha1::IPV4Match* temp = ip_match_.ipv4_match_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    ip_match_.ipv4_match_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tunneloffload::v1alpha1::IPV4Match& MatchCriteria_VXLanMatch::_internal_ipv4_match() const {
  return _internal_has_ipv4_match()
      ? *ip_match_.ipv4_match_
      : reinterpret_cast< ::tunneloffload::v1alpha1::IPV4Match&>(::tunneloffload::v1alpha1::_IPV4Match_default_instance_);
}
inline const ::tunneloffload::v1alpha1::IPV4Match& MatchCriteria_VXLanMatch::ipv4_match() const {
  // @@protoc_insertion_point(field_get:tunneloffload.v1alpha1.MatchCriteria.VXLanMatch.ipv4_match)
  return _internal_ipv4_match();
}
inline ::tunneloffload::v1alpha1::IPV4Match* MatchCriteria_VXLanMatch::unsafe_arena_release_ipv4_match() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tunneloffload.v1alpha1.MatchCriteria.VXLanMatch.ipv4_match)
  if (_internal_has_ipv4_match()) {
    clear_has_ip_match();
    ::tunneloffload::v1alpha1::IPV4Match* temp = ip_match_.ipv4_match_;
    ip_match_.ipv4_match_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MatchCriteria_VXLanMatch::unsafe_arena_set_allocated_ipv4_match(::tunneloffload::v1alpha1::IPV4Match* ipv4_match) {
  clear_ip_match();
  if (ipv4_match) {
    set_has_ipv4_match();
    ip_match_.ipv4_match_ = ipv4_match;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tunneloffload.v1alpha1.MatchCriteria.VXLanMatch.ipv4_match)
}
inline ::tunneloffload::v1alpha1::IPV4Match* MatchCriteria_VXLanMatch::_internal_mutable_ipv4_match() {
  if (!_internal_has_ipv4_match()) {
    clear_ip_match();
    set_has_ipv4_match();
    ip_match_.ipv4_match_ = CreateMaybeMessage< ::tunneloffload::v1alpha1::IPV4Match >(GetArenaForAllocation());
  }
  return ip_match_.ipv4_match_;
}
inline ::tunneloffload::v1alpha1::IPV4Match* MatchCriteria_VXLanMatch::mutable_ipv4_match() {
  ::tunneloffload::v1alpha1::IPV4Match* _msg = _internal_mutable_ipv4_match();
  // @@protoc_insertion_point(field_mutable:tunneloffload.v1alpha1.MatchCriteria.VXLanMatch.ipv4_match)
  return _msg;
}

// .tunneloffload.v1alpha1.IPV6Match ipv6_match = 4;
inline bool MatchCriteria_VXLanMatch::_internal_has_ipv6_match() const {
  return ip_match_case() == kIpv6Match;
}
inline bool MatchCriteria_VXLanMatch::has_ipv6_match() const {
  return _internal_has_ipv6_match();
}
inline void MatchCriteria_VXLanMatch::set_has_ipv6_match() {
  _oneof_case_[0] = kIpv6Match;
}
inline void MatchCriteria_VXLanMatch::clear_ipv6_match() {
  if (_internal_has_ipv6_match()) {
    if (GetArenaForAllocation() == nullptr) {
      delete ip_match_.ipv6_match_;
    }
    clear_has_ip_match();
  }
}
inline ::tunneloffload::v1alpha1::IPV6Match* MatchCriteria_VXLanMatch::release_ipv6_match() {
  // @@protoc_insertion_point(field_release:tunneloffload.v1alpha1.MatchCriteria.VXLanMatch.ipv6_match)
  if (_internal_has_ipv6_match()) {
    clear_has_ip_match();
      ::tunneloffload::v1alpha1::IPV6Match* temp = ip_match_.ipv6_match_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    ip_match_.ipv6_match_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tunneloffload::v1alpha1::IPV6Match& MatchCriteria_VXLanMatch::_internal_ipv6_match() const {
  return _internal_has_ipv6_match()
      ? *ip_match_.ipv6_match_
      : reinterpret_cast< ::tunneloffload::v1alpha1::IPV6Match&>(::tunneloffload::v1alpha1::_IPV6Match_default_instance_);
}
inline const ::tunneloffload::v1alpha1::IPV6Match& MatchCriteria_VXLanMatch::ipv6_match() const {
  // @@protoc_insertion_point(field_get:tunneloffload.v1alpha1.MatchCriteria.VXLanMatch.ipv6_match)
  return _internal_ipv6_match();
}
inline ::tunneloffload::v1alpha1::IPV6Match* MatchCriteria_VXLanMatch::unsafe_arena_release_ipv6_match() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tunneloffload.v1alpha1.MatchCriteria.VXLanMatch.ipv6_match)
  if (_internal_has_ipv6_match()) {
    clear_has_ip_match();
    ::tunneloffload::v1alpha1::IPV6Match* temp = ip_match_.ipv6_match_;
    ip_match_.ipv6_match_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MatchCriteria_VXLanMatch::unsafe_arena_set_allocated_ipv6_match(::tunneloffload::v1alpha1::IPV6Match* ipv6_match) {
  clear_ip_match();
  if (ipv6_match) {
    set_has_ipv6_match();
    ip_match_.ipv6_match_ = ipv6_match;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tunneloffload.v1alpha1.MatchCriteria.VXLanMatch.ipv6_match)
}
inline ::tunneloffload::v1alpha1::IPV6Match* MatchCriteria_VXLanMatch::_internal_mutable_ipv6_match() {
  if (!_internal_has_ipv6_match()) {
    clear_ip_match();
    set_has_ipv6_match();
    ip_match_.ipv6_match_ = CreateMaybeMessage< ::tunneloffload::v1alpha1::IPV6Match >(GetArenaForAllocation());
  }
  return ip_match_.ipv6_match_;
}
inline ::tunneloffload::v1alpha1::IPV6Match* MatchCriteria_VXLanMatch::mutable_ipv6_match() {
  ::tunneloffload::v1alpha1::IPV6Match* _msg = _internal_mutable_ipv6_match();
  // @@protoc_insertion_point(field_mutable:tunneloffload.v1alpha1.MatchCriteria.VXLanMatch.ipv6_match)
  return _msg;
}

inline bool MatchCriteria_VXLanMatch::has_ip_match() const {
  return ip_match_case() != IP_MATCH_NOT_SET;
}
inline void MatchCriteria_VXLanMatch::clear_has_ip_match() {
  _oneof_case_[0] = IP_MATCH_NOT_SET;
}
inline MatchCriteria_VXLanMatch::IpMatchCase MatchCriteria_VXLanMatch::ip_match_case() const {
  return MatchCriteria_VXLanMatch::IpMatchCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// MatchCriteria

// string ingress_interface = 1;
inline void MatchCriteria::clear_ingress_interface() {
  ingress_interface_.ClearToEmpty();
}
inline const std::string& MatchCriteria::ingress_interface() const {
  // @@protoc_insertion_point(field_get:tunneloffload.v1alpha1.MatchCriteria.ingress_interface)
  return _internal_ingress_interface();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MatchCriteria::set_ingress_interface(ArgT0&& arg0, ArgT... args) {
 
 ingress_interface_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tunneloffload.v1alpha1.MatchCriteria.ingress_interface)
}
inline std::string* MatchCriteria::mutable_ingress_interface() {
  std::string* _s = _internal_mutable_ingress_interface();
  // @@protoc_insertion_point(field_mutable:tunneloffload.v1alpha1.MatchCriteria.ingress_interface)
  return _s;
}
inline const std::string& MatchCriteria::_internal_ingress_interface() const {
  return ingress_interface_.Get();
}
inline void MatchCriteria::_internal_set_ingress_interface(const std::string& value) {
  
  ingress_interface_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MatchCriteria::_internal_mutable_ingress_interface() {
  
  return ingress_interface_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MatchCriteria::release_ingress_interface() {
  // @@protoc_insertion_point(field_release:tunneloffload.v1alpha1.MatchCriteria.ingress_interface)
  return ingress_interface_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MatchCriteria::set_allocated_ingress_interface(std::string* ingress_interface) {
  if (ingress_interface != nullptr) {
    
  } else {
    
  }
  ingress_interface_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ingress_interface,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ingress_interface_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ingress_interface_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tunneloffload.v1alpha1.MatchCriteria.ingress_interface)
}

// .tunneloffload.v1alpha1.MacPair mac_match = 2;
inline bool MatchCriteria::_internal_has_mac_match() const {
  return this != internal_default_instance() && mac_match_ != nullptr;
}
inline bool MatchCriteria::has_mac_match() const {
  return _internal_has_mac_match();
}
inline void MatchCriteria::clear_mac_match() {
  if (GetArenaForAllocation() == nullptr && mac_match_ != nullptr) {
    delete mac_match_;
  }
  mac_match_ = nullptr;
}
inline const ::tunneloffload::v1alpha1::MacPair& MatchCriteria::_internal_mac_match() const {
  const ::tunneloffload::v1alpha1::MacPair* p = mac_match_;
  return p != nullptr ? *p : reinterpret_cast<const ::tunneloffload::v1alpha1::MacPair&>(
      ::tunneloffload::v1alpha1::_MacPair_default_instance_);
}
inline const ::tunneloffload::v1alpha1::MacPair& MatchCriteria::mac_match() const {
  // @@protoc_insertion_point(field_get:tunneloffload.v1alpha1.MatchCriteria.mac_match)
  return _internal_mac_match();
}
inline void MatchCriteria::unsafe_arena_set_allocated_mac_match(
    ::tunneloffload::v1alpha1::MacPair* mac_match) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(mac_match_);
  }
  mac_match_ = mac_match;
  if (mac_match) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tunneloffload.v1alpha1.MatchCriteria.mac_match)
}
inline ::tunneloffload::v1alpha1::MacPair* MatchCriteria::release_mac_match() {
  
  ::tunneloffload::v1alpha1::MacPair* temp = mac_match_;
  mac_match_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tunneloffload::v1alpha1::MacPair* MatchCriteria::unsafe_arena_release_mac_match() {
  // @@protoc_insertion_point(field_release:tunneloffload.v1alpha1.MatchCriteria.mac_match)
  
  ::tunneloffload::v1alpha1::MacPair* temp = mac_match_;
  mac_match_ = nullptr;
  return temp;
}
inline ::tunneloffload::v1alpha1::MacPair* MatchCriteria::_internal_mutable_mac_match() {
  
  if (mac_match_ == nullptr) {
    auto* p = CreateMaybeMessage<::tunneloffload::v1alpha1::MacPair>(GetArenaForAllocation());
    mac_match_ = p;
  }
  return mac_match_;
}
inline ::tunneloffload::v1alpha1::MacPair* MatchCriteria::mutable_mac_match() {
  ::tunneloffload::v1alpha1::MacPair* _msg = _internal_mutable_mac_match();
  // @@protoc_insertion_point(field_mutable:tunneloffload.v1alpha1.MatchCriteria.mac_match)
  return _msg;
}
inline void MatchCriteria::set_allocated_mac_match(::tunneloffload::v1alpha1::MacPair* mac_match) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete mac_match_;
  }
  if (mac_match) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::tunneloffload::v1alpha1::MacPair>::GetOwningArena(mac_match);
    if (message_arena != submessage_arena) {
      mac_match = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mac_match, submessage_arena);
    }
    
  } else {
    
  }
  mac_match_ = mac_match;
  // @@protoc_insertion_point(field_set_allocated:tunneloffload.v1alpha1.MatchCriteria.mac_match)
}

// .tunneloffload.v1alpha1.IPV4Match ipv4_match = 3;
inline bool MatchCriteria::_internal_has_ipv4_match() const {
  return ip_match_case() == kIpv4Match;
}
inline bool MatchCriteria::has_ipv4_match() const {
  return _internal_has_ipv4_match();
}
inline void MatchCriteria::set_has_ipv4_match() {
  _oneof_case_[0] = kIpv4Match;
}
inline void MatchCriteria::clear_ipv4_match() {
  if (_internal_has_ipv4_match()) {
    if (GetArenaForAllocation() == nullptr) {
      delete ip_match_.ipv4_match_;
    }
    clear_has_ip_match();
  }
}
inline ::tunneloffload::v1alpha1::IPV4Match* MatchCriteria::release_ipv4_match() {
  // @@protoc_insertion_point(field_release:tunneloffload.v1alpha1.MatchCriteria.ipv4_match)
  if (_internal_has_ipv4_match()) {
    clear_has_ip_match();
      ::tunneloffload::v1alpha1::IPV4Match* temp = ip_match_.ipv4_match_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    ip_match_.ipv4_match_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tunneloffload::v1alpha1::IPV4Match& MatchCriteria::_internal_ipv4_match() const {
  return _internal_has_ipv4_match()
      ? *ip_match_.ipv4_match_
      : reinterpret_cast< ::tunneloffload::v1alpha1::IPV4Match&>(::tunneloffload::v1alpha1::_IPV4Match_default_instance_);
}
inline const ::tunneloffload::v1alpha1::IPV4Match& MatchCriteria::ipv4_match() const {
  // @@protoc_insertion_point(field_get:tunneloffload.v1alpha1.MatchCriteria.ipv4_match)
  return _internal_ipv4_match();
}
inline ::tunneloffload::v1alpha1::IPV4Match* MatchCriteria::unsafe_arena_release_ipv4_match() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tunneloffload.v1alpha1.MatchCriteria.ipv4_match)
  if (_internal_has_ipv4_match()) {
    clear_has_ip_match();
    ::tunneloffload::v1alpha1::IPV4Match* temp = ip_match_.ipv4_match_;
    ip_match_.ipv4_match_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MatchCriteria::unsafe_arena_set_allocated_ipv4_match(::tunneloffload::v1alpha1::IPV4Match* ipv4_match) {
  clear_ip_match();
  if (ipv4_match) {
    set_has_ipv4_match();
    ip_match_.ipv4_match_ = ipv4_match;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tunneloffload.v1alpha1.MatchCriteria.ipv4_match)
}
inline ::tunneloffload::v1alpha1::IPV4Match* MatchCriteria::_internal_mutable_ipv4_match() {
  if (!_internal_has_ipv4_match()) {
    clear_ip_match();
    set_has_ipv4_match();
    ip_match_.ipv4_match_ = CreateMaybeMessage< ::tunneloffload::v1alpha1::IPV4Match >(GetArenaForAllocation());
  }
  return ip_match_.ipv4_match_;
}
inline ::tunneloffload::v1alpha1::IPV4Match* MatchCriteria::mutable_ipv4_match() {
  ::tunneloffload::v1alpha1::IPV4Match* _msg = _internal_mutable_ipv4_match();
  // @@protoc_insertion_point(field_mutable:tunneloffload.v1alpha1.MatchCriteria.ipv4_match)
  return _msg;
}

// .tunneloffload.v1alpha1.IPV6Match ipv6_match = 4;
inline bool MatchCriteria::_internal_has_ipv6_match() const {
  return ip_match_case() == kIpv6Match;
}
inline bool MatchCriteria::has_ipv6_match() const {
  return _internal_has_ipv6_match();
}
inline void MatchCriteria::set_has_ipv6_match() {
  _oneof_case_[0] = kIpv6Match;
}
inline void MatchCriteria::clear_ipv6_match() {
  if (_internal_has_ipv6_match()) {
    if (GetArenaForAllocation() == nullptr) {
      delete ip_match_.ipv6_match_;
    }
    clear_has_ip_match();
  }
}
inline ::tunneloffload::v1alpha1::IPV6Match* MatchCriteria::release_ipv6_match() {
  // @@protoc_insertion_point(field_release:tunneloffload.v1alpha1.MatchCriteria.ipv6_match)
  if (_internal_has_ipv6_match()) {
    clear_has_ip_match();
      ::tunneloffload::v1alpha1::IPV6Match* temp = ip_match_.ipv6_match_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    ip_match_.ipv6_match_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tunneloffload::v1alpha1::IPV6Match& MatchCriteria::_internal_ipv6_match() const {
  return _internal_has_ipv6_match()
      ? *ip_match_.ipv6_match_
      : reinterpret_cast< ::tunneloffload::v1alpha1::IPV6Match&>(::tunneloffload::v1alpha1::_IPV6Match_default_instance_);
}
inline const ::tunneloffload::v1alpha1::IPV6Match& MatchCriteria::ipv6_match() const {
  // @@protoc_insertion_point(field_get:tunneloffload.v1alpha1.MatchCriteria.ipv6_match)
  return _internal_ipv6_match();
}
inline ::tunneloffload::v1alpha1::IPV6Match* MatchCriteria::unsafe_arena_release_ipv6_match() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tunneloffload.v1alpha1.MatchCriteria.ipv6_match)
  if (_internal_has_ipv6_match()) {
    clear_has_ip_match();
    ::tunneloffload::v1alpha1::IPV6Match* temp = ip_match_.ipv6_match_;
    ip_match_.ipv6_match_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MatchCriteria::unsafe_arena_set_allocated_ipv6_match(::tunneloffload::v1alpha1::IPV6Match* ipv6_match) {
  clear_ip_match();
  if (ipv6_match) {
    set_has_ipv6_match();
    ip_match_.ipv6_match_ = ipv6_match;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tunneloffload.v1alpha1.MatchCriteria.ipv6_match)
}
inline ::tunneloffload::v1alpha1::IPV6Match* MatchCriteria::_internal_mutable_ipv6_match() {
  if (!_internal_has_ipv6_match()) {
    clear_ip_match();
    set_has_ipv6_match();
    ip_match_.ipv6_match_ = CreateMaybeMessage< ::tunneloffload::v1alpha1::IPV6Match >(GetArenaForAllocation());
  }
  return ip_match_.ipv6_match_;
}
inline ::tunneloffload::v1alpha1::IPV6Match* MatchCriteria::mutable_ipv6_match() {
  ::tunneloffload::v1alpha1::IPV6Match* _msg = _internal_mutable_ipv6_match();
  // @@protoc_insertion_point(field_mutable:tunneloffload.v1alpha1.MatchCriteria.ipv6_match)
  return _msg;
}

// uint64 tunnel_id = 5;
inline void MatchCriteria::clear_tunnel_id() {
  tunnel_id_ = uint64_t{0u};
}
inline uint64_t MatchCriteria::_internal_tunnel_id() const {
  return tunnel_id_;
}
inline uint64_t MatchCriteria::tunnel_id() const {
  // @@protoc_insertion_point(field_get:tunneloffload.v1alpha1.MatchCriteria.tunnel_id)
  return _internal_tunnel_id();
}
inline void MatchCriteria::_internal_set_tunnel_id(uint64_t value) {
  
  tunnel_id_ = value;
}
inline void MatchCriteria::set_tunnel_id(uint64_t value) {
  _internal_set_tunnel_id(value);
  // @@protoc_insertion_point(field_set:tunneloffload.v1alpha1.MatchCriteria.tunnel_id)
}

// .tunneloffload.v1alpha1.MatchCriteria.IPSecMatch ipsec_match = 6;
inline bool MatchCriteria::_internal_has_ipsec_match() const {
  return match_case() == kIpsecMatch;
}
inline bool MatchCriteria::has_ipsec_match() const {
  return _internal_has_ipsec_match();
}
inline void MatchCriteria::set_has_ipsec_match() {
  _oneof_case_[1] = kIpsecMatch;
}
inline void MatchCriteria::clear_ipsec_match() {
  if (_internal_has_ipsec_match()) {
    if (GetArenaForAllocation() == nullptr) {
      delete match_.ipsec_match_;
    }
    clear_has_match();
  }
}
inline ::tunneloffload::v1alpha1::MatchCriteria_IPSecMatch* MatchCriteria::release_ipsec_match() {
  // @@protoc_insertion_point(field_release:tunneloffload.v1alpha1.MatchCriteria.ipsec_match)
  if (_internal_has_ipsec_match()) {
    clear_has_match();
      ::tunneloffload::v1alpha1::MatchCriteria_IPSecMatch* temp = match_.ipsec_match_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    match_.ipsec_match_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tunneloffload::v1alpha1::MatchCriteria_IPSecMatch& MatchCriteria::_internal_ipsec_match() const {
  return _internal_has_ipsec_match()
      ? *match_.ipsec_match_
      : reinterpret_cast< ::tunneloffload::v1alpha1::MatchCriteria_IPSecMatch&>(::tunneloffload::v1alpha1::_MatchCriteria_IPSecMatch_default_instance_);
}
inline const ::tunneloffload::v1alpha1::MatchCriteria_IPSecMatch& MatchCriteria::ipsec_match() const {
  // @@protoc_insertion_point(field_get:tunneloffload.v1alpha1.MatchCriteria.ipsec_match)
  return _internal_ipsec_match();
}
inline ::tunneloffload::v1alpha1::MatchCriteria_IPSecMatch* MatchCriteria::unsafe_arena_release_ipsec_match() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tunneloffload.v1alpha1.MatchCriteria.ipsec_match)
  if (_internal_has_ipsec_match()) {
    clear_has_match();
    ::tunneloffload::v1alpha1::MatchCriteria_IPSecMatch* temp = match_.ipsec_match_;
    match_.ipsec_match_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MatchCriteria::unsafe_arena_set_allocated_ipsec_match(::tunneloffload::v1alpha1::MatchCriteria_IPSecMatch* ipsec_match) {
  clear_match();
  if (ipsec_match) {
    set_has_ipsec_match();
    match_.ipsec_match_ = ipsec_match;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tunneloffload.v1alpha1.MatchCriteria.ipsec_match)
}
inline ::tunneloffload::v1alpha1::MatchCriteria_IPSecMatch* MatchCriteria::_internal_mutable_ipsec_match() {
  if (!_internal_has_ipsec_match()) {
    clear_match();
    set_has_ipsec_match();
    match_.ipsec_match_ = CreateMaybeMessage< ::tunneloffload::v1alpha1::MatchCriteria_IPSecMatch >(GetArenaForAllocation());
  }
  return match_.ipsec_match_;
}
inline ::tunneloffload::v1alpha1::MatchCriteria_IPSecMatch* MatchCriteria::mutable_ipsec_match() {
  ::tunneloffload::v1alpha1::MatchCriteria_IPSecMatch* _msg = _internal_mutable_ipsec_match();
  // @@protoc_insertion_point(field_mutable:tunneloffload.v1alpha1.MatchCriteria.ipsec_match)
  return _msg;
}

// .tunneloffload.v1alpha1.MatchCriteria.GeneveMatch geneve_match = 7;
inline bool MatchCriteria::_internal_has_geneve_match() const {
  return match_case() == kGeneveMatch;
}
inline bool MatchCriteria::has_geneve_match() const {
  return _internal_has_geneve_match();
}
inline void MatchCriteria::set_has_geneve_match() {
  _oneof_case_[1] = kGeneveMatch;
}
inline void MatchCriteria::clear_geneve_match() {
  if (_internal_has_geneve_match()) {
    if (GetArenaForAllocation() == nullptr) {
      delete match_.geneve_match_;
    }
    clear_has_match();
  }
}
inline ::tunneloffload::v1alpha1::MatchCriteria_GeneveMatch* MatchCriteria::release_geneve_match() {
  // @@protoc_insertion_point(field_release:tunneloffload.v1alpha1.MatchCriteria.geneve_match)
  if (_internal_has_geneve_match()) {
    clear_has_match();
      ::tunneloffload::v1alpha1::MatchCriteria_GeneveMatch* temp = match_.geneve_match_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    match_.geneve_match_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tunneloffload::v1alpha1::MatchCriteria_GeneveMatch& MatchCriteria::_internal_geneve_match() const {
  return _internal_has_geneve_match()
      ? *match_.geneve_match_
      : reinterpret_cast< ::tunneloffload::v1alpha1::MatchCriteria_GeneveMatch&>(::tunneloffload::v1alpha1::_MatchCriteria_GeneveMatch_default_instance_);
}
inline const ::tunneloffload::v1alpha1::MatchCriteria_GeneveMatch& MatchCriteria::geneve_match() const {
  // @@protoc_insertion_point(field_get:tunneloffload.v1alpha1.MatchCriteria.geneve_match)
  return _internal_geneve_match();
}
inline ::tunneloffload::v1alpha1::MatchCriteria_GeneveMatch* MatchCriteria::unsafe_arena_release_geneve_match() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tunneloffload.v1alpha1.MatchCriteria.geneve_match)
  if (_internal_has_geneve_match()) {
    clear_has_match();
    ::tunneloffload::v1alpha1::MatchCriteria_GeneveMatch* temp = match_.geneve_match_;
    match_.geneve_match_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MatchCriteria::unsafe_arena_set_allocated_geneve_match(::tunneloffload::v1alpha1::MatchCriteria_GeneveMatch* geneve_match) {
  clear_match();
  if (geneve_match) {
    set_has_geneve_match();
    match_.geneve_match_ = geneve_match;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tunneloffload.v1alpha1.MatchCriteria.geneve_match)
}
inline ::tunneloffload::v1alpha1::MatchCriteria_GeneveMatch* MatchCriteria::_internal_mutable_geneve_match() {
  if (!_internal_has_geneve_match()) {
    clear_match();
    set_has_geneve_match();
    match_.geneve_match_ = CreateMaybeMessage< ::tunneloffload::v1alpha1::MatchCriteria_GeneveMatch >(GetArenaForAllocation());
  }
  return match_.geneve_match_;
}
inline ::tunneloffload::v1alpha1::MatchCriteria_GeneveMatch* MatchCriteria::mutable_geneve_match() {
  ::tunneloffload::v1alpha1::MatchCriteria_GeneveMatch* _msg = _internal_mutable_geneve_match();
  // @@protoc_insertion_point(field_mutable:tunneloffload.v1alpha1.MatchCriteria.geneve_match)
  return _msg;
}

// .tunneloffload.v1alpha1.MatchCriteria.VXLanMatch vxlan_match = 8;
inline bool MatchCriteria::_internal_has_vxlan_match() const {
  return match_case() == kVxlanMatch;
}
inline bool MatchCriteria::has_vxlan_match() const {
  return _internal_has_vxlan_match();
}
inline void MatchCriteria::set_has_vxlan_match() {
  _oneof_case_[1] = kVxlanMatch;
}
inline void MatchCriteria::clear_vxlan_match() {
  if (_internal_has_vxlan_match()) {
    if (GetArenaForAllocation() == nullptr) {
      delete match_.vxlan_match_;
    }
    clear_has_match();
  }
}
inline ::tunneloffload::v1alpha1::MatchCriteria_VXLanMatch* MatchCriteria::release_vxlan_match() {
  // @@protoc_insertion_point(field_release:tunneloffload.v1alpha1.MatchCriteria.vxlan_match)
  if (_internal_has_vxlan_match()) {
    clear_has_match();
      ::tunneloffload::v1alpha1::MatchCriteria_VXLanMatch* temp = match_.vxlan_match_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    match_.vxlan_match_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tunneloffload::v1alpha1::MatchCriteria_VXLanMatch& MatchCriteria::_internal_vxlan_match() const {
  return _internal_has_vxlan_match()
      ? *match_.vxlan_match_
      : reinterpret_cast< ::tunneloffload::v1alpha1::MatchCriteria_VXLanMatch&>(::tunneloffload::v1alpha1::_MatchCriteria_VXLanMatch_default_instance_);
}
inline const ::tunneloffload::v1alpha1::MatchCriteria_VXLanMatch& MatchCriteria::vxlan_match() const {
  // @@protoc_insertion_point(field_get:tunneloffload.v1alpha1.MatchCriteria.vxlan_match)
  return _internal_vxlan_match();
}
inline ::tunneloffload::v1alpha1::MatchCriteria_VXLanMatch* MatchCriteria::unsafe_arena_release_vxlan_match() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tunneloffload.v1alpha1.MatchCriteria.vxlan_match)
  if (_internal_has_vxlan_match()) {
    clear_has_match();
    ::tunneloffload::v1alpha1::MatchCriteria_VXLanMatch* temp = match_.vxlan_match_;
    match_.vxlan_match_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MatchCriteria::unsafe_arena_set_allocated_vxlan_match(::tunneloffload::v1alpha1::MatchCriteria_VXLanMatch* vxlan_match) {
  clear_match();
  if (vxlan_match) {
    set_has_vxlan_match();
    match_.vxlan_match_ = vxlan_match;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tunneloffload.v1alpha1.MatchCriteria.vxlan_match)
}
inline ::tunneloffload::v1alpha1::MatchCriteria_VXLanMatch* MatchCriteria::_internal_mutable_vxlan_match() {
  if (!_internal_has_vxlan_match()) {
    clear_match();
    set_has_vxlan_match();
    match_.vxlan_match_ = CreateMaybeMessage< ::tunneloffload::v1alpha1::MatchCriteria_VXLanMatch >(GetArenaForAllocation());
  }
  return match_.vxlan_match_;
}
inline ::tunneloffload::v1alpha1::MatchCriteria_VXLanMatch* MatchCriteria::mutable_vxlan_match() {
  ::tunneloffload::v1alpha1::MatchCriteria_VXLanMatch* _msg = _internal_mutable_vxlan_match();
  // @@protoc_insertion_point(field_mutable:tunneloffload.v1alpha1.MatchCriteria.vxlan_match)
  return _msg;
}

inline bool MatchCriteria::has_ip_match() const {
  return ip_match_case() != IP_MATCH_NOT_SET;
}
inline void MatchCriteria::clear_has_ip_match() {
  _oneof_case_[0] = IP_MATCH_NOT_SET;
}
inline bool MatchCriteria::has_match() const {
  return match_case() != MATCH_NOT_SET;
}
inline void MatchCriteria::clear_has_match() {
  _oneof_case_[1] = MATCH_NOT_SET;
}
inline MatchCriteria::IpMatchCase MatchCriteria::ip_match_case() const {
  return MatchCriteria::IpMatchCase(_oneof_case_[0]);
}
inline MatchCriteria::MatchCase MatchCriteria::match_case() const {
  return MatchCriteria::MatchCase(_oneof_case_[1]);
}
// -------------------------------------------------------------------

// IpTunnelRequest

// uint64 tunnel_id = 1;
inline void IpTunnelRequest::clear_tunnel_id() {
  tunnel_id_ = uint64_t{0u};
}
inline uint64_t IpTunnelRequest::_internal_tunnel_id() const {
  return tunnel_id_;
}
inline uint64_t IpTunnelRequest::tunnel_id() const {
  // @@protoc_insertion_point(field_get:tunneloffload.v1alpha1.IpTunnelRequest.tunnel_id)
  return _internal_tunnel_id();
}
inline void IpTunnelRequest::_internal_set_tunnel_id(uint64_t value) {
  
  tunnel_id_ = value;
}
inline void IpTunnelRequest::set_tunnel_id(uint64_t value) {
  _internal_set_tunnel_id(value);
  // @@protoc_insertion_point(field_set:tunneloffload.v1alpha1.IpTunnelRequest.tunnel_id)
}

// .tunneloffload.v1alpha1.Operation operation = 2;
inline void IpTunnelRequest::clear_operation() {
  operation_ = 0;
}
inline ::tunneloffload::v1alpha1::Operation IpTunnelRequest::_internal_operation() const {
  return static_cast< ::tunneloffload::v1alpha1::Operation >(operation_);
}
inline ::tunneloffload::v1alpha1::Operation IpTunnelRequest::operation() const {
  // @@protoc_insertion_point(field_get:tunneloffload.v1alpha1.IpTunnelRequest.operation)
  return _internal_operation();
}
inline void IpTunnelRequest::_internal_set_operation(::tunneloffload::v1alpha1::Operation value) {
  
  operation_ = value;
}
inline void IpTunnelRequest::set_operation(::tunneloffload::v1alpha1::Operation value) {
  _internal_set_operation(value);
  // @@protoc_insertion_point(field_set:tunneloffload.v1alpha1.IpTunnelRequest.operation)
}

// .tunneloffload.v1alpha1.MatchCriteria match_criteria = 3;
inline bool IpTunnelRequest::_internal_has_match_criteria() const {
  return this != internal_default_instance() && match_criteria_ != nullptr;
}
inline bool IpTunnelRequest::has_match_criteria() const {
  return _internal_has_match_criteria();
}
inline void IpTunnelRequest::clear_match_criteria() {
  if (GetArenaForAllocation() == nullptr && match_criteria_ != nullptr) {
    delete match_criteria_;
  }
  match_criteria_ = nullptr;
}
inline const ::tunneloffload::v1alpha1::MatchCriteria& IpTunnelRequest::_internal_match_criteria() const {
  const ::tunneloffload::v1alpha1::MatchCriteria* p = match_criteria_;
  return p != nullptr ? *p : reinterpret_cast<const ::tunneloffload::v1alpha1::MatchCriteria&>(
      ::tunneloffload::v1alpha1::_MatchCriteria_default_instance_);
}
inline const ::tunneloffload::v1alpha1::MatchCriteria& IpTunnelRequest::match_criteria() const {
  // @@protoc_insertion_point(field_get:tunneloffload.v1alpha1.IpTunnelRequest.match_criteria)
  return _internal_match_criteria();
}
inline void IpTunnelRequest::unsafe_arena_set_allocated_match_criteria(
    ::tunneloffload::v1alpha1::MatchCriteria* match_criteria) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(match_criteria_);
  }
  match_criteria_ = match_criteria;
  if (match_criteria) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tunneloffload.v1alpha1.IpTunnelRequest.match_criteria)
}
inline ::tunneloffload::v1alpha1::MatchCriteria* IpTunnelRequest::release_match_criteria() {
  
  ::tunneloffload::v1alpha1::MatchCriteria* temp = match_criteria_;
  match_criteria_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tunneloffload::v1alpha1::MatchCriteria* IpTunnelRequest::unsafe_arena_release_match_criteria() {
  // @@protoc_insertion_point(field_release:tunneloffload.v1alpha1.IpTunnelRequest.match_criteria)
  
  ::tunneloffload::v1alpha1::MatchCriteria* temp = match_criteria_;
  match_criteria_ = nullptr;
  return temp;
}
inline ::tunneloffload::v1alpha1::MatchCriteria* IpTunnelRequest::_internal_mutable_match_criteria() {
  
  if (match_criteria_ == nullptr) {
    auto* p = CreateMaybeMessage<::tunneloffload::v1alpha1::MatchCriteria>(GetArenaForAllocation());
    match_criteria_ = p;
  }
  return match_criteria_;
}
inline ::tunneloffload::v1alpha1::MatchCriteria* IpTunnelRequest::mutable_match_criteria() {
  ::tunneloffload::v1alpha1::MatchCriteria* _msg = _internal_mutable_match_criteria();
  // @@protoc_insertion_point(field_mutable:tunneloffload.v1alpha1.IpTunnelRequest.match_criteria)
  return _msg;
}
inline void IpTunnelRequest::set_allocated_match_criteria(::tunneloffload::v1alpha1::MatchCriteria* match_criteria) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete match_criteria_;
  }
  if (match_criteria) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::tunneloffload::v1alpha1::MatchCriteria>::GetOwningArena(match_criteria);
    if (message_arena != submessage_arena) {
      match_criteria = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, match_criteria, submessage_arena);
    }
    
  } else {
    
  }
  match_criteria_ = match_criteria;
  // @@protoc_insertion_point(field_set_allocated:tunneloffload.v1alpha1.IpTunnelRequest.match_criteria)
}

// .tunneloffload.v1alpha1.Action next_action = 4;
inline void IpTunnelRequest::clear_next_action() {
  next_action_ = 0;
}
inline ::tunneloffload::v1alpha1::Action IpTunnelRequest::_internal_next_action() const {
  return static_cast< ::tunneloffload::v1alpha1::Action >(next_action_);
}
inline ::tunneloffload::v1alpha1::Action IpTunnelRequest::next_action() const {
  // @@protoc_insertion_point(field_get:tunneloffload.v1alpha1.IpTunnelRequest.next_action)
  return _internal_next_action();
}
inline void IpTunnelRequest::_internal_set_next_action(::tunneloffload::v1alpha1::Action value) {
  
  next_action_ = value;
}
inline void IpTunnelRequest::set_next_action(::tunneloffload::v1alpha1::Action value) {
  _internal_set_next_action(value);
  // @@protoc_insertion_point(field_set:tunneloffload.v1alpha1.IpTunnelRequest.next_action)
}

// .tunneloffload.v1alpha1.IPSecTunnel ipsec_tunnel = 5;
inline bool IpTunnelRequest::_internal_has_ipsec_tunnel() const {
  return tunnel_case() == kIpsecTunnel;
}
inline bool IpTunnelRequest::has_ipsec_tunnel() const {
  return _internal_has_ipsec_tunnel();
}
inline void IpTunnelRequest::set_has_ipsec_tunnel() {
  _oneof_case_[0] = kIpsecTunnel;
}
inline void IpTunnelRequest::clear_ipsec_tunnel() {
  if (_internal_has_ipsec_tunnel()) {
    if (GetArenaForAllocation() == nullptr) {
      delete tunnel_.ipsec_tunnel_;
    }
    clear_has_tunnel();
  }
}
inline ::tunneloffload::v1alpha1::IPSecTunnel* IpTunnelRequest::release_ipsec_tunnel() {
  // @@protoc_insertion_point(field_release:tunneloffload.v1alpha1.IpTunnelRequest.ipsec_tunnel)
  if (_internal_has_ipsec_tunnel()) {
    clear_has_tunnel();
      ::tunneloffload::v1alpha1::IPSecTunnel* temp = tunnel_.ipsec_tunnel_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    tunnel_.ipsec_tunnel_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tunneloffload::v1alpha1::IPSecTunnel& IpTunnelRequest::_internal_ipsec_tunnel() const {
  return _internal_has_ipsec_tunnel()
      ? *tunnel_.ipsec_tunnel_
      : reinterpret_cast< ::tunneloffload::v1alpha1::IPSecTunnel&>(::tunneloffload::v1alpha1::_IPSecTunnel_default_instance_);
}
inline const ::tunneloffload::v1alpha1::IPSecTunnel& IpTunnelRequest::ipsec_tunnel() const {
  // @@protoc_insertion_point(field_get:tunneloffload.v1alpha1.IpTunnelRequest.ipsec_tunnel)
  return _internal_ipsec_tunnel();
}
inline ::tunneloffload::v1alpha1::IPSecTunnel* IpTunnelRequest::unsafe_arena_release_ipsec_tunnel() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tunneloffload.v1alpha1.IpTunnelRequest.ipsec_tunnel)
  if (_internal_has_ipsec_tunnel()) {
    clear_has_tunnel();
    ::tunneloffload::v1alpha1::IPSecTunnel* temp = tunnel_.ipsec_tunnel_;
    tunnel_.ipsec_tunnel_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void IpTunnelRequest::unsafe_arena_set_allocated_ipsec_tunnel(::tunneloffload::v1alpha1::IPSecTunnel* ipsec_tunnel) {
  clear_tunnel();
  if (ipsec_tunnel) {
    set_has_ipsec_tunnel();
    tunnel_.ipsec_tunnel_ = ipsec_tunnel;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tunneloffload.v1alpha1.IpTunnelRequest.ipsec_tunnel)
}
inline ::tunneloffload::v1alpha1::IPSecTunnel* IpTunnelRequest::_internal_mutable_ipsec_tunnel() {
  if (!_internal_has_ipsec_tunnel()) {
    clear_tunnel();
    set_has_ipsec_tunnel();
    tunnel_.ipsec_tunnel_ = CreateMaybeMessage< ::tunneloffload::v1alpha1::IPSecTunnel >(GetArenaForAllocation());
  }
  return tunnel_.ipsec_tunnel_;
}
inline ::tunneloffload::v1alpha1::IPSecTunnel* IpTunnelRequest::mutable_ipsec_tunnel() {
  ::tunneloffload::v1alpha1::IPSecTunnel* _msg = _internal_mutable_ipsec_tunnel();
  // @@protoc_insertion_point(field_mutable:tunneloffload.v1alpha1.IpTunnelRequest.ipsec_tunnel)
  return _msg;
}

// .tunneloffload.v1alpha1.Geneve geneve = 6;
inline bool IpTunnelRequest::_internal_has_geneve() const {
  return tunnel_case() == kGeneve;
}
inline bool IpTunnelRequest::has_geneve() const {
  return _internal_has_geneve();
}
inline void IpTunnelRequest::set_has_geneve() {
  _oneof_case_[0] = kGeneve;
}
inline void IpTunnelRequest::clear_geneve() {
  if (_internal_has_geneve()) {
    if (GetArenaForAllocation() == nullptr) {
      delete tunnel_.geneve_;
    }
    clear_has_tunnel();
  }
}
inline ::tunneloffload::v1alpha1::Geneve* IpTunnelRequest::release_geneve() {
  // @@protoc_insertion_point(field_release:tunneloffload.v1alpha1.IpTunnelRequest.geneve)
  if (_internal_has_geneve()) {
    clear_has_tunnel();
      ::tunneloffload::v1alpha1::Geneve* temp = tunnel_.geneve_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    tunnel_.geneve_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tunneloffload::v1alpha1::Geneve& IpTunnelRequest::_internal_geneve() const {
  return _internal_has_geneve()
      ? *tunnel_.geneve_
      : reinterpret_cast< ::tunneloffload::v1alpha1::Geneve&>(::tunneloffload::v1alpha1::_Geneve_default_instance_);
}
inline const ::tunneloffload::v1alpha1::Geneve& IpTunnelRequest::geneve() const {
  // @@protoc_insertion_point(field_get:tunneloffload.v1alpha1.IpTunnelRequest.geneve)
  return _internal_geneve();
}
inline ::tunneloffload::v1alpha1::Geneve* IpTunnelRequest::unsafe_arena_release_geneve() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tunneloffload.v1alpha1.IpTunnelRequest.geneve)
  if (_internal_has_geneve()) {
    clear_has_tunnel();
    ::tunneloffload::v1alpha1::Geneve* temp = tunnel_.geneve_;
    tunnel_.geneve_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void IpTunnelRequest::unsafe_arena_set_allocated_geneve(::tunneloffload::v1alpha1::Geneve* geneve) {
  clear_tunnel();
  if (geneve) {
    set_has_geneve();
    tunnel_.geneve_ = geneve;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tunneloffload.v1alpha1.IpTunnelRequest.geneve)
}
inline ::tunneloffload::v1alpha1::Geneve* IpTunnelRequest::_internal_mutable_geneve() {
  if (!_internal_has_geneve()) {
    clear_tunnel();
    set_has_geneve();
    tunnel_.geneve_ = CreateMaybeMessage< ::tunneloffload::v1alpha1::Geneve >(GetArenaForAllocation());
  }
  return tunnel_.geneve_;
}
inline ::tunneloffload::v1alpha1::Geneve* IpTunnelRequest::mutable_geneve() {
  ::tunneloffload::v1alpha1::Geneve* _msg = _internal_mutable_geneve();
  // @@protoc_insertion_point(field_mutable:tunneloffload.v1alpha1.IpTunnelRequest.geneve)
  return _msg;
}

// .tunneloffload.v1alpha1.Nat nat = 7;
inline bool IpTunnelRequest::_internal_has_nat() const {
  return tunnel_case() == kNat;
}
inline bool IpTunnelRequest::has_nat() const {
  return _internal_has_nat();
}
inline void IpTunnelRequest::set_has_nat() {
  _oneof_case_[0] = kNat;
}
inline void IpTunnelRequest::clear_nat() {
  if (_internal_has_nat()) {
    if (GetArenaForAllocation() == nullptr) {
      delete tunnel_.nat_;
    }
    clear_has_tunnel();
  }
}
inline ::tunneloffload::v1alpha1::Nat* IpTunnelRequest::release_nat() {
  // @@protoc_insertion_point(field_release:tunneloffload.v1alpha1.IpTunnelRequest.nat)
  if (_internal_has_nat()) {
    clear_has_tunnel();
      ::tunneloffload::v1alpha1::Nat* temp = tunnel_.nat_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    tunnel_.nat_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tunneloffload::v1alpha1::Nat& IpTunnelRequest::_internal_nat() const {
  return _internal_has_nat()
      ? *tunnel_.nat_
      : reinterpret_cast< ::tunneloffload::v1alpha1::Nat&>(::tunneloffload::v1alpha1::_Nat_default_instance_);
}
inline const ::tunneloffload::v1alpha1::Nat& IpTunnelRequest::nat() const {
  // @@protoc_insertion_point(field_get:tunneloffload.v1alpha1.IpTunnelRequest.nat)
  return _internal_nat();
}
inline ::tunneloffload::v1alpha1::Nat* IpTunnelRequest::unsafe_arena_release_nat() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tunneloffload.v1alpha1.IpTunnelRequest.nat)
  if (_internal_has_nat()) {
    clear_has_tunnel();
    ::tunneloffload::v1alpha1::Nat* temp = tunnel_.nat_;
    tunnel_.nat_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void IpTunnelRequest::unsafe_arena_set_allocated_nat(::tunneloffload::v1alpha1::Nat* nat) {
  clear_tunnel();
  if (nat) {
    set_has_nat();
    tunnel_.nat_ = nat;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tunneloffload.v1alpha1.IpTunnelRequest.nat)
}
inline ::tunneloffload::v1alpha1::Nat* IpTunnelRequest::_internal_mutable_nat() {
  if (!_internal_has_nat()) {
    clear_tunnel();
    set_has_nat();
    tunnel_.nat_ = CreateMaybeMessage< ::tunneloffload::v1alpha1::Nat >(GetArenaForAllocation());
  }
  return tunnel_.nat_;
}
inline ::tunneloffload::v1alpha1::Nat* IpTunnelRequest::mutable_nat() {
  ::tunneloffload::v1alpha1::Nat* _msg = _internal_mutable_nat();
  // @@protoc_insertion_point(field_mutable:tunneloffload.v1alpha1.IpTunnelRequest.nat)
  return _msg;
}

inline bool IpTunnelRequest::has_tunnel() const {
  return tunnel_case() != TUNNEL_NOT_SET;
}
inline void IpTunnelRequest::clear_has_tunnel() {
  _oneof_case_[0] = TUNNEL_NOT_SET;
}
inline IpTunnelRequest::TunnelCase IpTunnelRequest::tunnel_case() const {
  return IpTunnelRequest::TunnelCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Geneve

// .tunneloffload.v1alpha1.GeneveEncap geneve_encap = 1;
inline bool Geneve::_internal_has_geneve_encap() const {
  return encap_decap_case() == kGeneveEncap;
}
inline bool Geneve::has_geneve_encap() const {
  return _internal_has_geneve_encap();
}
inline void Geneve::set_has_geneve_encap() {
  _oneof_case_[0] = kGeneveEncap;
}
inline void Geneve::clear_geneve_encap() {
  if (_internal_has_geneve_encap()) {
    if (GetArenaForAllocation() == nullptr) {
      delete encap_decap_.geneve_encap_;
    }
    clear_has_encap_decap();
  }
}
inline ::tunneloffload::v1alpha1::GeneveEncap* Geneve::release_geneve_encap() {
  // @@protoc_insertion_point(field_release:tunneloffload.v1alpha1.Geneve.geneve_encap)
  if (_internal_has_geneve_encap()) {
    clear_has_encap_decap();
      ::tunneloffload::v1alpha1::GeneveEncap* temp = encap_decap_.geneve_encap_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    encap_decap_.geneve_encap_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tunneloffload::v1alpha1::GeneveEncap& Geneve::_internal_geneve_encap() const {
  return _internal_has_geneve_encap()
      ? *encap_decap_.geneve_encap_
      : reinterpret_cast< ::tunneloffload::v1alpha1::GeneveEncap&>(::tunneloffload::v1alpha1::_GeneveEncap_default_instance_);
}
inline const ::tunneloffload::v1alpha1::GeneveEncap& Geneve::geneve_encap() const {
  // @@protoc_insertion_point(field_get:tunneloffload.v1alpha1.Geneve.geneve_encap)
  return _internal_geneve_encap();
}
inline ::tunneloffload::v1alpha1::GeneveEncap* Geneve::unsafe_arena_release_geneve_encap() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tunneloffload.v1alpha1.Geneve.geneve_encap)
  if (_internal_has_geneve_encap()) {
    clear_has_encap_decap();
    ::tunneloffload::v1alpha1::GeneveEncap* temp = encap_decap_.geneve_encap_;
    encap_decap_.geneve_encap_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Geneve::unsafe_arena_set_allocated_geneve_encap(::tunneloffload::v1alpha1::GeneveEncap* geneve_encap) {
  clear_encap_decap();
  if (geneve_encap) {
    set_has_geneve_encap();
    encap_decap_.geneve_encap_ = geneve_encap;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tunneloffload.v1alpha1.Geneve.geneve_encap)
}
inline ::tunneloffload::v1alpha1::GeneveEncap* Geneve::_internal_mutable_geneve_encap() {
  if (!_internal_has_geneve_encap()) {
    clear_encap_decap();
    set_has_geneve_encap();
    encap_decap_.geneve_encap_ = CreateMaybeMessage< ::tunneloffload::v1alpha1::GeneveEncap >(GetArenaForAllocation());
  }
  return encap_decap_.geneve_encap_;
}
inline ::tunneloffload::v1alpha1::GeneveEncap* Geneve::mutable_geneve_encap() {
  ::tunneloffload::v1alpha1::GeneveEncap* _msg = _internal_mutable_geneve_encap();
  // @@protoc_insertion_point(field_mutable:tunneloffload.v1alpha1.Geneve.geneve_encap)
  return _msg;
}

// .tunneloffload.v1alpha1.GeneveDecap geneve_decap = 2;
inline bool Geneve::_internal_has_geneve_decap() const {
  return encap_decap_case() == kGeneveDecap;
}
inline bool Geneve::has_geneve_decap() const {
  return _internal_has_geneve_decap();
}
inline void Geneve::set_has_geneve_decap() {
  _oneof_case_[0] = kGeneveDecap;
}
inline void Geneve::clear_geneve_decap() {
  if (_internal_has_geneve_decap()) {
    if (GetArenaForAllocation() == nullptr) {
      delete encap_decap_.geneve_decap_;
    }
    clear_has_encap_decap();
  }
}
inline ::tunneloffload::v1alpha1::GeneveDecap* Geneve::release_geneve_decap() {
  // @@protoc_insertion_point(field_release:tunneloffload.v1alpha1.Geneve.geneve_decap)
  if (_internal_has_geneve_decap()) {
    clear_has_encap_decap();
      ::tunneloffload::v1alpha1::GeneveDecap* temp = encap_decap_.geneve_decap_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    encap_decap_.geneve_decap_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tunneloffload::v1alpha1::GeneveDecap& Geneve::_internal_geneve_decap() const {
  return _internal_has_geneve_decap()
      ? *encap_decap_.geneve_decap_
      : reinterpret_cast< ::tunneloffload::v1alpha1::GeneveDecap&>(::tunneloffload::v1alpha1::_GeneveDecap_default_instance_);
}
inline const ::tunneloffload::v1alpha1::GeneveDecap& Geneve::geneve_decap() const {
  // @@protoc_insertion_point(field_get:tunneloffload.v1alpha1.Geneve.geneve_decap)
  return _internal_geneve_decap();
}
inline ::tunneloffload::v1alpha1::GeneveDecap* Geneve::unsafe_arena_release_geneve_decap() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tunneloffload.v1alpha1.Geneve.geneve_decap)
  if (_internal_has_geneve_decap()) {
    clear_has_encap_decap();
    ::tunneloffload::v1alpha1::GeneveDecap* temp = encap_decap_.geneve_decap_;
    encap_decap_.geneve_decap_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Geneve::unsafe_arena_set_allocated_geneve_decap(::tunneloffload::v1alpha1::GeneveDecap* geneve_decap) {
  clear_encap_decap();
  if (geneve_decap) {
    set_has_geneve_decap();
    encap_decap_.geneve_decap_ = geneve_decap;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tunneloffload.v1alpha1.Geneve.geneve_decap)
}
inline ::tunneloffload::v1alpha1::GeneveDecap* Geneve::_internal_mutable_geneve_decap() {
  if (!_internal_has_geneve_decap()) {
    clear_encap_decap();
    set_has_geneve_decap();
    encap_decap_.geneve_decap_ = CreateMaybeMessage< ::tunneloffload::v1alpha1::GeneveDecap >(GetArenaForAllocation());
  }
  return encap_decap_.geneve_decap_;
}
inline ::tunneloffload::v1alpha1::GeneveDecap* Geneve::mutable_geneve_decap() {
  ::tunneloffload::v1alpha1::GeneveDecap* _msg = _internal_mutable_geneve_decap();
  // @@protoc_insertion_point(field_mutable:tunneloffload.v1alpha1.Geneve.geneve_decap)
  return _msg;
}

inline bool Geneve::has_encap_decap() const {
  return encap_decap_case() != ENCAP_DECAP_NOT_SET;
}
inline void Geneve::clear_has_encap_decap() {
  _oneof_case_[0] = ENCAP_DECAP_NOT_SET;
}
inline Geneve::EncapDecapCase Geneve::encap_decap_case() const {
  return Geneve::EncapDecapCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// GeneveOption

// uint32 option_class = 1;
inline void GeneveOption::clear_option_class() {
  option_class_ = 0u;
}
inline uint32_t GeneveOption::_internal_option_class() const {
  return option_class_;
}
inline uint32_t GeneveOption::option_class() const {
  // @@protoc_insertion_point(field_get:tunneloffload.v1alpha1.GeneveOption.option_class)
  return _internal_option_class();
}
inline void GeneveOption::_internal_set_option_class(uint32_t value) {
  
  option_class_ = value;
}
inline void GeneveOption::set_option_class(uint32_t value) {
  _internal_set_option_class(value);
  // @@protoc_insertion_point(field_set:tunneloffload.v1alpha1.GeneveOption.option_class)
}

// uint32 type = 2;
inline void GeneveOption::clear_type() {
  type_ = 0u;
}
inline uint32_t GeneveOption::_internal_type() const {
  return type_;
}
inline uint32_t GeneveOption::type() const {
  // @@protoc_insertion_point(field_get:tunneloffload.v1alpha1.GeneveOption.type)
  return _internal_type();
}
inline void GeneveOption::_internal_set_type(uint32_t value) {
  
  type_ = value;
}
inline void GeneveOption::set_type(uint32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:tunneloffload.v1alpha1.GeneveOption.type)
}

// uint32 length = 3;
inline void GeneveOption::clear_length() {
  length_ = 0u;
}
inline uint32_t GeneveOption::_internal_length() const {
  return length_;
}
inline uint32_t GeneveOption::length() const {
  // @@protoc_insertion_point(field_get:tunneloffload.v1alpha1.GeneveOption.length)
  return _internal_length();
}
inline void GeneveOption::_internal_set_length(uint32_t value) {
  
  length_ = value;
}
inline void GeneveOption::set_length(uint32_t value) {
  _internal_set_length(value);
  // @@protoc_insertion_point(field_set:tunneloffload.v1alpha1.GeneveOption.length)
}

// bytes data = 4;
inline void GeneveOption::clear_data() {
  data_.ClearToEmpty();
}
inline const std::string& GeneveOption::data() const {
  // @@protoc_insertion_point(field_get:tunneloffload.v1alpha1.GeneveOption.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GeneveOption::set_data(ArgT0&& arg0, ArgT... args) {
 
 data_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tunneloffload.v1alpha1.GeneveOption.data)
}
inline std::string* GeneveOption::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:tunneloffload.v1alpha1.GeneveOption.data)
  return _s;
}
inline const std::string& GeneveOption::_internal_data() const {
  return data_.Get();
}
inline void GeneveOption::_internal_set_data(const std::string& value) {
  
  data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GeneveOption::_internal_mutable_data() {
  
  return data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GeneveOption::release_data() {
  // @@protoc_insertion_point(field_release:tunneloffload.v1alpha1.GeneveOption.data)
  return data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GeneveOption::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (data_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tunneloffload.v1alpha1.GeneveOption.data)
}

// -------------------------------------------------------------------

// GeneveEncap

// .tunneloffload.v1alpha1.IPV4Pair outer_ipv4_pair = 1;
inline bool GeneveEncap::_internal_has_outer_ipv4_pair() const {
  return ip_case() == kOuterIpv4Pair;
}
inline bool GeneveEncap::has_outer_ipv4_pair() const {
  return _internal_has_outer_ipv4_pair();
}
inline void GeneveEncap::set_has_outer_ipv4_pair() {
  _oneof_case_[0] = kOuterIpv4Pair;
}
inline void GeneveEncap::clear_outer_ipv4_pair() {
  if (_internal_has_outer_ipv4_pair()) {
    if (GetArenaForAllocation() == nullptr) {
      delete ip_.outer_ipv4_pair_;
    }
    clear_has_ip();
  }
}
inline ::tunneloffload::v1alpha1::IPV4Pair* GeneveEncap::release_outer_ipv4_pair() {
  // @@protoc_insertion_point(field_release:tunneloffload.v1alpha1.GeneveEncap.outer_ipv4_pair)
  if (_internal_has_outer_ipv4_pair()) {
    clear_has_ip();
      ::tunneloffload::v1alpha1::IPV4Pair* temp = ip_.outer_ipv4_pair_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    ip_.outer_ipv4_pair_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tunneloffload::v1alpha1::IPV4Pair& GeneveEncap::_internal_outer_ipv4_pair() const {
  return _internal_has_outer_ipv4_pair()
      ? *ip_.outer_ipv4_pair_
      : reinterpret_cast< ::tunneloffload::v1alpha1::IPV4Pair&>(::tunneloffload::v1alpha1::_IPV4Pair_default_instance_);
}
inline const ::tunneloffload::v1alpha1::IPV4Pair& GeneveEncap::outer_ipv4_pair() const {
  // @@protoc_insertion_point(field_get:tunneloffload.v1alpha1.GeneveEncap.outer_ipv4_pair)
  return _internal_outer_ipv4_pair();
}
inline ::tunneloffload::v1alpha1::IPV4Pair* GeneveEncap::unsafe_arena_release_outer_ipv4_pair() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tunneloffload.v1alpha1.GeneveEncap.outer_ipv4_pair)
  if (_internal_has_outer_ipv4_pair()) {
    clear_has_ip();
    ::tunneloffload::v1alpha1::IPV4Pair* temp = ip_.outer_ipv4_pair_;
    ip_.outer_ipv4_pair_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GeneveEncap::unsafe_arena_set_allocated_outer_ipv4_pair(::tunneloffload::v1alpha1::IPV4Pair* outer_ipv4_pair) {
  clear_ip();
  if (outer_ipv4_pair) {
    set_has_outer_ipv4_pair();
    ip_.outer_ipv4_pair_ = outer_ipv4_pair;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tunneloffload.v1alpha1.GeneveEncap.outer_ipv4_pair)
}
inline ::tunneloffload::v1alpha1::IPV4Pair* GeneveEncap::_internal_mutable_outer_ipv4_pair() {
  if (!_internal_has_outer_ipv4_pair()) {
    clear_ip();
    set_has_outer_ipv4_pair();
    ip_.outer_ipv4_pair_ = CreateMaybeMessage< ::tunneloffload::v1alpha1::IPV4Pair >(GetArenaForAllocation());
  }
  return ip_.outer_ipv4_pair_;
}
inline ::tunneloffload::v1alpha1::IPV4Pair* GeneveEncap::mutable_outer_ipv4_pair() {
  ::tunneloffload::v1alpha1::IPV4Pair* _msg = _internal_mutable_outer_ipv4_pair();
  // @@protoc_insertion_point(field_mutable:tunneloffload.v1alpha1.GeneveEncap.outer_ipv4_pair)
  return _msg;
}

// .tunneloffload.v1alpha1.IPV6Pair outer_ipv6_pair = 2;
inline bool GeneveEncap::_internal_has_outer_ipv6_pair() const {
  return ip_case() == kOuterIpv6Pair;
}
inline bool GeneveEncap::has_outer_ipv6_pair() const {
  return _internal_has_outer_ipv6_pair();
}
inline void GeneveEncap::set_has_outer_ipv6_pair() {
  _oneof_case_[0] = kOuterIpv6Pair;
}
inline void GeneveEncap::clear_outer_ipv6_pair() {
  if (_internal_has_outer_ipv6_pair()) {
    if (GetArenaForAllocation() == nullptr) {
      delete ip_.outer_ipv6_pair_;
    }
    clear_has_ip();
  }
}
inline ::tunneloffload::v1alpha1::IPV6Pair* GeneveEncap::release_outer_ipv6_pair() {
  // @@protoc_insertion_point(field_release:tunneloffload.v1alpha1.GeneveEncap.outer_ipv6_pair)
  if (_internal_has_outer_ipv6_pair()) {
    clear_has_ip();
      ::tunneloffload::v1alpha1::IPV6Pair* temp = ip_.outer_ipv6_pair_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    ip_.outer_ipv6_pair_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tunneloffload::v1alpha1::IPV6Pair& GeneveEncap::_internal_outer_ipv6_pair() const {
  return _internal_has_outer_ipv6_pair()
      ? *ip_.outer_ipv6_pair_
      : reinterpret_cast< ::tunneloffload::v1alpha1::IPV6Pair&>(::tunneloffload::v1alpha1::_IPV6Pair_default_instance_);
}
inline const ::tunneloffload::v1alpha1::IPV6Pair& GeneveEncap::outer_ipv6_pair() const {
  // @@protoc_insertion_point(field_get:tunneloffload.v1alpha1.GeneveEncap.outer_ipv6_pair)
  return _internal_outer_ipv6_pair();
}
inline ::tunneloffload::v1alpha1::IPV6Pair* GeneveEncap::unsafe_arena_release_outer_ipv6_pair() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tunneloffload.v1alpha1.GeneveEncap.outer_ipv6_pair)
  if (_internal_has_outer_ipv6_pair()) {
    clear_has_ip();
    ::tunneloffload::v1alpha1::IPV6Pair* temp = ip_.outer_ipv6_pair_;
    ip_.outer_ipv6_pair_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GeneveEncap::unsafe_arena_set_allocated_outer_ipv6_pair(::tunneloffload::v1alpha1::IPV6Pair* outer_ipv6_pair) {
  clear_ip();
  if (outer_ipv6_pair) {
    set_has_outer_ipv6_pair();
    ip_.outer_ipv6_pair_ = outer_ipv6_pair;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tunneloffload.v1alpha1.GeneveEncap.outer_ipv6_pair)
}
inline ::tunneloffload::v1alpha1::IPV6Pair* GeneveEncap::_internal_mutable_outer_ipv6_pair() {
  if (!_internal_has_outer_ipv6_pair()) {
    clear_ip();
    set_has_outer_ipv6_pair();
    ip_.outer_ipv6_pair_ = CreateMaybeMessage< ::tunneloffload::v1alpha1::IPV6Pair >(GetArenaForAllocation());
  }
  return ip_.outer_ipv6_pair_;
}
inline ::tunneloffload::v1alpha1::IPV6Pair* GeneveEncap::mutable_outer_ipv6_pair() {
  ::tunneloffload::v1alpha1::IPV6Pair* _msg = _internal_mutable_outer_ipv6_pair();
  // @@protoc_insertion_point(field_mutable:tunneloffload.v1alpha1.GeneveEncap.outer_ipv6_pair)
  return _msg;
}

// .tunneloffload.v1alpha1.MacPair inner_mac_pair = 3;
inline bool GeneveEncap::_internal_has_inner_mac_pair() const {
  return this != internal_default_instance() && inner_mac_pair_ != nullptr;
}
inline bool GeneveEncap::has_inner_mac_pair() const {
  return _internal_has_inner_mac_pair();
}
inline void GeneveEncap::clear_inner_mac_pair() {
  if (GetArenaForAllocation() == nullptr && inner_mac_pair_ != nullptr) {
    delete inner_mac_pair_;
  }
  inner_mac_pair_ = nullptr;
}
inline const ::tunneloffload::v1alpha1::MacPair& GeneveEncap::_internal_inner_mac_pair() const {
  const ::tunneloffload::v1alpha1::MacPair* p = inner_mac_pair_;
  return p != nullptr ? *p : reinterpret_cast<const ::tunneloffload::v1alpha1::MacPair&>(
      ::tunneloffload::v1alpha1::_MacPair_default_instance_);
}
inline const ::tunneloffload::v1alpha1::MacPair& GeneveEncap::inner_mac_pair() const {
  // @@protoc_insertion_point(field_get:tunneloffload.v1alpha1.GeneveEncap.inner_mac_pair)
  return _internal_inner_mac_pair();
}
inline void GeneveEncap::unsafe_arena_set_allocated_inner_mac_pair(
    ::tunneloffload::v1alpha1::MacPair* inner_mac_pair) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(inner_mac_pair_);
  }
  inner_mac_pair_ = inner_mac_pair;
  if (inner_mac_pair) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tunneloffload.v1alpha1.GeneveEncap.inner_mac_pair)
}
inline ::tunneloffload::v1alpha1::MacPair* GeneveEncap::release_inner_mac_pair() {
  
  ::tunneloffload::v1alpha1::MacPair* temp = inner_mac_pair_;
  inner_mac_pair_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tunneloffload::v1alpha1::MacPair* GeneveEncap::unsafe_arena_release_inner_mac_pair() {
  // @@protoc_insertion_point(field_release:tunneloffload.v1alpha1.GeneveEncap.inner_mac_pair)
  
  ::tunneloffload::v1alpha1::MacPair* temp = inner_mac_pair_;
  inner_mac_pair_ = nullptr;
  return temp;
}
inline ::tunneloffload::v1alpha1::MacPair* GeneveEncap::_internal_mutable_inner_mac_pair() {
  
  if (inner_mac_pair_ == nullptr) {
    auto* p = CreateMaybeMessage<::tunneloffload::v1alpha1::MacPair>(GetArenaForAllocation());
    inner_mac_pair_ = p;
  }
  return inner_mac_pair_;
}
inline ::tunneloffload::v1alpha1::MacPair* GeneveEncap::mutable_inner_mac_pair() {
  ::tunneloffload::v1alpha1::MacPair* _msg = _internal_mutable_inner_mac_pair();
  // @@protoc_insertion_point(field_mutable:tunneloffload.v1alpha1.GeneveEncap.inner_mac_pair)
  return _msg;
}
inline void GeneveEncap::set_allocated_inner_mac_pair(::tunneloffload::v1alpha1::MacPair* inner_mac_pair) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete inner_mac_pair_;
  }
  if (inner_mac_pair) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::tunneloffload::v1alpha1::MacPair>::GetOwningArena(inner_mac_pair);
    if (message_arena != submessage_arena) {
      inner_mac_pair = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, inner_mac_pair, submessage_arena);
    }
    
  } else {
    
  }
  inner_mac_pair_ = inner_mac_pair;
  // @@protoc_insertion_point(field_set_allocated:tunneloffload.v1alpha1.GeneveEncap.inner_mac_pair)
}

// uint32 option_length = 4;
inline void GeneveEncap::clear_option_length() {
  option_length_ = 0u;
}
inline uint32_t GeneveEncap::_internal_option_length() const {
  return option_length_;
}
inline uint32_t GeneveEncap::option_length() const {
  // @@protoc_insertion_point(field_get:tunneloffload.v1alpha1.GeneveEncap.option_length)
  return _internal_option_length();
}
inline void GeneveEncap::_internal_set_option_length(uint32_t value) {
  
  option_length_ = value;
}
inline void GeneveEncap::set_option_length(uint32_t value) {
  _internal_set_option_length(value);
  // @@protoc_insertion_point(field_set:tunneloffload.v1alpha1.GeneveEncap.option_length)
}

// bool control_packet = 5;
inline void GeneveEncap::clear_control_packet() {
  control_packet_ = false;
}
inline bool GeneveEncap::_internal_control_packet() const {
  return control_packet_;
}
inline bool GeneveEncap::control_packet() const {
  // @@protoc_insertion_point(field_get:tunneloffload.v1alpha1.GeneveEncap.control_packet)
  return _internal_control_packet();
}
inline void GeneveEncap::_internal_set_control_packet(bool value) {
  
  control_packet_ = value;
}
inline void GeneveEncap::set_control_packet(bool value) {
  _internal_set_control_packet(value);
  // @@protoc_insertion_point(field_set:tunneloffload.v1alpha1.GeneveEncap.control_packet)
}

// bool critical_option_present = 6;
inline void GeneveEncap::clear_critical_option_present() {
  critical_option_present_ = false;
}
inline bool GeneveEncap::_internal_critical_option_present() const {
  return critical_option_present_;
}
inline bool GeneveEncap::critical_option_present() const {
  // @@protoc_insertion_point(field_get:tunneloffload.v1alpha1.GeneveEncap.critical_option_present)
  return _internal_critical_option_present();
}
inline void GeneveEncap::_internal_set_critical_option_present(bool value) {
  
  critical_option_present_ = value;
}
inline void GeneveEncap::set_critical_option_present(bool value) {
  _internal_set_critical_option_present(value);
  // @@protoc_insertion_point(field_set:tunneloffload.v1alpha1.GeneveEncap.critical_option_present)
}

// uint32 vni = 7;
inline void GeneveEncap::clear_vni() {
  vni_ = 0u;
}
inline uint32_t GeneveEncap::_internal_vni() const {
  return vni_;
}
inline uint32_t GeneveEncap::vni() const {
  // @@protoc_insertion_point(field_get:tunneloffload.v1alpha1.GeneveEncap.vni)
  return _internal_vni();
}
inline void GeneveEncap::_internal_set_vni(uint32_t value) {
  
  vni_ = value;
}
inline void GeneveEncap::set_vni(uint32_t value) {
  _internal_set_vni(value);
  // @@protoc_insertion_point(field_set:tunneloffload.v1alpha1.GeneveEncap.vni)
}

// uint32 protocol_type = 8;
inline void GeneveEncap::clear_protocol_type() {
  protocol_type_ = 0u;
}
inline uint32_t GeneveEncap::_internal_protocol_type() const {
  return protocol_type_;
}
inline uint32_t GeneveEncap::protocol_type() const {
  // @@protoc_insertion_point(field_get:tunneloffload.v1alpha1.GeneveEncap.protocol_type)
  return _internal_protocol_type();
}
inline void GeneveEncap::_internal_set_protocol_type(uint32_t value) {
  
  protocol_type_ = value;
}
inline void GeneveEncap::set_protocol_type(uint32_t value) {
  _internal_set_protocol_type(value);
  // @@protoc_insertion_point(field_set:tunneloffload.v1alpha1.GeneveEncap.protocol_type)
}

// repeated .tunneloffload.v1alpha1.GeneveOption geneve_option = 9;
inline int GeneveEncap::_internal_geneve_option_size() const {
  return geneve_option_.size();
}
inline int GeneveEncap::geneve_option_size() const {
  return _internal_geneve_option_size();
}
inline void GeneveEncap::clear_geneve_option() {
  geneve_option_.Clear();
}
inline ::tunneloffload::v1alpha1::GeneveOption* GeneveEncap::mutable_geneve_option(int index) {
  // @@protoc_insertion_point(field_mutable:tunneloffload.v1alpha1.GeneveEncap.geneve_option)
  return geneve_option_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tunneloffload::v1alpha1::GeneveOption >*
GeneveEncap::mutable_geneve_option() {
  // @@protoc_insertion_point(field_mutable_list:tunneloffload.v1alpha1.GeneveEncap.geneve_option)
  return &geneve_option_;
}
inline const ::tunneloffload::v1alpha1::GeneveOption& GeneveEncap::_internal_geneve_option(int index) const {
  return geneve_option_.Get(index);
}
inline const ::tunneloffload::v1alpha1::GeneveOption& GeneveEncap::geneve_option(int index) const {
  // @@protoc_insertion_point(field_get:tunneloffload.v1alpha1.GeneveEncap.geneve_option)
  return _internal_geneve_option(index);
}
inline ::tunneloffload::v1alpha1::GeneveOption* GeneveEncap::_internal_add_geneve_option() {
  return geneve_option_.Add();
}
inline ::tunneloffload::v1alpha1::GeneveOption* GeneveEncap::add_geneve_option() {
  ::tunneloffload::v1alpha1::GeneveOption* _add = _internal_add_geneve_option();
  // @@protoc_insertion_point(field_add:tunneloffload.v1alpha1.GeneveEncap.geneve_option)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tunneloffload::v1alpha1::GeneveOption >&
GeneveEncap::geneve_option() const {
  // @@protoc_insertion_point(field_list:tunneloffload.v1alpha1.GeneveEncap.geneve_option)
  return geneve_option_;
}

inline bool GeneveEncap::has_ip() const {
  return ip_case() != IP_NOT_SET;
}
inline void GeneveEncap::clear_has_ip() {
  _oneof_case_[0] = IP_NOT_SET;
}
inline GeneveEncap::IpCase GeneveEncap::ip_case() const {
  return GeneveEncap::IpCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// GeneveDecap

// -------------------------------------------------------------------

// MacPair

// bytes destination_mac = 1;
inline void MacPair::clear_destination_mac() {
  destination_mac_.ClearToEmpty();
}
inline const std::string& MacPair::destination_mac() const {
  // @@protoc_insertion_point(field_get:tunneloffload.v1alpha1.MacPair.destination_mac)
  return _internal_destination_mac();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MacPair::set_destination_mac(ArgT0&& arg0, ArgT... args) {
 
 destination_mac_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tunneloffload.v1alpha1.MacPair.destination_mac)
}
inline std::string* MacPair::mutable_destination_mac() {
  std::string* _s = _internal_mutable_destination_mac();
  // @@protoc_insertion_point(field_mutable:tunneloffload.v1alpha1.MacPair.destination_mac)
  return _s;
}
inline const std::string& MacPair::_internal_destination_mac() const {
  return destination_mac_.Get();
}
inline void MacPair::_internal_set_destination_mac(const std::string& value) {
  
  destination_mac_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MacPair::_internal_mutable_destination_mac() {
  
  return destination_mac_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MacPair::release_destination_mac() {
  // @@protoc_insertion_point(field_release:tunneloffload.v1alpha1.MacPair.destination_mac)
  return destination_mac_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MacPair::set_allocated_destination_mac(std::string* destination_mac) {
  if (destination_mac != nullptr) {
    
  } else {
    
  }
  destination_mac_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), destination_mac,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (destination_mac_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    destination_mac_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tunneloffload.v1alpha1.MacPair.destination_mac)
}

// bytes source_mac = 2;
inline void MacPair::clear_source_mac() {
  source_mac_.ClearToEmpty();
}
inline const std::string& MacPair::source_mac() const {
  // @@protoc_insertion_point(field_get:tunneloffload.v1alpha1.MacPair.source_mac)
  return _internal_source_mac();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MacPair::set_source_mac(ArgT0&& arg0, ArgT... args) {
 
 source_mac_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tunneloffload.v1alpha1.MacPair.source_mac)
}
inline std::string* MacPair::mutable_source_mac() {
  std::string* _s = _internal_mutable_source_mac();
  // @@protoc_insertion_point(field_mutable:tunneloffload.v1alpha1.MacPair.source_mac)
  return _s;
}
inline const std::string& MacPair::_internal_source_mac() const {
  return source_mac_.Get();
}
inline void MacPair::_internal_set_source_mac(const std::string& value) {
  
  source_mac_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MacPair::_internal_mutable_source_mac() {
  
  return source_mac_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MacPair::release_source_mac() {
  // @@protoc_insertion_point(field_release:tunneloffload.v1alpha1.MacPair.source_mac)
  return source_mac_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MacPair::set_allocated_source_mac(std::string* source_mac) {
  if (source_mac != nullptr) {
    
  } else {
    
  }
  source_mac_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), source_mac,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (source_mac_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    source_mac_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tunneloffload.v1alpha1.MacPair.source_mac)
}

// -------------------------------------------------------------------

// IPV4Pair

// fixed32 source_ip = 1;
inline void IPV4Pair::clear_source_ip() {
  source_ip_ = 0u;
}
inline uint32_t IPV4Pair::_internal_source_ip() const {
  return source_ip_;
}
inline uint32_t IPV4Pair::source_ip() const {
  // @@protoc_insertion_point(field_get:tunneloffload.v1alpha1.IPV4Pair.source_ip)
  return _internal_source_ip();
}
inline void IPV4Pair::_internal_set_source_ip(uint32_t value) {
  
  source_ip_ = value;
}
inline void IPV4Pair::set_source_ip(uint32_t value) {
  _internal_set_source_ip(value);
  // @@protoc_insertion_point(field_set:tunneloffload.v1alpha1.IPV4Pair.source_ip)
}

// fixed32 destination_ip = 2;
inline void IPV4Pair::clear_destination_ip() {
  destination_ip_ = 0u;
}
inline uint32_t IPV4Pair::_internal_destination_ip() const {
  return destination_ip_;
}
inline uint32_t IPV4Pair::destination_ip() const {
  // @@protoc_insertion_point(field_get:tunneloffload.v1alpha1.IPV4Pair.destination_ip)
  return _internal_destination_ip();
}
inline void IPV4Pair::_internal_set_destination_ip(uint32_t value) {
  
  destination_ip_ = value;
}
inline void IPV4Pair::set_destination_ip(uint32_t value) {
  _internal_set_destination_ip(value);
  // @@protoc_insertion_point(field_set:tunneloffload.v1alpha1.IPV4Pair.destination_ip)
}

// -------------------------------------------------------------------

// IPV6Pair

// bytes source_ip = 1;
inline void IPV6Pair::clear_source_ip() {
  source_ip_.ClearToEmpty();
}
inline const std::string& IPV6Pair::source_ip() const {
  // @@protoc_insertion_point(field_get:tunneloffload.v1alpha1.IPV6Pair.source_ip)
  return _internal_source_ip();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IPV6Pair::set_source_ip(ArgT0&& arg0, ArgT... args) {
 
 source_ip_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tunneloffload.v1alpha1.IPV6Pair.source_ip)
}
inline std::string* IPV6Pair::mutable_source_ip() {
  std::string* _s = _internal_mutable_source_ip();
  // @@protoc_insertion_point(field_mutable:tunneloffload.v1alpha1.IPV6Pair.source_ip)
  return _s;
}
inline const std::string& IPV6Pair::_internal_source_ip() const {
  return source_ip_.Get();
}
inline void IPV6Pair::_internal_set_source_ip(const std::string& value) {
  
  source_ip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* IPV6Pair::_internal_mutable_source_ip() {
  
  return source_ip_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* IPV6Pair::release_source_ip() {
  // @@protoc_insertion_point(field_release:tunneloffload.v1alpha1.IPV6Pair.source_ip)
  return source_ip_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void IPV6Pair::set_allocated_source_ip(std::string* source_ip) {
  if (source_ip != nullptr) {
    
  } else {
    
  }
  source_ip_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), source_ip,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (source_ip_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    source_ip_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tunneloffload.v1alpha1.IPV6Pair.source_ip)
}

// bytes destination_ip = 2;
inline void IPV6Pair::clear_destination_ip() {
  destination_ip_.ClearToEmpty();
}
inline const std::string& IPV6Pair::destination_ip() const {
  // @@protoc_insertion_point(field_get:tunneloffload.v1alpha1.IPV6Pair.destination_ip)
  return _internal_destination_ip();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IPV6Pair::set_destination_ip(ArgT0&& arg0, ArgT... args) {
 
 destination_ip_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tunneloffload.v1alpha1.IPV6Pair.destination_ip)
}
inline std::string* IPV6Pair::mutable_destination_ip() {
  std::string* _s = _internal_mutable_destination_ip();
  // @@protoc_insertion_point(field_mutable:tunneloffload.v1alpha1.IPV6Pair.destination_ip)
  return _s;
}
inline const std::string& IPV6Pair::_internal_destination_ip() const {
  return destination_ip_.Get();
}
inline void IPV6Pair::_internal_set_destination_ip(const std::string& value) {
  
  destination_ip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* IPV6Pair::_internal_mutable_destination_ip() {
  
  return destination_ip_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* IPV6Pair::release_destination_ip() {
  // @@protoc_insertion_point(field_release:tunneloffload.v1alpha1.IPV6Pair.destination_ip)
  return destination_ip_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void IPV6Pair::set_allocated_destination_ip(std::string* destination_ip) {
  if (destination_ip != nullptr) {
    
  } else {
    
  }
  destination_ip_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), destination_ip,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (destination_ip_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    destination_ip_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tunneloffload.v1alpha1.IPV6Pair.destination_ip)
}

// -------------------------------------------------------------------

// IPV4Match

// fixed32 source_ip = 1;
inline void IPV4Match::clear_source_ip() {
  source_ip_ = 0u;
}
inline uint32_t IPV4Match::_internal_source_ip() const {
  return source_ip_;
}
inline uint32_t IPV4Match::source_ip() const {
  // @@protoc_insertion_point(field_get:tunneloffload.v1alpha1.IPV4Match.source_ip)
  return _internal_source_ip();
}
inline void IPV4Match::_internal_set_source_ip(uint32_t value) {
  
  source_ip_ = value;
}
inline void IPV4Match::set_source_ip(uint32_t value) {
  _internal_set_source_ip(value);
  // @@protoc_insertion_point(field_set:tunneloffload.v1alpha1.IPV4Match.source_ip)
}

// uint32 source_ip_prefix = 2;
inline void IPV4Match::clear_source_ip_prefix() {
  source_ip_prefix_ = 0u;
}
inline uint32_t IPV4Match::_internal_source_ip_prefix() const {
  return source_ip_prefix_;
}
inline uint32_t IPV4Match::source_ip_prefix() const {
  // @@protoc_insertion_point(field_get:tunneloffload.v1alpha1.IPV4Match.source_ip_prefix)
  return _internal_source_ip_prefix();
}
inline void IPV4Match::_internal_set_source_ip_prefix(uint32_t value) {
  
  source_ip_prefix_ = value;
}
inline void IPV4Match::set_source_ip_prefix(uint32_t value) {
  _internal_set_source_ip_prefix(value);
  // @@protoc_insertion_point(field_set:tunneloffload.v1alpha1.IPV4Match.source_ip_prefix)
}

// fixed32 destination_ip = 3;
inline void IPV4Match::clear_destination_ip() {
  destination_ip_ = 0u;
}
inline uint32_t IPV4Match::_internal_destination_ip() const {
  return destination_ip_;
}
inline uint32_t IPV4Match::destination_ip() const {
  // @@protoc_insertion_point(field_get:tunneloffload.v1alpha1.IPV4Match.destination_ip)
  return _internal_destination_ip();
}
inline void IPV4Match::_internal_set_destination_ip(uint32_t value) {
  
  destination_ip_ = value;
}
inline void IPV4Match::set_destination_ip(uint32_t value) {
  _internal_set_destination_ip(value);
  // @@protoc_insertion_point(field_set:tunneloffload.v1alpha1.IPV4Match.destination_ip)
}

// uint32 destination_ip_prefix = 4;
inline void IPV4Match::clear_destination_ip_prefix() {
  destination_ip_prefix_ = 0u;
}
inline uint32_t IPV4Match::_internal_destination_ip_prefix() const {
  return destination_ip_prefix_;
}
inline uint32_t IPV4Match::destination_ip_prefix() const {
  // @@protoc_insertion_point(field_get:tunneloffload.v1alpha1.IPV4Match.destination_ip_prefix)
  return _internal_destination_ip_prefix();
}
inline void IPV4Match::_internal_set_destination_ip_prefix(uint32_t value) {
  
  destination_ip_prefix_ = value;
}
inline void IPV4Match::set_destination_ip_prefix(uint32_t value) {
  _internal_set_destination_ip_prefix(value);
  // @@protoc_insertion_point(field_set:tunneloffload.v1alpha1.IPV4Match.destination_ip_prefix)
}

// -------------------------------------------------------------------

// IPV6Match

// bytes source_ip = 1;
inline void IPV6Match::clear_source_ip() {
  source_ip_.ClearToEmpty();
}
inline const std::string& IPV6Match::source_ip() const {
  // @@protoc_insertion_point(field_get:tunneloffload.v1alpha1.IPV6Match.source_ip)
  return _internal_source_ip();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IPV6Match::set_source_ip(ArgT0&& arg0, ArgT... args) {
 
 source_ip_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tunneloffload.v1alpha1.IPV6Match.source_ip)
}
inline std::string* IPV6Match::mutable_source_ip() {
  std::string* _s = _internal_mutable_source_ip();
  // @@protoc_insertion_point(field_mutable:tunneloffload.v1alpha1.IPV6Match.source_ip)
  return _s;
}
inline const std::string& IPV6Match::_internal_source_ip() const {
  return source_ip_.Get();
}
inline void IPV6Match::_internal_set_source_ip(const std::string& value) {
  
  source_ip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* IPV6Match::_internal_mutable_source_ip() {
  
  return source_ip_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* IPV6Match::release_source_ip() {
  // @@protoc_insertion_point(field_release:tunneloffload.v1alpha1.IPV6Match.source_ip)
  return source_ip_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void IPV6Match::set_allocated_source_ip(std::string* source_ip) {
  if (source_ip != nullptr) {
    
  } else {
    
  }
  source_ip_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), source_ip,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (source_ip_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    source_ip_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tunneloffload.v1alpha1.IPV6Match.source_ip)
}

// uint32 source_ip_prefix = 2;
inline void IPV6Match::clear_source_ip_prefix() {
  source_ip_prefix_ = 0u;
}
inline uint32_t IPV6Match::_internal_source_ip_prefix() const {
  return source_ip_prefix_;
}
inline uint32_t IPV6Match::source_ip_prefix() const {
  // @@protoc_insertion_point(field_get:tunneloffload.v1alpha1.IPV6Match.source_ip_prefix)
  return _internal_source_ip_prefix();
}
inline void IPV6Match::_internal_set_source_ip_prefix(uint32_t value) {
  
  source_ip_prefix_ = value;
}
inline void IPV6Match::set_source_ip_prefix(uint32_t value) {
  _internal_set_source_ip_prefix(value);
  // @@protoc_insertion_point(field_set:tunneloffload.v1alpha1.IPV6Match.source_ip_prefix)
}

// bytes destination_ip = 3;
inline void IPV6Match::clear_destination_ip() {
  destination_ip_.ClearToEmpty();
}
inline const std::string& IPV6Match::destination_ip() const {
  // @@protoc_insertion_point(field_get:tunneloffload.v1alpha1.IPV6Match.destination_ip)
  return _internal_destination_ip();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IPV6Match::set_destination_ip(ArgT0&& arg0, ArgT... args) {
 
 destination_ip_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tunneloffload.v1alpha1.IPV6Match.destination_ip)
}
inline std::string* IPV6Match::mutable_destination_ip() {
  std::string* _s = _internal_mutable_destination_ip();
  // @@protoc_insertion_point(field_mutable:tunneloffload.v1alpha1.IPV6Match.destination_ip)
  return _s;
}
inline const std::string& IPV6Match::_internal_destination_ip() const {
  return destination_ip_.Get();
}
inline void IPV6Match::_internal_set_destination_ip(const std::string& value) {
  
  destination_ip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* IPV6Match::_internal_mutable_destination_ip() {
  
  return destination_ip_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* IPV6Match::release_destination_ip() {
  // @@protoc_insertion_point(field_release:tunneloffload.v1alpha1.IPV6Match.destination_ip)
  return destination_ip_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void IPV6Match::set_allocated_destination_ip(std::string* destination_ip) {
  if (destination_ip != nullptr) {
    
  } else {
    
  }
  destination_ip_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), destination_ip,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (destination_ip_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    destination_ip_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tunneloffload.v1alpha1.IPV6Match.destination_ip)
}

// uint32 destination_ip_prefix = 4;
inline void IPV6Match::clear_destination_ip_prefix() {
  destination_ip_prefix_ = 0u;
}
inline uint32_t IPV6Match::_internal_destination_ip_prefix() const {
  return destination_ip_prefix_;
}
inline uint32_t IPV6Match::destination_ip_prefix() const {
  // @@protoc_insertion_point(field_get:tunneloffload.v1alpha1.IPV6Match.destination_ip_prefix)
  return _internal_destination_ip_prefix();
}
inline void IPV6Match::_internal_set_destination_ip_prefix(uint32_t value) {
  
  destination_ip_prefix_ = value;
}
inline void IPV6Match::set_destination_ip_prefix(uint32_t value) {
  _internal_set_destination_ip_prefix(value);
  // @@protoc_insertion_point(field_set:tunneloffload.v1alpha1.IPV6Match.destination_ip_prefix)
}

// -------------------------------------------------------------------

// Nat

// uint32 source_ip = 1;
inline void Nat::clear_source_ip() {
  source_ip_ = 0u;
}
inline uint32_t Nat::_internal_source_ip() const {
  return source_ip_;
}
inline uint32_t Nat::source_ip() const {
  // @@protoc_insertion_point(field_get:tunneloffload.v1alpha1.Nat.source_ip)
  return _internal_source_ip();
}
inline void Nat::_internal_set_source_ip(uint32_t value) {
  
  source_ip_ = value;
}
inline void Nat::set_source_ip(uint32_t value) {
  _internal_set_source_ip(value);
  // @@protoc_insertion_point(field_set:tunneloffload.v1alpha1.Nat.source_ip)
}

// -------------------------------------------------------------------

// IPSecEnc

// .tunneloffload.v1alpha1.IPSecTunnelType tunnel_type = 1;
inline void IPSecEnc::clear_tunnel_type() {
  tunnel_type_ = 0;
}
inline ::tunneloffload::v1alpha1::IPSecTunnelType IPSecEnc::_internal_tunnel_type() const {
  return static_cast< ::tunneloffload::v1alpha1::IPSecTunnelType >(tunnel_type_);
}
inline ::tunneloffload::v1alpha1::IPSecTunnelType IPSecEnc::tunnel_type() const {
  // @@protoc_insertion_point(field_get:tunneloffload.v1alpha1.IPSecEnc.tunnel_type)
  return _internal_tunnel_type();
}
inline void IPSecEnc::_internal_set_tunnel_type(::tunneloffload::v1alpha1::IPSecTunnelType value) {
  
  tunnel_type_ = value;
}
inline void IPSecEnc::set_tunnel_type(::tunneloffload::v1alpha1::IPSecTunnelType value) {
  _internal_set_tunnel_type(value);
  // @@protoc_insertion_point(field_set:tunneloffload.v1alpha1.IPSecEnc.tunnel_type)
}

// .tunneloffload.v1alpha1.EncType encryption_type = 2;
inline void IPSecEnc::clear_encryption_type() {
  encryption_type_ = 0;
}
inline ::tunneloffload::v1alpha1::EncType IPSecEnc::_internal_encryption_type() const {
  return static_cast< ::tunneloffload::v1alpha1::EncType >(encryption_type_);
}
inline ::tunneloffload::v1alpha1::EncType IPSecEnc::encryption_type() const {
  // @@protoc_insertion_point(field_get:tunneloffload.v1alpha1.IPSecEnc.encryption_type)
  return _internal_encryption_type();
}
inline void IPSecEnc::_internal_set_encryption_type(::tunneloffload::v1alpha1::EncType value) {
  
  encryption_type_ = value;
}
inline void IPSecEnc::set_encryption_type(::tunneloffload::v1alpha1::EncType value) {
  _internal_set_encryption_type(value);
  // @@protoc_insertion_point(field_set:tunneloffload.v1alpha1.IPSecEnc.encryption_type)
}

// .tunneloffload.v1alpha1.IPSecSAParams ipsec_sa = 3;
inline bool IPSecEnc::_internal_has_ipsec_sa() const {
  return this != internal_default_instance() && ipsec_sa_ != nullptr;
}
inline bool IPSecEnc::has_ipsec_sa() const {
  return _internal_has_ipsec_sa();
}
inline void IPSecEnc::clear_ipsec_sa() {
  if (GetArenaForAllocation() == nullptr && ipsec_sa_ != nullptr) {
    delete ipsec_sa_;
  }
  ipsec_sa_ = nullptr;
}
inline const ::tunneloffload::v1alpha1::IPSecSAParams& IPSecEnc::_internal_ipsec_sa() const {
  const ::tunneloffload::v1alpha1::IPSecSAParams* p = ipsec_sa_;
  return p != nullptr ? *p : reinterpret_cast<const ::tunneloffload::v1alpha1::IPSecSAParams&>(
      ::tunneloffload::v1alpha1::_IPSecSAParams_default_instance_);
}
inline const ::tunneloffload::v1alpha1::IPSecSAParams& IPSecEnc::ipsec_sa() const {
  // @@protoc_insertion_point(field_get:tunneloffload.v1alpha1.IPSecEnc.ipsec_sa)
  return _internal_ipsec_sa();
}
inline void IPSecEnc::unsafe_arena_set_allocated_ipsec_sa(
    ::tunneloffload::v1alpha1::IPSecSAParams* ipsec_sa) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ipsec_sa_);
  }
  ipsec_sa_ = ipsec_sa;
  if (ipsec_sa) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tunneloffload.v1alpha1.IPSecEnc.ipsec_sa)
}
inline ::tunneloffload::v1alpha1::IPSecSAParams* IPSecEnc::release_ipsec_sa() {
  
  ::tunneloffload::v1alpha1::IPSecSAParams* temp = ipsec_sa_;
  ipsec_sa_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tunneloffload::v1alpha1::IPSecSAParams* IPSecEnc::unsafe_arena_release_ipsec_sa() {
  // @@protoc_insertion_point(field_release:tunneloffload.v1alpha1.IPSecEnc.ipsec_sa)
  
  ::tunneloffload::v1alpha1::IPSecSAParams* temp = ipsec_sa_;
  ipsec_sa_ = nullptr;
  return temp;
}
inline ::tunneloffload::v1alpha1::IPSecSAParams* IPSecEnc::_internal_mutable_ipsec_sa() {
  
  if (ipsec_sa_ == nullptr) {
    auto* p = CreateMaybeMessage<::tunneloffload::v1alpha1::IPSecSAParams>(GetArenaForAllocation());
    ipsec_sa_ = p;
  }
  return ipsec_sa_;
}
inline ::tunneloffload::v1alpha1::IPSecSAParams* IPSecEnc::mutable_ipsec_sa() {
  ::tunneloffload::v1alpha1::IPSecSAParams* _msg = _internal_mutable_ipsec_sa();
  // @@protoc_insertion_point(field_mutable:tunneloffload.v1alpha1.IPSecEnc.ipsec_sa)
  return _msg;
}
inline void IPSecEnc::set_allocated_ipsec_sa(::tunneloffload::v1alpha1::IPSecSAParams* ipsec_sa) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete ipsec_sa_;
  }
  if (ipsec_sa) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::tunneloffload::v1alpha1::IPSecSAParams>::GetOwningArena(ipsec_sa);
    if (message_arena != submessage_arena) {
      ipsec_sa = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ipsec_sa, submessage_arena);
    }
    
  } else {
    
  }
  ipsec_sa_ = ipsec_sa;
  // @@protoc_insertion_point(field_set_allocated:tunneloffload.v1alpha1.IPSecEnc.ipsec_sa)
}

// .tunneloffload.v1alpha1.IPV4Pair ipv4_tunnel = 4;
inline bool IPSecEnc::_internal_has_ipv4_tunnel() const {
  return tunnelIps_case() == kIpv4Tunnel;
}
inline bool IPSecEnc::has_ipv4_tunnel() const {
  return _internal_has_ipv4_tunnel();
}
inline void IPSecEnc::set_has_ipv4_tunnel() {
  _oneof_case_[0] = kIpv4Tunnel;
}
inline void IPSecEnc::clear_ipv4_tunnel() {
  if (_internal_has_ipv4_tunnel()) {
    if (GetArenaForAllocation() == nullptr) {
      delete tunnelIps_.ipv4_tunnel_;
    }
    clear_has_tunnelIps();
  }
}
inline ::tunneloffload::v1alpha1::IPV4Pair* IPSecEnc::release_ipv4_tunnel() {
  // @@protoc_insertion_point(field_release:tunneloffload.v1alpha1.IPSecEnc.ipv4_tunnel)
  if (_internal_has_ipv4_tunnel()) {
    clear_has_tunnelIps();
      ::tunneloffload::v1alpha1::IPV4Pair* temp = tunnelIps_.ipv4_tunnel_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    tunnelIps_.ipv4_tunnel_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tunneloffload::v1alpha1::IPV4Pair& IPSecEnc::_internal_ipv4_tunnel() const {
  return _internal_has_ipv4_tunnel()
      ? *tunnelIps_.ipv4_tunnel_
      : reinterpret_cast< ::tunneloffload::v1alpha1::IPV4Pair&>(::tunneloffload::v1alpha1::_IPV4Pair_default_instance_);
}
inline const ::tunneloffload::v1alpha1::IPV4Pair& IPSecEnc::ipv4_tunnel() const {
  // @@protoc_insertion_point(field_get:tunneloffload.v1alpha1.IPSecEnc.ipv4_tunnel)
  return _internal_ipv4_tunnel();
}
inline ::tunneloffload::v1alpha1::IPV4Pair* IPSecEnc::unsafe_arena_release_ipv4_tunnel() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tunneloffload.v1alpha1.IPSecEnc.ipv4_tunnel)
  if (_internal_has_ipv4_tunnel()) {
    clear_has_tunnelIps();
    ::tunneloffload::v1alpha1::IPV4Pair* temp = tunnelIps_.ipv4_tunnel_;
    tunnelIps_.ipv4_tunnel_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void IPSecEnc::unsafe_arena_set_allocated_ipv4_tunnel(::tunneloffload::v1alpha1::IPV4Pair* ipv4_tunnel) {
  clear_tunnelIps();
  if (ipv4_tunnel) {
    set_has_ipv4_tunnel();
    tunnelIps_.ipv4_tunnel_ = ipv4_tunnel;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tunneloffload.v1alpha1.IPSecEnc.ipv4_tunnel)
}
inline ::tunneloffload::v1alpha1::IPV4Pair* IPSecEnc::_internal_mutable_ipv4_tunnel() {
  if (!_internal_has_ipv4_tunnel()) {
    clear_tunnelIps();
    set_has_ipv4_tunnel();
    tunnelIps_.ipv4_tunnel_ = CreateMaybeMessage< ::tunneloffload::v1alpha1::IPV4Pair >(GetArenaForAllocation());
  }
  return tunnelIps_.ipv4_tunnel_;
}
inline ::tunneloffload::v1alpha1::IPV4Pair* IPSecEnc::mutable_ipv4_tunnel() {
  ::tunneloffload::v1alpha1::IPV4Pair* _msg = _internal_mutable_ipv4_tunnel();
  // @@protoc_insertion_point(field_mutable:tunneloffload.v1alpha1.IPSecEnc.ipv4_tunnel)
  return _msg;
}

// .tunneloffload.v1alpha1.IPV6Pair ipv6_tunnel = 5;
inline bool IPSecEnc::_internal_has_ipv6_tunnel() const {
  return tunnelIps_case() == kIpv6Tunnel;
}
inline bool IPSecEnc::has_ipv6_tunnel() const {
  return _internal_has_ipv6_tunnel();
}
inline void IPSecEnc::set_has_ipv6_tunnel() {
  _oneof_case_[0] = kIpv6Tunnel;
}
inline void IPSecEnc::clear_ipv6_tunnel() {
  if (_internal_has_ipv6_tunnel()) {
    if (GetArenaForAllocation() == nullptr) {
      delete tunnelIps_.ipv6_tunnel_;
    }
    clear_has_tunnelIps();
  }
}
inline ::tunneloffload::v1alpha1::IPV6Pair* IPSecEnc::release_ipv6_tunnel() {
  // @@protoc_insertion_point(field_release:tunneloffload.v1alpha1.IPSecEnc.ipv6_tunnel)
  if (_internal_has_ipv6_tunnel()) {
    clear_has_tunnelIps();
      ::tunneloffload::v1alpha1::IPV6Pair* temp = tunnelIps_.ipv6_tunnel_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    tunnelIps_.ipv6_tunnel_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tunneloffload::v1alpha1::IPV6Pair& IPSecEnc::_internal_ipv6_tunnel() const {
  return _internal_has_ipv6_tunnel()
      ? *tunnelIps_.ipv6_tunnel_
      : reinterpret_cast< ::tunneloffload::v1alpha1::IPV6Pair&>(::tunneloffload::v1alpha1::_IPV6Pair_default_instance_);
}
inline const ::tunneloffload::v1alpha1::IPV6Pair& IPSecEnc::ipv6_tunnel() const {
  // @@protoc_insertion_point(field_get:tunneloffload.v1alpha1.IPSecEnc.ipv6_tunnel)
  return _internal_ipv6_tunnel();
}
inline ::tunneloffload::v1alpha1::IPV6Pair* IPSecEnc::unsafe_arena_release_ipv6_tunnel() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tunneloffload.v1alpha1.IPSecEnc.ipv6_tunnel)
  if (_internal_has_ipv6_tunnel()) {
    clear_has_tunnelIps();
    ::tunneloffload::v1alpha1::IPV6Pair* temp = tunnelIps_.ipv6_tunnel_;
    tunnelIps_.ipv6_tunnel_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void IPSecEnc::unsafe_arena_set_allocated_ipv6_tunnel(::tunneloffload::v1alpha1::IPV6Pair* ipv6_tunnel) {
  clear_tunnelIps();
  if (ipv6_tunnel) {
    set_has_ipv6_tunnel();
    tunnelIps_.ipv6_tunnel_ = ipv6_tunnel;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tunneloffload.v1alpha1.IPSecEnc.ipv6_tunnel)
}
inline ::tunneloffload::v1alpha1::IPV6Pair* IPSecEnc::_internal_mutable_ipv6_tunnel() {
  if (!_internal_has_ipv6_tunnel()) {
    clear_tunnelIps();
    set_has_ipv6_tunnel();
    tunnelIps_.ipv6_tunnel_ = CreateMaybeMessage< ::tunneloffload::v1alpha1::IPV6Pair >(GetArenaForAllocation());
  }
  return tunnelIps_.ipv6_tunnel_;
}
inline ::tunneloffload::v1alpha1::IPV6Pair* IPSecEnc::mutable_ipv6_tunnel() {
  ::tunneloffload::v1alpha1::IPV6Pair* _msg = _internal_mutable_ipv6_tunnel();
  // @@protoc_insertion_point(field_mutable:tunneloffload.v1alpha1.IPSecEnc.ipv6_tunnel)
  return _msg;
}

inline bool IPSecEnc::has_tunnelIps() const {
  return tunnelIps_case() != TUNNELIPS_NOT_SET;
}
inline void IPSecEnc::clear_has_tunnelIps() {
  _oneof_case_[0] = TUNNELIPS_NOT_SET;
}
inline IPSecEnc::TunnelIpsCase IPSecEnc::tunnelIps_case() const {
  return IPSecEnc::TunnelIpsCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// IPSecDec

// .tunneloffload.v1alpha1.IPSecTunnelType tunnel_type = 1;
inline void IPSecDec::clear_tunnel_type() {
  tunnel_type_ = 0;
}
inline ::tunneloffload::v1alpha1::IPSecTunnelType IPSecDec::_internal_tunnel_type() const {
  return static_cast< ::tunneloffload::v1alpha1::IPSecTunnelType >(tunnel_type_);
}
inline ::tunneloffload::v1alpha1::IPSecTunnelType IPSecDec::tunnel_type() const {
  // @@protoc_insertion_point(field_get:tunneloffload.v1alpha1.IPSecDec.tunnel_type)
  return _internal_tunnel_type();
}
inline void IPSecDec::_internal_set_tunnel_type(::tunneloffload::v1alpha1::IPSecTunnelType value) {
  
  tunnel_type_ = value;
}
inline void IPSecDec::set_tunnel_type(::tunneloffload::v1alpha1::IPSecTunnelType value) {
  _internal_set_tunnel_type(value);
  // @@protoc_insertion_point(field_set:tunneloffload.v1alpha1.IPSecDec.tunnel_type)
}

// .tunneloffload.v1alpha1.EncType encryption_type = 2;
inline void IPSecDec::clear_encryption_type() {
  encryption_type_ = 0;
}
inline ::tunneloffload::v1alpha1::EncType IPSecDec::_internal_encryption_type() const {
  return static_cast< ::tunneloffload::v1alpha1::EncType >(encryption_type_);
}
inline ::tunneloffload::v1alpha1::EncType IPSecDec::encryption_type() const {
  // @@protoc_insertion_point(field_get:tunneloffload.v1alpha1.IPSecDec.encryption_type)
  return _internal_encryption_type();
}
inline void IPSecDec::_internal_set_encryption_type(::tunneloffload::v1alpha1::EncType value) {
  
  encryption_type_ = value;
}
inline void IPSecDec::set_encryption_type(::tunneloffload::v1alpha1::EncType value) {
  _internal_set_encryption_type(value);
  // @@protoc_insertion_point(field_set:tunneloffload.v1alpha1.IPSecDec.encryption_type)
}

// repeated .tunneloffload.v1alpha1.IPSecSAParams ipsec_sas = 3;
inline int IPSecDec::_internal_ipsec_sas_size() const {
  return ipsec_sas_.size();
}
inline int IPSecDec::ipsec_sas_size() const {
  return _internal_ipsec_sas_size();
}
inline void IPSecDec::clear_ipsec_sas() {
  ipsec_sas_.Clear();
}
inline ::tunneloffload::v1alpha1::IPSecSAParams* IPSecDec::mutable_ipsec_sas(int index) {
  // @@protoc_insertion_point(field_mutable:tunneloffload.v1alpha1.IPSecDec.ipsec_sas)
  return ipsec_sas_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tunneloffload::v1alpha1::IPSecSAParams >*
IPSecDec::mutable_ipsec_sas() {
  // @@protoc_insertion_point(field_mutable_list:tunneloffload.v1alpha1.IPSecDec.ipsec_sas)
  return &ipsec_sas_;
}
inline const ::tunneloffload::v1alpha1::IPSecSAParams& IPSecDec::_internal_ipsec_sas(int index) const {
  return ipsec_sas_.Get(index);
}
inline const ::tunneloffload::v1alpha1::IPSecSAParams& IPSecDec::ipsec_sas(int index) const {
  // @@protoc_insertion_point(field_get:tunneloffload.v1alpha1.IPSecDec.ipsec_sas)
  return _internal_ipsec_sas(index);
}
inline ::tunneloffload::v1alpha1::IPSecSAParams* IPSecDec::_internal_add_ipsec_sas() {
  return ipsec_sas_.Add();
}
inline ::tunneloffload::v1alpha1::IPSecSAParams* IPSecDec::add_ipsec_sas() {
  ::tunneloffload::v1alpha1::IPSecSAParams* _add = _internal_add_ipsec_sas();
  // @@protoc_insertion_point(field_add:tunneloffload.v1alpha1.IPSecDec.ipsec_sas)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tunneloffload::v1alpha1::IPSecSAParams >&
IPSecDec::ipsec_sas() const {
  // @@protoc_insertion_point(field_list:tunneloffload.v1alpha1.IPSecDec.ipsec_sas)
  return ipsec_sas_;
}

// -------------------------------------------------------------------

// IPSecSAParams

// uint32 spi = 1;
inline void IPSecSAParams::clear_spi() {
  spi_ = 0u;
}
inline uint32_t IPSecSAParams::_internal_spi() const {
  return spi_;
}
inline uint32_t IPSecSAParams::spi() const {
  // @@protoc_insertion_point(field_get:tunneloffload.v1alpha1.IPSecSAParams.spi)
  return _internal_spi();
}
inline void IPSecSAParams::_internal_set_spi(uint32_t value) {
  
  spi_ = value;
}
inline void IPSecSAParams::set_spi(uint32_t value) {
  _internal_set_spi(value);
  // @@protoc_insertion_point(field_set:tunneloffload.v1alpha1.IPSecSAParams.spi)
}

// bytes encryption_key = 2;
inline void IPSecSAParams::clear_encryption_key() {
  encryption_key_.ClearToEmpty();
}
inline const std::string& IPSecSAParams::encryption_key() const {
  // @@protoc_insertion_point(field_get:tunneloffload.v1alpha1.IPSecSAParams.encryption_key)
  return _internal_encryption_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IPSecSAParams::set_encryption_key(ArgT0&& arg0, ArgT... args) {
 
 encryption_key_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tunneloffload.v1alpha1.IPSecSAParams.encryption_key)
}
inline std::string* IPSecSAParams::mutable_encryption_key() {
  std::string* _s = _internal_mutable_encryption_key();
  // @@protoc_insertion_point(field_mutable:tunneloffload.v1alpha1.IPSecSAParams.encryption_key)
  return _s;
}
inline const std::string& IPSecSAParams::_internal_encryption_key() const {
  return encryption_key_.Get();
}
inline void IPSecSAParams::_internal_set_encryption_key(const std::string& value) {
  
  encryption_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* IPSecSAParams::_internal_mutable_encryption_key() {
  
  return encryption_key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* IPSecSAParams::release_encryption_key() {
  // @@protoc_insertion_point(field_release:tunneloffload.v1alpha1.IPSecSAParams.encryption_key)
  return encryption_key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void IPSecSAParams::set_allocated_encryption_key(std::string* encryption_key) {
  if (encryption_key != nullptr) {
    
  } else {
    
  }
  encryption_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), encryption_key,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (encryption_key_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    encryption_key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tunneloffload.v1alpha1.IPSecSAParams.encryption_key)
}

// .tunneloffload.v1alpha1.Operation operation = 3;
inline void IPSecSAParams::clear_operation() {
  operation_ = 0;
}
inline ::tunneloffload::v1alpha1::Operation IPSecSAParams::_internal_operation() const {
  return static_cast< ::tunneloffload::v1alpha1::Operation >(operation_);
}
inline ::tunneloffload::v1alpha1::Operation IPSecSAParams::operation() const {
  // @@protoc_insertion_point(field_get:tunneloffload.v1alpha1.IPSecSAParams.operation)
  return _internal_operation();
}
inline void IPSecSAParams::_internal_set_operation(::tunneloffload::v1alpha1::Operation value) {
  
  operation_ = value;
}
inline void IPSecSAParams::set_operation(::tunneloffload::v1alpha1::Operation value) {
  _internal_set_operation(value);
  // @@protoc_insertion_point(field_set:tunneloffload.v1alpha1.IPSecSAParams.operation)
}

// -------------------------------------------------------------------

// IPSecTunnel

// .tunneloffload.v1alpha1.IPSecEnc ipsec_enc = 1;
inline bool IPSecTunnel::_internal_has_ipsec_enc() const {
  return ipsec_case() == kIpsecEnc;
}
inline bool IPSecTunnel::has_ipsec_enc() const {
  return _internal_has_ipsec_enc();
}
inline void IPSecTunnel::set_has_ipsec_enc() {
  _oneof_case_[0] = kIpsecEnc;
}
inline void IPSecTunnel::clear_ipsec_enc() {
  if (_internal_has_ipsec_enc()) {
    if (GetArenaForAllocation() == nullptr) {
      delete ipsec_.ipsec_enc_;
    }
    clear_has_ipsec();
  }
}
inline ::tunneloffload::v1alpha1::IPSecEnc* IPSecTunnel::release_ipsec_enc() {
  // @@protoc_insertion_point(field_release:tunneloffload.v1alpha1.IPSecTunnel.ipsec_enc)
  if (_internal_has_ipsec_enc()) {
    clear_has_ipsec();
      ::tunneloffload::v1alpha1::IPSecEnc* temp = ipsec_.ipsec_enc_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    ipsec_.ipsec_enc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tunneloffload::v1alpha1::IPSecEnc& IPSecTunnel::_internal_ipsec_enc() const {
  return _internal_has_ipsec_enc()
      ? *ipsec_.ipsec_enc_
      : reinterpret_cast< ::tunneloffload::v1alpha1::IPSecEnc&>(::tunneloffload::v1alpha1::_IPSecEnc_default_instance_);
}
inline const ::tunneloffload::v1alpha1::IPSecEnc& IPSecTunnel::ipsec_enc() const {
  // @@protoc_insertion_point(field_get:tunneloffload.v1alpha1.IPSecTunnel.ipsec_enc)
  return _internal_ipsec_enc();
}
inline ::tunneloffload::v1alpha1::IPSecEnc* IPSecTunnel::unsafe_arena_release_ipsec_enc() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tunneloffload.v1alpha1.IPSecTunnel.ipsec_enc)
  if (_internal_has_ipsec_enc()) {
    clear_has_ipsec();
    ::tunneloffload::v1alpha1::IPSecEnc* temp = ipsec_.ipsec_enc_;
    ipsec_.ipsec_enc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void IPSecTunnel::unsafe_arena_set_allocated_ipsec_enc(::tunneloffload::v1alpha1::IPSecEnc* ipsec_enc) {
  clear_ipsec();
  if (ipsec_enc) {
    set_has_ipsec_enc();
    ipsec_.ipsec_enc_ = ipsec_enc;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tunneloffload.v1alpha1.IPSecTunnel.ipsec_enc)
}
inline ::tunneloffload::v1alpha1::IPSecEnc* IPSecTunnel::_internal_mutable_ipsec_enc() {
  if (!_internal_has_ipsec_enc()) {
    clear_ipsec();
    set_has_ipsec_enc();
    ipsec_.ipsec_enc_ = CreateMaybeMessage< ::tunneloffload::v1alpha1::IPSecEnc >(GetArenaForAllocation());
  }
  return ipsec_.ipsec_enc_;
}
inline ::tunneloffload::v1alpha1::IPSecEnc* IPSecTunnel::mutable_ipsec_enc() {
  ::tunneloffload::v1alpha1::IPSecEnc* _msg = _internal_mutable_ipsec_enc();
  // @@protoc_insertion_point(field_mutable:tunneloffload.v1alpha1.IPSecTunnel.ipsec_enc)
  return _msg;
}

// .tunneloffload.v1alpha1.IPSecDec ipsec_dec = 2;
inline bool IPSecTunnel::_internal_has_ipsec_dec() const {
  return ipsec_case() == kIpsecDec;
}
inline bool IPSecTunnel::has_ipsec_dec() const {
  return _internal_has_ipsec_dec();
}
inline void IPSecTunnel::set_has_ipsec_dec() {
  _oneof_case_[0] = kIpsecDec;
}
inline void IPSecTunnel::clear_ipsec_dec() {
  if (_internal_has_ipsec_dec()) {
    if (GetArenaForAllocation() == nullptr) {
      delete ipsec_.ipsec_dec_;
    }
    clear_has_ipsec();
  }
}
inline ::tunneloffload::v1alpha1::IPSecDec* IPSecTunnel::release_ipsec_dec() {
  // @@protoc_insertion_point(field_release:tunneloffload.v1alpha1.IPSecTunnel.ipsec_dec)
  if (_internal_has_ipsec_dec()) {
    clear_has_ipsec();
      ::tunneloffload::v1alpha1::IPSecDec* temp = ipsec_.ipsec_dec_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    ipsec_.ipsec_dec_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tunneloffload::v1alpha1::IPSecDec& IPSecTunnel::_internal_ipsec_dec() const {
  return _internal_has_ipsec_dec()
      ? *ipsec_.ipsec_dec_
      : reinterpret_cast< ::tunneloffload::v1alpha1::IPSecDec&>(::tunneloffload::v1alpha1::_IPSecDec_default_instance_);
}
inline const ::tunneloffload::v1alpha1::IPSecDec& IPSecTunnel::ipsec_dec() const {
  // @@protoc_insertion_point(field_get:tunneloffload.v1alpha1.IPSecTunnel.ipsec_dec)
  return _internal_ipsec_dec();
}
inline ::tunneloffload::v1alpha1::IPSecDec* IPSecTunnel::unsafe_arena_release_ipsec_dec() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tunneloffload.v1alpha1.IPSecTunnel.ipsec_dec)
  if (_internal_has_ipsec_dec()) {
    clear_has_ipsec();
    ::tunneloffload::v1alpha1::IPSecDec* temp = ipsec_.ipsec_dec_;
    ipsec_.ipsec_dec_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void IPSecTunnel::unsafe_arena_set_allocated_ipsec_dec(::tunneloffload::v1alpha1::IPSecDec* ipsec_dec) {
  clear_ipsec();
  if (ipsec_dec) {
    set_has_ipsec_dec();
    ipsec_.ipsec_dec_ = ipsec_dec;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tunneloffload.v1alpha1.IPSecTunnel.ipsec_dec)
}
inline ::tunneloffload::v1alpha1::IPSecDec* IPSecTunnel::_internal_mutable_ipsec_dec() {
  if (!_internal_has_ipsec_dec()) {
    clear_ipsec();
    set_has_ipsec_dec();
    ipsec_.ipsec_dec_ = CreateMaybeMessage< ::tunneloffload::v1alpha1::IPSecDec >(GetArenaForAllocation());
  }
  return ipsec_.ipsec_dec_;
}
inline ::tunneloffload::v1alpha1::IPSecDec* IPSecTunnel::mutable_ipsec_dec() {
  ::tunneloffload::v1alpha1::IPSecDec* _msg = _internal_mutable_ipsec_dec();
  // @@protoc_insertion_point(field_mutable:tunneloffload.v1alpha1.IPSecTunnel.ipsec_dec)
  return _msg;
}

inline bool IPSecTunnel::has_ipsec() const {
  return ipsec_case() != IPSEC_NOT_SET;
}
inline void IPSecTunnel::clear_has_ipsec() {
  _oneof_case_[0] = IPSEC_NOT_SET;
}
inline IPSecTunnel::IpsecCase IPSecTunnel::ipsec_case() const {
  return IPSecTunnel::IpsecCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// TunnelId

// uint64 tunnel_id = 1;
inline void TunnelId::clear_tunnel_id() {
  tunnel_id_ = uint64_t{0u};
}
inline uint64_t TunnelId::_internal_tunnel_id() const {
  return tunnel_id_;
}
inline uint64_t TunnelId::tunnel_id() const {
  // @@protoc_insertion_point(field_get:tunneloffload.v1alpha1.TunnelId.tunnel_id)
  return _internal_tunnel_id();
}
inline void TunnelId::_internal_set_tunnel_id(uint64_t value) {
  
  tunnel_id_ = value;
}
inline void TunnelId::set_tunnel_id(uint64_t value) {
  _internal_set_tunnel_id(value);
  // @@protoc_insertion_point(field_set:tunneloffload.v1alpha1.TunnelId.tunnel_id)
}

// -------------------------------------------------------------------

// Counters

// uint64 in_packets = 1;
inline void Counters::clear_in_packets() {
  in_packets_ = uint64_t{0u};
}
inline uint64_t Counters::_internal_in_packets() const {
  return in_packets_;
}
inline uint64_t Counters::in_packets() const {
  // @@protoc_insertion_point(field_get:tunneloffload.v1alpha1.Counters.in_packets)
  return _internal_in_packets();
}
inline void Counters::_internal_set_in_packets(uint64_t value) {
  
  in_packets_ = value;
}
inline void Counters::set_in_packets(uint64_t value) {
  _internal_set_in_packets(value);
  // @@protoc_insertion_point(field_set:tunneloffload.v1alpha1.Counters.in_packets)
}

// uint64 out_packets = 2;
inline void Counters::clear_out_packets() {
  out_packets_ = uint64_t{0u};
}
inline uint64_t Counters::_internal_out_packets() const {
  return out_packets_;
}
inline uint64_t Counters::out_packets() const {
  // @@protoc_insertion_point(field_get:tunneloffload.v1alpha1.Counters.out_packets)
  return _internal_out_packets();
}
inline void Counters::_internal_set_out_packets(uint64_t value) {
  
  out_packets_ = value;
}
inline void Counters::set_out_packets(uint64_t value) {
  _internal_set_out_packets(value);
  // @@protoc_insertion_point(field_set:tunneloffload.v1alpha1.Counters.out_packets)
}

// uint64 in_bytes = 3;
inline void Counters::clear_in_bytes() {
  in_bytes_ = uint64_t{0u};
}
inline uint64_t Counters::_internal_in_bytes() const {
  return in_bytes_;
}
inline uint64_t Counters::in_bytes() const {
  // @@protoc_insertion_point(field_get:tunneloffload.v1alpha1.Counters.in_bytes)
  return _internal_in_bytes();
}
inline void Counters::_internal_set_in_bytes(uint64_t value) {
  
  in_bytes_ = value;
}
inline void Counters::set_in_bytes(uint64_t value) {
  _internal_set_in_bytes(value);
  // @@protoc_insertion_point(field_set:tunneloffload.v1alpha1.Counters.in_bytes)
}

// uint64 out_bytes = 4;
inline void Counters::clear_out_bytes() {
  out_bytes_ = uint64_t{0u};
}
inline uint64_t Counters::_internal_out_bytes() const {
  return out_bytes_;
}
inline uint64_t Counters::out_bytes() const {
  // @@protoc_insertion_point(field_get:tunneloffload.v1alpha1.Counters.out_bytes)
  return _internal_out_bytes();
}
inline void Counters::_internal_set_out_bytes(uint64_t value) {
  
  out_bytes_ = value;
}
inline void Counters::set_out_bytes(uint64_t value) {
  _internal_set_out_bytes(value);
  // @@protoc_insertion_point(field_set:tunneloffload.v1alpha1.Counters.out_bytes)
}

// uint64 in_packets_drops = 5;
inline void Counters::clear_in_packets_drops() {
  in_packets_drops_ = uint64_t{0u};
}
inline uint64_t Counters::_internal_in_packets_drops() const {
  return in_packets_drops_;
}
inline uint64_t Counters::in_packets_drops() const {
  // @@protoc_insertion_point(field_get:tunneloffload.v1alpha1.Counters.in_packets_drops)
  return _internal_in_packets_drops();
}
inline void Counters::_internal_set_in_packets_drops(uint64_t value) {
  
  in_packets_drops_ = value;
}
inline void Counters::set_in_packets_drops(uint64_t value) {
  _internal_set_in_packets_drops(value);
  // @@protoc_insertion_point(field_set:tunneloffload.v1alpha1.Counters.in_packets_drops)
}

// uint64 out_packets_drops = 6;
inline void Counters::clear_out_packets_drops() {
  out_packets_drops_ = uint64_t{0u};
}
inline uint64_t Counters::_internal_out_packets_drops() const {
  return out_packets_drops_;
}
inline uint64_t Counters::out_packets_drops() const {
  // @@protoc_insertion_point(field_get:tunneloffload.v1alpha1.Counters.out_packets_drops)
  return _internal_out_packets_drops();
}
inline void Counters::_internal_set_out_packets_drops(uint64_t value) {
  
  out_packets_drops_ = value;
}
inline void Counters::set_out_packets_drops(uint64_t value) {
  _internal_set_out_packets_drops(value);
  // @@protoc_insertion_point(field_set:tunneloffload.v1alpha1.Counters.out_packets_drops)
}

// uint64 in_bytes_drops = 7;
inline void Counters::clear_in_bytes_drops() {
  in_bytes_drops_ = uint64_t{0u};
}
inline uint64_t Counters::_internal_in_bytes_drops() const {
  return in_bytes_drops_;
}
inline uint64_t Counters::in_bytes_drops() const {
  // @@protoc_insertion_point(field_get:tunneloffload.v1alpha1.Counters.in_bytes_drops)
  return _internal_in_bytes_drops();
}
inline void Counters::_internal_set_in_bytes_drops(uint64_t value) {
  
  in_bytes_drops_ = value;
}
inline void Counters::set_in_bytes_drops(uint64_t value) {
  _internal_set_in_bytes_drops(value);
  // @@protoc_insertion_point(field_set:tunneloffload.v1alpha1.Counters.in_bytes_drops)
}

// uint64 out_bytes_drops = 8;
inline void Counters::clear_out_bytes_drops() {
  out_bytes_drops_ = uint64_t{0u};
}
inline uint64_t Counters::_internal_out_bytes_drops() const {
  return out_bytes_drops_;
}
inline uint64_t Counters::out_bytes_drops() const {
  // @@protoc_insertion_point(field_get:tunneloffload.v1alpha1.Counters.out_bytes_drops)
  return _internal_out_bytes_drops();
}
inline void Counters::_internal_set_out_bytes_drops(uint64_t value) {
  
  out_bytes_drops_ = value;
}
inline void Counters::set_out_bytes_drops(uint64_t value) {
  _internal_set_out_bytes_drops(value);
  // @@protoc_insertion_point(field_set:tunneloffload.v1alpha1.Counters.out_bytes_drops)
}

// -------------------------------------------------------------------

// CreateIpTunnelResponses

// .tunneloffload.v1alpha1.AddTunnelStatus request_status = 1;
inline void CreateIpTunnelResponses::clear_request_status() {
  request_status_ = 0;
}
inline ::tunneloffload::v1alpha1::AddTunnelStatus CreateIpTunnelResponses::_internal_request_status() const {
  return static_cast< ::tunneloffload::v1alpha1::AddTunnelStatus >(request_status_);
}
inline ::tunneloffload::v1alpha1::AddTunnelStatus CreateIpTunnelResponses::request_status() const {
  // @@protoc_insertion_point(field_get:tunneloffload.v1alpha1.CreateIpTunnelResponses.request_status)
  return _internal_request_status();
}
inline void CreateIpTunnelResponses::_internal_set_request_status(::tunneloffload::v1alpha1::AddTunnelStatus value) {
  
  request_status_ = value;
}
inline void CreateIpTunnelResponses::set_request_status(::tunneloffload::v1alpha1::AddTunnelStatus value) {
  _internal_set_request_status(value);
  // @@protoc_insertion_point(field_set:tunneloffload.v1alpha1.CreateIpTunnelResponses.request_status)
}

// uint64 error_status = 2;
inline void CreateIpTunnelResponses::clear_error_status() {
  error_status_ = uint64_t{0u};
}
inline uint64_t CreateIpTunnelResponses::_internal_error_status() const {
  return error_status_;
}
inline uint64_t CreateIpTunnelResponses::error_status() const {
  // @@protoc_insertion_point(field_get:tunneloffload.v1alpha1.CreateIpTunnelResponses.error_status)
  return _internal_error_status();
}
inline void CreateIpTunnelResponses::_internal_set_error_status(uint64_t value) {
  
  error_status_ = value;
}
inline void CreateIpTunnelResponses::set_error_status(uint64_t value) {
  _internal_set_error_status(value);
  // @@protoc_insertion_point(field_set:tunneloffload.v1alpha1.CreateIpTunnelResponses.error_status)
}

// repeated .tunneloffload.v1alpha1.CreateIpTunnelResponse responses = 3;
inline int CreateIpTunnelResponses::_internal_responses_size() const {
  return responses_.size();
}
inline int CreateIpTunnelResponses::responses_size() const {
  return _internal_responses_size();
}
inline void CreateIpTunnelResponses::clear_responses() {
  responses_.Clear();
}
inline ::tunneloffload::v1alpha1::CreateIpTunnelResponse* CreateIpTunnelResponses::mutable_responses(int index) {
  // @@protoc_insertion_point(field_mutable:tunneloffload.v1alpha1.CreateIpTunnelResponses.responses)
  return responses_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tunneloffload::v1alpha1::CreateIpTunnelResponse >*
CreateIpTunnelResponses::mutable_responses() {
  // @@protoc_insertion_point(field_mutable_list:tunneloffload.v1alpha1.CreateIpTunnelResponses.responses)
  return &responses_;
}
inline const ::tunneloffload::v1alpha1::CreateIpTunnelResponse& CreateIpTunnelResponses::_internal_responses(int index) const {
  return responses_.Get(index);
}
inline const ::tunneloffload::v1alpha1::CreateIpTunnelResponse& CreateIpTunnelResponses::responses(int index) const {
  // @@protoc_insertion_point(field_get:tunneloffload.v1alpha1.CreateIpTunnelResponses.responses)
  return _internal_responses(index);
}
inline ::tunneloffload::v1alpha1::CreateIpTunnelResponse* CreateIpTunnelResponses::_internal_add_responses() {
  return responses_.Add();
}
inline ::tunneloffload::v1alpha1::CreateIpTunnelResponse* CreateIpTunnelResponses::add_responses() {
  ::tunneloffload::v1alpha1::CreateIpTunnelResponse* _add = _internal_add_responses();
  // @@protoc_insertion_point(field_add:tunneloffload.v1alpha1.CreateIpTunnelResponses.responses)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tunneloffload::v1alpha1::CreateIpTunnelResponse >&
CreateIpTunnelResponses::responses() const {
  // @@protoc_insertion_point(field_list:tunneloffload.v1alpha1.CreateIpTunnelResponses.responses)
  return responses_;
}

// -------------------------------------------------------------------

// CreateIpTunnelResponse

// uint64 tunnel_id = 1;
inline void CreateIpTunnelResponse::clear_tunnel_id() {
  tunnel_id_ = uint64_t{0u};
}
inline uint64_t CreateIpTunnelResponse::_internal_tunnel_id() const {
  return tunnel_id_;
}
inline uint64_t CreateIpTunnelResponse::tunnel_id() const {
  // @@protoc_insertion_point(field_get:tunneloffload.v1alpha1.CreateIpTunnelResponse.tunnel_id)
  return _internal_tunnel_id();
}
inline void CreateIpTunnelResponse::_internal_set_tunnel_id(uint64_t value) {
  
  tunnel_id_ = value;
}
inline void CreateIpTunnelResponse::set_tunnel_id(uint64_t value) {
  _internal_set_tunnel_id(value);
  // @@protoc_insertion_point(field_set:tunneloffload.v1alpha1.CreateIpTunnelResponse.tunnel_id)
}

// .tunneloffload.v1alpha1.Error error = 2;
inline bool CreateIpTunnelResponse::_internal_has_error() const {
  return this != internal_default_instance() && error_ != nullptr;
}
inline bool CreateIpTunnelResponse::has_error() const {
  return _internal_has_error();
}
inline void CreateIpTunnelResponse::clear_error() {
  if (GetArenaForAllocation() == nullptr && error_ != nullptr) {
    delete error_;
  }
  error_ = nullptr;
}
inline const ::tunneloffload::v1alpha1::Error& CreateIpTunnelResponse::_internal_error() const {
  const ::tunneloffload::v1alpha1::Error* p = error_;
  return p != nullptr ? *p : reinterpret_cast<const ::tunneloffload::v1alpha1::Error&>(
      ::tunneloffload::v1alpha1::_Error_default_instance_);
}
inline const ::tunneloffload::v1alpha1::Error& CreateIpTunnelResponse::error() const {
  // @@protoc_insertion_point(field_get:tunneloffload.v1alpha1.CreateIpTunnelResponse.error)
  return _internal_error();
}
inline void CreateIpTunnelResponse::unsafe_arena_set_allocated_error(
    ::tunneloffload::v1alpha1::Error* error) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(error_);
  }
  error_ = error;
  if (error) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tunneloffload.v1alpha1.CreateIpTunnelResponse.error)
}
inline ::tunneloffload::v1alpha1::Error* CreateIpTunnelResponse::release_error() {
  
  ::tunneloffload::v1alpha1::Error* temp = error_;
  error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tunneloffload::v1alpha1::Error* CreateIpTunnelResponse::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_release:tunneloffload.v1alpha1.CreateIpTunnelResponse.error)
  
  ::tunneloffload::v1alpha1::Error* temp = error_;
  error_ = nullptr;
  return temp;
}
inline ::tunneloffload::v1alpha1::Error* CreateIpTunnelResponse::_internal_mutable_error() {
  
  if (error_ == nullptr) {
    auto* p = CreateMaybeMessage<::tunneloffload::v1alpha1::Error>(GetArenaForAllocation());
    error_ = p;
  }
  return error_;
}
inline ::tunneloffload::v1alpha1::Error* CreateIpTunnelResponse::mutable_error() {
  ::tunneloffload::v1alpha1::Error* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:tunneloffload.v1alpha1.CreateIpTunnelResponse.error)
  return _msg;
}
inline void CreateIpTunnelResponse::set_allocated_error(::tunneloffload::v1alpha1::Error* error) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete error_;
  }
  if (error) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::tunneloffload::v1alpha1::Error>::GetOwningArena(error);
    if (message_arena != submessage_arena) {
      error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    
  } else {
    
  }
  error_ = error;
  // @@protoc_insertion_point(field_set_allocated:tunneloffload.v1alpha1.CreateIpTunnelResponse.error)
}

// -------------------------------------------------------------------

// Error

// .tunneloffload.v1alpha1.TunnelAdditionError error_message = 1;
inline bool Error::_internal_has_error_message() const {
  return this != internal_default_instance() && error_message_ != nullptr;
}
inline bool Error::has_error_message() const {
  return _internal_has_error_message();
}
inline void Error::clear_error_message() {
  if (GetArenaForAllocation() == nullptr && error_message_ != nullptr) {
    delete error_message_;
  }
  error_message_ = nullptr;
}
inline const ::tunneloffload::v1alpha1::TunnelAdditionError& Error::_internal_error_message() const {
  const ::tunneloffload::v1alpha1::TunnelAdditionError* p = error_message_;
  return p != nullptr ? *p : reinterpret_cast<const ::tunneloffload::v1alpha1::TunnelAdditionError&>(
      ::tunneloffload::v1alpha1::_TunnelAdditionError_default_instance_);
}
inline const ::tunneloffload::v1alpha1::TunnelAdditionError& Error::error_message() const {
  // @@protoc_insertion_point(field_get:tunneloffload.v1alpha1.Error.error_message)
  return _internal_error_message();
}
inline void Error::unsafe_arena_set_allocated_error_message(
    ::tunneloffload::v1alpha1::TunnelAdditionError* error_message) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(error_message_);
  }
  error_message_ = error_message;
  if (error_message) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tunneloffload.v1alpha1.Error.error_message)
}
inline ::tunneloffload::v1alpha1::TunnelAdditionError* Error::release_error_message() {
  
  ::tunneloffload::v1alpha1::TunnelAdditionError* temp = error_message_;
  error_message_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tunneloffload::v1alpha1::TunnelAdditionError* Error::unsafe_arena_release_error_message() {
  // @@protoc_insertion_point(field_release:tunneloffload.v1alpha1.Error.error_message)
  
  ::tunneloffload::v1alpha1::TunnelAdditionError* temp = error_message_;
  error_message_ = nullptr;
  return temp;
}
inline ::tunneloffload::v1alpha1::TunnelAdditionError* Error::_internal_mutable_error_message() {
  
  if (error_message_ == nullptr) {
    auto* p = CreateMaybeMessage<::tunneloffload::v1alpha1::TunnelAdditionError>(GetArenaForAllocation());
    error_message_ = p;
  }
  return error_message_;
}
inline ::tunneloffload::v1alpha1::TunnelAdditionError* Error::mutable_error_message() {
  ::tunneloffload::v1alpha1::TunnelAdditionError* _msg = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:tunneloffload.v1alpha1.Error.error_message)
  return _msg;
}
inline void Error::set_allocated_error_message(::tunneloffload::v1alpha1::TunnelAdditionError* error_message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete error_message_;
  }
  if (error_message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::tunneloffload::v1alpha1::TunnelAdditionError>::GetOwningArena(error_message);
    if (message_arena != submessage_arena) {
      error_message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, error_message, submessage_arena);
    }
    
  } else {
    
  }
  error_message_ = error_message;
  // @@protoc_insertion_point(field_set_allocated:tunneloffload.v1alpha1.Error.error_message)
}

// string error_string = 2;
inline void Error::clear_error_string() {
  error_string_.ClearToEmpty();
}
inline const std::string& Error::error_string() const {
  // @@protoc_insertion_point(field_get:tunneloffload.v1alpha1.Error.error_string)
  return _internal_error_string();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Error::set_error_string(ArgT0&& arg0, ArgT... args) {
 
 error_string_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tunneloffload.v1alpha1.Error.error_string)
}
inline std::string* Error::mutable_error_string() {
  std::string* _s = _internal_mutable_error_string();
  // @@protoc_insertion_point(field_mutable:tunneloffload.v1alpha1.Error.error_string)
  return _s;
}
inline const std::string& Error::_internal_error_string() const {
  return error_string_.Get();
}
inline void Error::_internal_set_error_string(const std::string& value) {
  
  error_string_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Error::_internal_mutable_error_string() {
  
  return error_string_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Error::release_error_string() {
  // @@protoc_insertion_point(field_release:tunneloffload.v1alpha1.Error.error_string)
  return error_string_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Error::set_allocated_error_string(std::string* error_string) {
  if (error_string != nullptr) {
    
  } else {
    
  }
  error_string_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error_string,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (error_string_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    error_string_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tunneloffload.v1alpha1.Error.error_string)
}

// -------------------------------------------------------------------

// IpTunnelResponses

// repeated .tunneloffload.v1alpha1.IpTunnelResponse responses = 1;
inline int IpTunnelResponses::_internal_responses_size() const {
  return responses_.size();
}
inline int IpTunnelResponses::responses_size() const {
  return _internal_responses_size();
}
inline void IpTunnelResponses::clear_responses() {
  responses_.Clear();
}
inline ::tunneloffload::v1alpha1::IpTunnelResponse* IpTunnelResponses::mutable_responses(int index) {
  // @@protoc_insertion_point(field_mutable:tunneloffload.v1alpha1.IpTunnelResponses.responses)
  return responses_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tunneloffload::v1alpha1::IpTunnelResponse >*
IpTunnelResponses::mutable_responses() {
  // @@protoc_insertion_point(field_mutable_list:tunneloffload.v1alpha1.IpTunnelResponses.responses)
  return &responses_;
}
inline const ::tunneloffload::v1alpha1::IpTunnelResponse& IpTunnelResponses::_internal_responses(int index) const {
  return responses_.Get(index);
}
inline const ::tunneloffload::v1alpha1::IpTunnelResponse& IpTunnelResponses::responses(int index) const {
  // @@protoc_insertion_point(field_get:tunneloffload.v1alpha1.IpTunnelResponses.responses)
  return _internal_responses(index);
}
inline ::tunneloffload::v1alpha1::IpTunnelResponse* IpTunnelResponses::_internal_add_responses() {
  return responses_.Add();
}
inline ::tunneloffload::v1alpha1::IpTunnelResponse* IpTunnelResponses::add_responses() {
  ::tunneloffload::v1alpha1::IpTunnelResponse* _add = _internal_add_responses();
  // @@protoc_insertion_point(field_add:tunneloffload.v1alpha1.IpTunnelResponses.responses)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tunneloffload::v1alpha1::IpTunnelResponse >&
IpTunnelResponses::responses() const {
  // @@protoc_insertion_point(field_list:tunneloffload.v1alpha1.IpTunnelResponses.responses)
  return responses_;
}

// -------------------------------------------------------------------

// IpTunnelResponse

// uint64 tunnel_id = 1;
inline void IpTunnelResponse::clear_tunnel_id() {
  tunnel_id_ = uint64_t{0u};
}
inline uint64_t IpTunnelResponse::_internal_tunnel_id() const {
  return tunnel_id_;
}
inline uint64_t IpTunnelResponse::tunnel_id() const {
  // @@protoc_insertion_point(field_get:tunneloffload.v1alpha1.IpTunnelResponse.tunnel_id)
  return _internal_tunnel_id();
}
inline void IpTunnelResponse::_internal_set_tunnel_id(uint64_t value) {
  
  tunnel_id_ = value;
}
inline void IpTunnelResponse::set_tunnel_id(uint64_t value) {
  _internal_set_tunnel_id(value);
  // @@protoc_insertion_point(field_set:tunneloffload.v1alpha1.IpTunnelResponse.tunnel_id)
}

// .tunneloffload.v1alpha1.IpTunnelRequest ip_tunnel = 2;
inline bool IpTunnelResponse::_internal_has_ip_tunnel() const {
  return this != internal_default_instance() && ip_tunnel_ != nullptr;
}
inline bool IpTunnelResponse::has_ip_tunnel() const {
  return _internal_has_ip_tunnel();
}
inline void IpTunnelResponse::clear_ip_tunnel() {
  if (GetArenaForAllocation() == nullptr && ip_tunnel_ != nullptr) {
    delete ip_tunnel_;
  }
  ip_tunnel_ = nullptr;
}
inline const ::tunneloffload::v1alpha1::IpTunnelRequest& IpTunnelResponse::_internal_ip_tunnel() const {
  const ::tunneloffload::v1alpha1::IpTunnelRequest* p = ip_tunnel_;
  return p != nullptr ? *p : reinterpret_cast<const ::tunneloffload::v1alpha1::IpTunnelRequest&>(
      ::tunneloffload::v1alpha1::_IpTunnelRequest_default_instance_);
}
inline const ::tunneloffload::v1alpha1::IpTunnelRequest& IpTunnelResponse::ip_tunnel() const {
  // @@protoc_insertion_point(field_get:tunneloffload.v1alpha1.IpTunnelResponse.ip_tunnel)
  return _internal_ip_tunnel();
}
inline void IpTunnelResponse::unsafe_arena_set_allocated_ip_tunnel(
    ::tunneloffload::v1alpha1::IpTunnelRequest* ip_tunnel) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ip_tunnel_);
  }
  ip_tunnel_ = ip_tunnel;
  if (ip_tunnel) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tunneloffload.v1alpha1.IpTunnelResponse.ip_tunnel)
}
inline ::tunneloffload::v1alpha1::IpTunnelRequest* IpTunnelResponse::release_ip_tunnel() {
  
  ::tunneloffload::v1alpha1::IpTunnelRequest* temp = ip_tunnel_;
  ip_tunnel_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tunneloffload::v1alpha1::IpTunnelRequest* IpTunnelResponse::unsafe_arena_release_ip_tunnel() {
  // @@protoc_insertion_point(field_release:tunneloffload.v1alpha1.IpTunnelResponse.ip_tunnel)
  
  ::tunneloffload::v1alpha1::IpTunnelRequest* temp = ip_tunnel_;
  ip_tunnel_ = nullptr;
  return temp;
}
inline ::tunneloffload::v1alpha1::IpTunnelRequest* IpTunnelResponse::_internal_mutable_ip_tunnel() {
  
  if (ip_tunnel_ == nullptr) {
    auto* p = CreateMaybeMessage<::tunneloffload::v1alpha1::IpTunnelRequest>(GetArenaForAllocation());
    ip_tunnel_ = p;
  }
  return ip_tunnel_;
}
inline ::tunneloffload::v1alpha1::IpTunnelRequest* IpTunnelResponse::mutable_ip_tunnel() {
  ::tunneloffload::v1alpha1::IpTunnelRequest* _msg = _internal_mutable_ip_tunnel();
  // @@protoc_insertion_point(field_mutable:tunneloffload.v1alpha1.IpTunnelResponse.ip_tunnel)
  return _msg;
}
inline void IpTunnelResponse::set_allocated_ip_tunnel(::tunneloffload::v1alpha1::IpTunnelRequest* ip_tunnel) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete ip_tunnel_;
  }
  if (ip_tunnel) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::tunneloffload::v1alpha1::IpTunnelRequest>::GetOwningArena(ip_tunnel);
    if (message_arena != submessage_arena) {
      ip_tunnel = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ip_tunnel, submessage_arena);
    }
    
  } else {
    
  }
  ip_tunnel_ = ip_tunnel;
  // @@protoc_insertion_point(field_set_allocated:tunneloffload.v1alpha1.IpTunnelResponse.ip_tunnel)
}

// .tunneloffload.v1alpha1.Counters tunnel_counters = 3;
inline bool IpTunnelResponse::_internal_has_tunnel_counters() const {
  return this != internal_default_instance() && tunnel_counters_ != nullptr;
}
inline bool IpTunnelResponse::has_tunnel_counters() const {
  return _internal_has_tunnel_counters();
}
inline void IpTunnelResponse::clear_tunnel_counters() {
  if (GetArenaForAllocation() == nullptr && tunnel_counters_ != nullptr) {
    delete tunnel_counters_;
  }
  tunnel_counters_ = nullptr;
}
inline const ::tunneloffload::v1alpha1::Counters& IpTunnelResponse::_internal_tunnel_counters() const {
  const ::tunneloffload::v1alpha1::Counters* p = tunnel_counters_;
  return p != nullptr ? *p : reinterpret_cast<const ::tunneloffload::v1alpha1::Counters&>(
      ::tunneloffload::v1alpha1::_Counters_default_instance_);
}
inline const ::tunneloffload::v1alpha1::Counters& IpTunnelResponse::tunnel_counters() const {
  // @@protoc_insertion_point(field_get:tunneloffload.v1alpha1.IpTunnelResponse.tunnel_counters)
  return _internal_tunnel_counters();
}
inline void IpTunnelResponse::unsafe_arena_set_allocated_tunnel_counters(
    ::tunneloffload::v1alpha1::Counters* tunnel_counters) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(tunnel_counters_);
  }
  tunnel_counters_ = tunnel_counters;
  if (tunnel_counters) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tunneloffload.v1alpha1.IpTunnelResponse.tunnel_counters)
}
inline ::tunneloffload::v1alpha1::Counters* IpTunnelResponse::release_tunnel_counters() {
  
  ::tunneloffload::v1alpha1::Counters* temp = tunnel_counters_;
  tunnel_counters_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tunneloffload::v1alpha1::Counters* IpTunnelResponse::unsafe_arena_release_tunnel_counters() {
  // @@protoc_insertion_point(field_release:tunneloffload.v1alpha1.IpTunnelResponse.tunnel_counters)
  
  ::tunneloffload::v1alpha1::Counters* temp = tunnel_counters_;
  tunnel_counters_ = nullptr;
  return temp;
}
inline ::tunneloffload::v1alpha1::Counters* IpTunnelResponse::_internal_mutable_tunnel_counters() {
  
  if (tunnel_counters_ == nullptr) {
    auto* p = CreateMaybeMessage<::tunneloffload::v1alpha1::Counters>(GetArenaForAllocation());
    tunnel_counters_ = p;
  }
  return tunnel_counters_;
}
inline ::tunneloffload::v1alpha1::Counters* IpTunnelResponse::mutable_tunnel_counters() {
  ::tunneloffload::v1alpha1::Counters* _msg = _internal_mutable_tunnel_counters();
  // @@protoc_insertion_point(field_mutable:tunneloffload.v1alpha1.IpTunnelResponse.tunnel_counters)
  return _msg;
}
inline void IpTunnelResponse::set_allocated_tunnel_counters(::tunneloffload::v1alpha1::Counters* tunnel_counters) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete tunnel_counters_;
  }
  if (tunnel_counters) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::tunneloffload::v1alpha1::Counters>::GetOwningArena(tunnel_counters);
    if (message_arena != submessage_arena) {
      tunnel_counters = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tunnel_counters, submessage_arena);
    }
    
  } else {
    
  }
  tunnel_counters_ = tunnel_counters;
  // @@protoc_insertion_point(field_set_allocated:tunneloffload.v1alpha1.IpTunnelResponse.tunnel_counters)
}

// .tunneloffload.v1alpha1.Error error = 4;
inline bool IpTunnelResponse::_internal_has_error() const {
  return this != internal_default_instance() && error_ != nullptr;
}
inline bool IpTunnelResponse::has_error() const {
  return _internal_has_error();
}
inline void IpTunnelResponse::clear_error() {
  if (GetArenaForAllocation() == nullptr && error_ != nullptr) {
    delete error_;
  }
  error_ = nullptr;
}
inline const ::tunneloffload::v1alpha1::Error& IpTunnelResponse::_internal_error() const {
  const ::tunneloffload::v1alpha1::Error* p = error_;
  return p != nullptr ? *p : reinterpret_cast<const ::tunneloffload::v1alpha1::Error&>(
      ::tunneloffload::v1alpha1::_Error_default_instance_);
}
inline const ::tunneloffload::v1alpha1::Error& IpTunnelResponse::error() const {
  // @@protoc_insertion_point(field_get:tunneloffload.v1alpha1.IpTunnelResponse.error)
  return _internal_error();
}
inline void IpTunnelResponse::unsafe_arena_set_allocated_error(
    ::tunneloffload::v1alpha1::Error* error) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(error_);
  }
  error_ = error;
  if (error) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tunneloffload.v1alpha1.IpTunnelResponse.error)
}
inline ::tunneloffload::v1alpha1::Error* IpTunnelResponse::release_error() {
  
  ::tunneloffload::v1alpha1::Error* temp = error_;
  error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tunneloffload::v1alpha1::Error* IpTunnelResponse::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_release:tunneloffload.v1alpha1.IpTunnelResponse.error)
  
  ::tunneloffload::v1alpha1::Error* temp = error_;
  error_ = nullptr;
  return temp;
}
inline ::tunneloffload::v1alpha1::Error* IpTunnelResponse::_internal_mutable_error() {
  
  if (error_ == nullptr) {
    auto* p = CreateMaybeMessage<::tunneloffload::v1alpha1::Error>(GetArenaForAllocation());
    error_ = p;
  }
  return error_;
}
inline ::tunneloffload::v1alpha1::Error* IpTunnelResponse::mutable_error() {
  ::tunneloffload::v1alpha1::Error* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:tunneloffload.v1alpha1.IpTunnelResponse.error)
  return _msg;
}
inline void IpTunnelResponse::set_allocated_error(::tunneloffload::v1alpha1::Error* error) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete error_;
  }
  if (error) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::tunneloffload::v1alpha1::Error>::GetOwningArena(error);
    if (message_arena != submessage_arena) {
      error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    
  } else {
    
  }
  error_ = error;
  // @@protoc_insertion_point(field_set_allocated:tunneloffload.v1alpha1.IpTunnelResponse.error)
}

// -------------------------------------------------------------------

// IpTunnelStatsResponses

// repeated .tunneloffload.v1alpha1.IpTunnelStatsResponse responses = 1;
inline int IpTunnelStatsResponses::_internal_responses_size() const {
  return responses_.size();
}
inline int IpTunnelStatsResponses::responses_size() const {
  return _internal_responses_size();
}
inline void IpTunnelStatsResponses::clear_responses() {
  responses_.Clear();
}
inline ::tunneloffload::v1alpha1::IpTunnelStatsResponse* IpTunnelStatsResponses::mutable_responses(int index) {
  // @@protoc_insertion_point(field_mutable:tunneloffload.v1alpha1.IpTunnelStatsResponses.responses)
  return responses_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tunneloffload::v1alpha1::IpTunnelStatsResponse >*
IpTunnelStatsResponses::mutable_responses() {
  // @@protoc_insertion_point(field_mutable_list:tunneloffload.v1alpha1.IpTunnelStatsResponses.responses)
  return &responses_;
}
inline const ::tunneloffload::v1alpha1::IpTunnelStatsResponse& IpTunnelStatsResponses::_internal_responses(int index) const {
  return responses_.Get(index);
}
inline const ::tunneloffload::v1alpha1::IpTunnelStatsResponse& IpTunnelStatsResponses::responses(int index) const {
  // @@protoc_insertion_point(field_get:tunneloffload.v1alpha1.IpTunnelStatsResponses.responses)
  return _internal_responses(index);
}
inline ::tunneloffload::v1alpha1::IpTunnelStatsResponse* IpTunnelStatsResponses::_internal_add_responses() {
  return responses_.Add();
}
inline ::tunneloffload::v1alpha1::IpTunnelStatsResponse* IpTunnelStatsResponses::add_responses() {
  ::tunneloffload::v1alpha1::IpTunnelStatsResponse* _add = _internal_add_responses();
  // @@protoc_insertion_point(field_add:tunneloffload.v1alpha1.IpTunnelStatsResponses.responses)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tunneloffload::v1alpha1::IpTunnelStatsResponse >&
IpTunnelStatsResponses::responses() const {
  // @@protoc_insertion_point(field_list:tunneloffload.v1alpha1.IpTunnelStatsResponses.responses)
  return responses_;
}

// -------------------------------------------------------------------

// IpTunnelStatsResponse

// uint64 tunnel_id = 1;
inline void IpTunnelStatsResponse::clear_tunnel_id() {
  tunnel_id_ = uint64_t{0u};
}
inline uint64_t IpTunnelStatsResponse::_internal_tunnel_id() const {
  return tunnel_id_;
}
inline uint64_t IpTunnelStatsResponse::tunnel_id() const {
  // @@protoc_insertion_point(field_get:tunneloffload.v1alpha1.IpTunnelStatsResponse.tunnel_id)
  return _internal_tunnel_id();
}
inline void IpTunnelStatsResponse::_internal_set_tunnel_id(uint64_t value) {
  
  tunnel_id_ = value;
}
inline void IpTunnelStatsResponse::set_tunnel_id(uint64_t value) {
  _internal_set_tunnel_id(value);
  // @@protoc_insertion_point(field_set:tunneloffload.v1alpha1.IpTunnelStatsResponse.tunnel_id)
}

// .tunneloffload.v1alpha1.Counters tunnel_counters = 2;
inline bool IpTunnelStatsResponse::_internal_has_tunnel_counters() const {
  return this != internal_default_instance() && tunnel_counters_ != nullptr;
}
inline bool IpTunnelStatsResponse::has_tunnel_counters() const {
  return _internal_has_tunnel_counters();
}
inline void IpTunnelStatsResponse::clear_tunnel_counters() {
  if (GetArenaForAllocation() == nullptr && tunnel_counters_ != nullptr) {
    delete tunnel_counters_;
  }
  tunnel_counters_ = nullptr;
}
inline const ::tunneloffload::v1alpha1::Counters& IpTunnelStatsResponse::_internal_tunnel_counters() const {
  const ::tunneloffload::v1alpha1::Counters* p = tunnel_counters_;
  return p != nullptr ? *p : reinterpret_cast<const ::tunneloffload::v1alpha1::Counters&>(
      ::tunneloffload::v1alpha1::_Counters_default_instance_);
}
inline const ::tunneloffload::v1alpha1::Counters& IpTunnelStatsResponse::tunnel_counters() const {
  // @@protoc_insertion_point(field_get:tunneloffload.v1alpha1.IpTunnelStatsResponse.tunnel_counters)
  return _internal_tunnel_counters();
}
inline void IpTunnelStatsResponse::unsafe_arena_set_allocated_tunnel_counters(
    ::tunneloffload::v1alpha1::Counters* tunnel_counters) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(tunnel_counters_);
  }
  tunnel_counters_ = tunnel_counters;
  if (tunnel_counters) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tunneloffload.v1alpha1.IpTunnelStatsResponse.tunnel_counters)
}
inline ::tunneloffload::v1alpha1::Counters* IpTunnelStatsResponse::release_tunnel_counters() {
  
  ::tunneloffload::v1alpha1::Counters* temp = tunnel_counters_;
  tunnel_counters_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tunneloffload::v1alpha1::Counters* IpTunnelStatsResponse::unsafe_arena_release_tunnel_counters() {
  // @@protoc_insertion_point(field_release:tunneloffload.v1alpha1.IpTunnelStatsResponse.tunnel_counters)
  
  ::tunneloffload::v1alpha1::Counters* temp = tunnel_counters_;
  tunnel_counters_ = nullptr;
  return temp;
}
inline ::tunneloffload::v1alpha1::Counters* IpTunnelStatsResponse::_internal_mutable_tunnel_counters() {
  
  if (tunnel_counters_ == nullptr) {
    auto* p = CreateMaybeMessage<::tunneloffload::v1alpha1::Counters>(GetArenaForAllocation());
    tunnel_counters_ = p;
  }
  return tunnel_counters_;
}
inline ::tunneloffload::v1alpha1::Counters* IpTunnelStatsResponse::mutable_tunnel_counters() {
  ::tunneloffload::v1alpha1::Counters* _msg = _internal_mutable_tunnel_counters();
  // @@protoc_insertion_point(field_mutable:tunneloffload.v1alpha1.IpTunnelStatsResponse.tunnel_counters)
  return _msg;
}
inline void IpTunnelStatsResponse::set_allocated_tunnel_counters(::tunneloffload::v1alpha1::Counters* tunnel_counters) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete tunnel_counters_;
  }
  if (tunnel_counters) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::tunneloffload::v1alpha1::Counters>::GetOwningArena(tunnel_counters);
    if (message_arena != submessage_arena) {
      tunnel_counters = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tunnel_counters, submessage_arena);
    }
    
  } else {
    
  }
  tunnel_counters_ = tunnel_counters;
  // @@protoc_insertion_point(field_set_allocated:tunneloffload.v1alpha1.IpTunnelStatsResponse.tunnel_counters)
}

// .tunneloffload.v1alpha1.Error error = 3;
inline bool IpTunnelStatsResponse::_internal_has_error() const {
  return this != internal_default_instance() && error_ != nullptr;
}
inline bool IpTunnelStatsResponse::has_error() const {
  return _internal_has_error();
}
inline void IpTunnelStatsResponse::clear_error() {
  if (GetArenaForAllocation() == nullptr && error_ != nullptr) {
    delete error_;
  }
  error_ = nullptr;
}
inline const ::tunneloffload::v1alpha1::Error& IpTunnelStatsResponse::_internal_error() const {
  const ::tunneloffload::v1alpha1::Error* p = error_;
  return p != nullptr ? *p : reinterpret_cast<const ::tunneloffload::v1alpha1::Error&>(
      ::tunneloffload::v1alpha1::_Error_default_instance_);
}
inline const ::tunneloffload::v1alpha1::Error& IpTunnelStatsResponse::error() const {
  // @@protoc_insertion_point(field_get:tunneloffload.v1alpha1.IpTunnelStatsResponse.error)
  return _internal_error();
}
inline void IpTunnelStatsResponse::unsafe_arena_set_allocated_error(
    ::tunneloffload::v1alpha1::Error* error) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(error_);
  }
  error_ = error;
  if (error) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tunneloffload.v1alpha1.IpTunnelStatsResponse.error)
}
inline ::tunneloffload::v1alpha1::Error* IpTunnelStatsResponse::release_error() {
  
  ::tunneloffload::v1alpha1::Error* temp = error_;
  error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tunneloffload::v1alpha1::Error* IpTunnelStatsResponse::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_release:tunneloffload.v1alpha1.IpTunnelStatsResponse.error)
  
  ::tunneloffload::v1alpha1::Error* temp = error_;
  error_ = nullptr;
  return temp;
}
inline ::tunneloffload::v1alpha1::Error* IpTunnelStatsResponse::_internal_mutable_error() {
  
  if (error_ == nullptr) {
    auto* p = CreateMaybeMessage<::tunneloffload::v1alpha1::Error>(GetArenaForAllocation());
    error_ = p;
  }
  return error_;
}
inline ::tunneloffload::v1alpha1::Error* IpTunnelStatsResponse::mutable_error() {
  ::tunneloffload::v1alpha1::Error* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:tunneloffload.v1alpha1.IpTunnelStatsResponse.error)
  return _msg;
}
inline void IpTunnelStatsResponse::set_allocated_error(::tunneloffload::v1alpha1::Error* error) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete error_;
  }
  if (error) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::tunneloffload::v1alpha1::Error>::GetOwningArena(error);
    if (message_arena != submessage_arena) {
      error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    
  } else {
    
  }
  error_ = error;
  // @@protoc_insertion_point(field_set_allocated:tunneloffload.v1alpha1.IpTunnelStatsResponse.error)
}

// -------------------------------------------------------------------

// TunnelRequestArgs

// uint32 tunnels_per_request = 1;
inline void TunnelRequestArgs::clear_tunnels_per_request() {
  tunnels_per_request_ = 0u;
}
inline uint32_t TunnelRequestArgs::_internal_tunnels_per_request() const {
  return tunnels_per_request_;
}
inline uint32_t TunnelRequestArgs::tunnels_per_request() const {
  // @@protoc_insertion_point(field_get:tunneloffload.v1alpha1.TunnelRequestArgs.tunnels_per_request)
  return _internal_tunnels_per_request();
}
inline void TunnelRequestArgs::_internal_set_tunnels_per_request(uint32_t value) {
  
  tunnels_per_request_ = value;
}
inline void TunnelRequestArgs::set_tunnels_per_request(uint32_t value) {
  _internal_set_tunnels_per_request(value);
  // @@protoc_insertion_point(field_set:tunneloffload.v1alpha1.TunnelRequestArgs.tunnels_per_request)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1alpha1
}  // namespace tunneloffload

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::tunneloffload::v1alpha1::AddTunnelStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tunneloffload::v1alpha1::AddTunnelStatus>() {
  return ::tunneloffload::v1alpha1::AddTunnelStatus_descriptor();
}
template <> struct is_proto_enum< ::tunneloffload::v1alpha1::Operation> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tunneloffload::v1alpha1::Operation>() {
  return ::tunneloffload::v1alpha1::Operation_descriptor();
}
template <> struct is_proto_enum< ::tunneloffload::v1alpha1::EncType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tunneloffload::v1alpha1::EncType>() {
  return ::tunneloffload::v1alpha1::EncType_descriptor();
}
template <> struct is_proto_enum< ::tunneloffload::v1alpha1::Action> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tunneloffload::v1alpha1::Action>() {
  return ::tunneloffload::v1alpha1::Action_descriptor();
}
template <> struct is_proto_enum< ::tunneloffload::v1alpha1::MatchError> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tunneloffload::v1alpha1::MatchError>() {
  return ::tunneloffload::v1alpha1::MatchError_descriptor();
}
template <> struct is_proto_enum< ::tunneloffload::v1alpha1::TunnelError> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tunneloffload::v1alpha1::TunnelError>() {
  return ::tunneloffload::v1alpha1::TunnelError_descriptor();
}
template <> struct is_proto_enum< ::tunneloffload::v1alpha1::IPSecError> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tunneloffload::v1alpha1::IPSecError>() {
  return ::tunneloffload::v1alpha1::IPSecError_descriptor();
}
template <> struct is_proto_enum< ::tunneloffload::v1alpha1::GeneveError> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tunneloffload::v1alpha1::GeneveError>() {
  return ::tunneloffload::v1alpha1::GeneveError_descriptor();
}
template <> struct is_proto_enum< ::tunneloffload::v1alpha1::IPSecTunnelType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tunneloffload::v1alpha1::IPSecTunnelType>() {
  return ::tunneloffload::v1alpha1::IPSecTunnelType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_tunneloffload_2eproto
