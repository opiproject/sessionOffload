// Copyright (C) 2022 DriveNets Ltd. Intellectual Property. All rights reserved.
// Copyright (C) 2022 VMware, Inc. All rights reserved.
// Copyright (C) 2022 AT&T Intellectual Property. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.28.0
// 	protoc        v3.19.4
// source: tunneloffload.proto

package protos

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

//
// Errors for adding a tunnel
// If all tunnels are successful inserted return _ACCEPTED
//
// If check of tunnel capacity in offload device is insufficient to add all tunnels
// do not insert any tunnels and return  _REJECTED_TUNNEL_TABLE_FULL. It is the
// responsibility of the client to re-try
//
// If the server is unavailable for some other reason then return _REJECTED_TUNNEL_TABLE_UNAVAILABLE.
// It is the  responsibility of the client to re-try
//
// All other errors will return _REJECTED with a buit mask of the failed sessions and it is the responsibility
// of the client to address the issues
//
// AddTunnelStatus Codes Description
//
// _TUNNEL_ACCEPTED: Tunnel is accepted by the server and the client performs normal operation
// _TUNNEL_REJECTED: Tunnel is rejected by the server as the message
//    is invalid, the client needs to correct the error.
// _TUNNEL_TABLE_FULL: Tunnel is rejected by the server as its session table is full,
//    the client needs to backoff until more space is available
// _TUNNEL_TABLE_UNAVAILABLE: Tunnel is rejected by the server due to an internal error
//    in the server, the client needs to back off until error is corrected.
// _TUNNEL_ALREADY_EXISTS: Tunnel is rejected by the the server as it already exists
//    in the server session table, the client will take corrective action to ensure state is consistent.
//
type AddTunnelStatus int32

const (
	AddTunnelStatus__TUNNEL_ACCEPTED          AddTunnelStatus = 0
	AddTunnelStatus__TUNNEL_REJECTED          AddTunnelStatus = 1
	AddTunnelStatus__TUNNEL_TABLE_FULL        AddTunnelStatus = 2
	AddTunnelStatus__TUNNEL_TABLE_UNAVAILABLE AddTunnelStatus = 3
	AddTunnelStatus__TUNNEL_ALREADY_EXISTS    AddTunnelStatus = 4
)

// Enum value maps for AddTunnelStatus.
var (
	AddTunnelStatus_name = map[int32]string{
		0: "_TUNNEL_ACCEPTED",
		1: "_TUNNEL_REJECTED",
		2: "_TUNNEL_TABLE_FULL",
		3: "_TUNNEL_TABLE_UNAVAILABLE",
		4: "_TUNNEL_ALREADY_EXISTS",
	}
	AddTunnelStatus_value = map[string]int32{
		"_TUNNEL_ACCEPTED":          0,
		"_TUNNEL_REJECTED":          1,
		"_TUNNEL_TABLE_FULL":        2,
		"_TUNNEL_TABLE_UNAVAILABLE": 3,
		"_TUNNEL_ALREADY_EXISTS":    4,
	}
)

func (x AddTunnelStatus) Enum() *AddTunnelStatus {
	p := new(AddTunnelStatus)
	*p = x
	return p
}

func (x AddTunnelStatus) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (AddTunnelStatus) Descriptor() protoreflect.EnumDescriptor {
	return file_tunneloffload_proto_enumTypes[0].Descriptor()
}

func (AddTunnelStatus) Type() protoreflect.EnumType {
	return &file_tunneloffload_proto_enumTypes[0]
}

func (x AddTunnelStatus) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use AddTunnelStatus.Descriptor instead.
func (AddTunnelStatus) EnumDescriptor() ([]byte, []int) {
	return file_tunneloffload_proto_rawDescGZIP(), []int{0}
}

type Operation int32

const (
	Operation__NONE   Operation = 0
	Operation__CREATE Operation = 1
	Operation__UPDATE Operation = 2
	Operation__DELETE Operation = 3
)

// Enum value maps for Operation.
var (
	Operation_name = map[int32]string{
		0: "_NONE",
		1: "_CREATE",
		2: "_UPDATE",
		3: "_DELETE",
	}
	Operation_value = map[string]int32{
		"_NONE":   0,
		"_CREATE": 1,
		"_UPDATE": 2,
		"_DELETE": 3,
	}
)

func (x Operation) Enum() *Operation {
	p := new(Operation)
	*p = x
	return p
}

func (x Operation) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Operation) Descriptor() protoreflect.EnumDescriptor {
	return file_tunneloffload_proto_enumTypes[1].Descriptor()
}

func (Operation) Type() protoreflect.EnumType {
	return &file_tunneloffload_proto_enumTypes[1]
}

func (x Operation) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Operation.Descriptor instead.
func (Operation) EnumDescriptor() ([]byte, []int) {
	return file_tunneloffload_proto_rawDescGZIP(), []int{1}
}

type EncType int32

const (
	EncType__AES256GCM64  EncType = 0
	EncType__AES256GCM96  EncType = 1
	EncType__AES256GCM128 EncType = 2
	EncType__AES128GCM64  EncType = 3
	EncType__AES128GCM96  EncType = 4
	EncType__AES128GCM128 EncType = 5
	EncType__AES256CCM64  EncType = 6
	EncType__AES256CCM96  EncType = 7
	EncType__AES256CCM128 EncType = 8
	EncType__AES128CCM64  EncType = 9
	EncType__AES128CCM96  EncType = 10
	EncType__AES128CCM128 EncType = 11
)

// Enum value maps for EncType.
var (
	EncType_name = map[int32]string{
		0:  "_AES256GCM64",
		1:  "_AES256GCM96",
		2:  "_AES256GCM128",
		3:  "_AES128GCM64",
		4:  "_AES128GCM96",
		5:  "_AES128GCM128",
		6:  "_AES256CCM64",
		7:  "_AES256CCM96",
		8:  "_AES256CCM128",
		9:  "_AES128CCM64",
		10: "_AES128CCM96",
		11: "_AES128CCM128",
	}
	EncType_value = map[string]int32{
		"_AES256GCM64":  0,
		"_AES256GCM96":  1,
		"_AES256GCM128": 2,
		"_AES128GCM64":  3,
		"_AES128GCM96":  4,
		"_AES128GCM128": 5,
		"_AES256CCM64":  6,
		"_AES256CCM96":  7,
		"_AES256CCM128": 8,
		"_AES128CCM64":  9,
		"_AES128CCM96":  10,
		"_AES128CCM128": 11,
	}
)

func (x EncType) Enum() *EncType {
	p := new(EncType)
	*p = x
	return p
}

func (x EncType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (EncType) Descriptor() protoreflect.EnumDescriptor {
	return file_tunneloffload_proto_enumTypes[2].Descriptor()
}

func (EncType) Type() protoreflect.EnumType {
	return &file_tunneloffload_proto_enumTypes[2]
}

func (x EncType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use EncType.Descriptor instead.
func (EncType) EnumDescriptor() ([]byte, []int) {
	return file_tunneloffload_proto_rawDescGZIP(), []int{2}
}

type Action int32

const (
	Action_NONE Action = 0
	// In this action packet will be forwarded right away
	Action_FORWARD Action = 1
	// In this action packet will continue processing, to other tunnel
	Action_RECIRCULATE Action = 2
)

// Enum value maps for Action.
var (
	Action_name = map[int32]string{
		0: "NONE",
		1: "FORWARD",
		2: "RECIRCULATE",
	}
	Action_value = map[string]int32{
		"NONE":        0,
		"FORWARD":     1,
		"RECIRCULATE": 2,
	}
)

func (x Action) Enum() *Action {
	p := new(Action)
	*p = x
	return p
}

func (x Action) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Action) Descriptor() protoreflect.EnumDescriptor {
	return file_tunneloffload_proto_enumTypes[3].Descriptor()
}

func (Action) Type() protoreflect.EnumType {
	return &file_tunneloffload_proto_enumTypes[3]
}

func (x Action) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Action.Descriptor instead.
func (Action) EnumDescriptor() ([]byte, []int) {
	return file_tunneloffload_proto_rawDescGZIP(), []int{3}
}

type MatchError int32

const (
	MatchError_MISING_FIELDS        MatchError = 0 // Some missing fields are misisng in the match statment
	MatchError_INVALID_TUNNEL_ID    MatchError = 1 // Tunnel ID match isn't valid or doesn't exist
	MatchError_INVALID_CAPABILITIES MatchError = 2 // The match isn't suitable with tunnel capabilities
	MatchError_INVALID_FIELD        MatchError = 3 // Invalid field found in the match (e.g. invalid mac)
)

// Enum value maps for MatchError.
var (
	MatchError_name = map[int32]string{
		0: "MISING_FIELDS",
		1: "INVALID_TUNNEL_ID",
		2: "INVALID_CAPABILITIES",
		3: "INVALID_FIELD",
	}
	MatchError_value = map[string]int32{
		"MISING_FIELDS":        0,
		"INVALID_TUNNEL_ID":    1,
		"INVALID_CAPABILITIES": 2,
		"INVALID_FIELD":        3,
	}
)

func (x MatchError) Enum() *MatchError {
	p := new(MatchError)
	*p = x
	return p
}

func (x MatchError) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (MatchError) Descriptor() protoreflect.EnumDescriptor {
	return file_tunneloffload_proto_enumTypes[4].Descriptor()
}

func (MatchError) Type() protoreflect.EnumType {
	return &file_tunneloffload_proto_enumTypes[4]
}

func (x MatchError) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use MatchError.Descriptor instead.
func (MatchError) EnumDescriptor() ([]byte, []int) {
	return file_tunneloffload_proto_rawDescGZIP(), []int{4}
}

type TunnelError int32

const (
	TunnelError_NOT_SUPPORTED_TUNNEL TunnelError = 0 // Tunnel offload requested to non supported tunnel
)

// Enum value maps for TunnelError.
var (
	TunnelError_name = map[int32]string{
		0: "NOT_SUPPORTED_TUNNEL",
	}
	TunnelError_value = map[string]int32{
		"NOT_SUPPORTED_TUNNEL": 0,
	}
)

func (x TunnelError) Enum() *TunnelError {
	p := new(TunnelError)
	*p = x
	return p
}

func (x TunnelError) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (TunnelError) Descriptor() protoreflect.EnumDescriptor {
	return file_tunneloffload_proto_enumTypes[5].Descriptor()
}

func (TunnelError) Type() protoreflect.EnumType {
	return &file_tunneloffload_proto_enumTypes[5]
}

func (x TunnelError) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use TunnelError.Descriptor instead.
func (TunnelError) EnumDescriptor() ([]byte, []int) {
	return file_tunneloffload_proto_rawDescGZIP(), []int{5}
}

type IPSecError int32

const (
	IPSecError_INVALID_KEY               IPSecError = 0 // Key got into IPSec is not matching the requested size
	IPSecError_NON_SUPPORTED_ENCRYPTION  IPSecError = 1 // Encrypted type requested from IPSec is not supported
	IPSecError_NON_SUPPORTED_TUNNEL_TYPE IPSecError = 2 // Tunnel type requested by IPSec is not valid (TUNNEL mode requested but not valid)
	IPSecError_IPSEC_MISSING_FIELDS      IPSecError = 3 // Some missing fields in IPSec, e.g. TUNNEL MODE without tunnel IP's provided
)

// Enum value maps for IPSecError.
var (
	IPSecError_name = map[int32]string{
		0: "INVALID_KEY",
		1: "NON_SUPPORTED_ENCRYPTION",
		2: "NON_SUPPORTED_TUNNEL_TYPE",
		3: "IPSEC_MISSING_FIELDS",
	}
	IPSecError_value = map[string]int32{
		"INVALID_KEY":               0,
		"NON_SUPPORTED_ENCRYPTION":  1,
		"NON_SUPPORTED_TUNNEL_TYPE": 2,
		"IPSEC_MISSING_FIELDS":      3,
	}
)

func (x IPSecError) Enum() *IPSecError {
	p := new(IPSecError)
	*p = x
	return p
}

func (x IPSecError) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (IPSecError) Descriptor() protoreflect.EnumDescriptor {
	return file_tunneloffload_proto_enumTypes[6].Descriptor()
}

func (IPSecError) Type() protoreflect.EnumType {
	return &file_tunneloffload_proto_enumTypes[6]
}

func (x IPSecError) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use IPSecError.Descriptor instead.
func (IPSecError) EnumDescriptor() ([]byte, []int) {
	return file_tunneloffload_proto_rawDescGZIP(), []int{6}
}

type GeneveError int32

const (
	GeneveError_INVALID_OPTION       GeneveError = 0 // One of the options supported isn't valid
	GeneveError_TOO_MANY_OPTIONS     GeneveError = 1 // Too many options provided with the geneve tunnel
	GeneveError_INVALID_GENEVE_FIELD GeneveError = 2 // One of the fields provided in GENVE isn't valid (e.g. too big VNI)
)

// Enum value maps for GeneveError.
var (
	GeneveError_name = map[int32]string{
		0: "INVALID_OPTION",
		1: "TOO_MANY_OPTIONS",
		2: "INVALID_GENEVE_FIELD",
	}
	GeneveError_value = map[string]int32{
		"INVALID_OPTION":       0,
		"TOO_MANY_OPTIONS":     1,
		"INVALID_GENEVE_FIELD": 2,
	}
)

func (x GeneveError) Enum() *GeneveError {
	p := new(GeneveError)
	*p = x
	return p
}

func (x GeneveError) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (GeneveError) Descriptor() protoreflect.EnumDescriptor {
	return file_tunneloffload_proto_enumTypes[7].Descriptor()
}

func (GeneveError) Type() protoreflect.EnumType {
	return &file_tunneloffload_proto_enumTypes[7]
}

func (x GeneveError) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use GeneveError.Descriptor instead.
func (GeneveError) EnumDescriptor() ([]byte, []int) {
	return file_tunneloffload_proto_rawDescGZIP(), []int{7}
}

type IPSecTunnelType int32

const (
	IPSecTunnelType_TRANSPORT IPSecTunnelType = 0
	IPSecTunnelType_TUNNEL    IPSecTunnelType = 1
	// Nat Traversal is a mechanism to overcome Nat happens between the
	// two IPSec endpoints, by adding a UDP Header after IPSec
	// This mode can happen both in TRANSPORT & TUNNEL Mode
	// Fore more information please refer to the following RFC's:
	// https://datatracker.ietf.org/doc/html/rfc3947
	// https://datatracker.ietf.org/doc/html/rfc3715
	IPSecTunnelType_TRANSPORT_NAT_TRAVERSAL IPSecTunnelType = 2
	IPSecTunnelType_TUNNEL_NAT_TRAVERSAL    IPSecTunnelType = 3
)

// Enum value maps for IPSecTunnelType.
var (
	IPSecTunnelType_name = map[int32]string{
		0: "TRANSPORT",
		1: "TUNNEL",
		2: "TRANSPORT_NAT_TRAVERSAL",
		3: "TUNNEL_NAT_TRAVERSAL",
	}
	IPSecTunnelType_value = map[string]int32{
		"TRANSPORT":               0,
		"TUNNEL":                  1,
		"TRANSPORT_NAT_TRAVERSAL": 2,
		"TUNNEL_NAT_TRAVERSAL":    3,
	}
)

func (x IPSecTunnelType) Enum() *IPSecTunnelType {
	p := new(IPSecTunnelType)
	*p = x
	return p
}

func (x IPSecTunnelType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (IPSecTunnelType) Descriptor() protoreflect.EnumDescriptor {
	return file_tunneloffload_proto_enumTypes[8].Descriptor()
}

func (IPSecTunnelType) Type() protoreflect.EnumType {
	return &file_tunneloffload_proto_enumTypes[8]
}

func (x IPSecTunnelType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use IPSecTunnelType.Descriptor instead.
func (IPSecTunnelType) EnumDescriptor() ([]byte, []int) {
	return file_tunneloffload_proto_rawDescGZIP(), []int{8}
}

// Capabilty request is empty since no paramteres are supplied to it,
// all capabilities will be provided at response
type CapabilityRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields
}

func (x *CapabilityRequest) Reset() {
	*x = CapabilityRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_tunneloffload_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *CapabilityRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CapabilityRequest) ProtoMessage() {}

func (x *CapabilityRequest) ProtoReflect() protoreflect.Message {
	mi := &file_tunneloffload_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CapabilityRequest.ProtoReflect.Descriptor instead.
func (*CapabilityRequest) Descriptor() ([]byte, []int) {
	return file_tunneloffload_proto_rawDescGZIP(), []int{0}
}

type CapabilityResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	MatchCapabilities  *CapabilityResponse_MatchCapabilities  `protobuf:"bytes,1,opt,name=match_capabilities,json=matchCapabilities,proto3" json:"match_capabilities,omitempty"`
	IpsecCapabilities  *CapabilityResponse_IPSecCapabilities  `protobuf:"bytes,2,opt,name=ipsec_capabilities,json=ipsecCapabilities,proto3" json:"ipsec_capabilities,omitempty"`
	GeneveCapabilities *CapabilityResponse_GeneveCapabilities `protobuf:"bytes,3,opt,name=geneve_capabilities,json=geneveCapabilities,proto3" json:"geneve_capabilities,omitempty"`
}

func (x *CapabilityResponse) Reset() {
	*x = CapabilityResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_tunneloffload_proto_msgTypes[1]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *CapabilityResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CapabilityResponse) ProtoMessage() {}

func (x *CapabilityResponse) ProtoReflect() protoreflect.Message {
	mi := &file_tunneloffload_proto_msgTypes[1]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CapabilityResponse.ProtoReflect.Descriptor instead.
func (*CapabilityResponse) Descriptor() ([]byte, []int) {
	return file_tunneloffload_proto_rawDescGZIP(), []int{1}
}

func (x *CapabilityResponse) GetMatchCapabilities() *CapabilityResponse_MatchCapabilities {
	if x != nil {
		return x.MatchCapabilities
	}
	return nil
}

func (x *CapabilityResponse) GetIpsecCapabilities() *CapabilityResponse_IPSecCapabilities {
	if x != nil {
		return x.IpsecCapabilities
	}
	return nil
}

func (x *CapabilityResponse) GetGeneveCapabilities() *CapabilityResponse_GeneveCapabilities {
	if x != nil {
		return x.GeneveCapabilities
	}
	return nil
}

type TunnelAdditionError struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Message will only present if there's error in tunnel
	MatchError  MatchError  `protobuf:"varint,1,opt,name=match_error,json=matchError,proto3,enum=tunneloffload.v2.MatchError" json:"match_error,omitempty"`     // Error in match of tunnel
	TunnelError TunnelError `protobuf:"varint,2,opt,name=tunnel_error,json=tunnelError,proto3,enum=tunneloffload.v2.TunnelError" json:"tunnel_error,omitempty"` // General problem in tunnel definition
	IpsecError  IPSecError  `protobuf:"varint,3,opt,name=ipsec_error,json=ipsecError,proto3,enum=tunneloffload.v2.IPSecError" json:"ipsec_error,omitempty"`     // IPSec Error
	GeneveError GeneveError `protobuf:"varint,4,opt,name=geneve_error,json=geneveError,proto3,enum=tunneloffload.v2.GeneveError" json:"geneve_error,omitempty"` // Error in geneve
}

func (x *TunnelAdditionError) Reset() {
	*x = TunnelAdditionError{}
	if protoimpl.UnsafeEnabled {
		mi := &file_tunneloffload_proto_msgTypes[2]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *TunnelAdditionError) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TunnelAdditionError) ProtoMessage() {}

func (x *TunnelAdditionError) ProtoReflect() protoreflect.Message {
	mi := &file_tunneloffload_proto_msgTypes[2]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TunnelAdditionError.ProtoReflect.Descriptor instead.
func (*TunnelAdditionError) Descriptor() ([]byte, []int) {
	return file_tunneloffload_proto_rawDescGZIP(), []int{2}
}

func (x *TunnelAdditionError) GetMatchError() MatchError {
	if x != nil {
		return x.MatchError
	}
	return MatchError_MISING_FIELDS
}

func (x *TunnelAdditionError) GetTunnelError() TunnelError {
	if x != nil {
		return x.TunnelError
	}
	return TunnelError_NOT_SUPPORTED_TUNNEL
}

func (x *TunnelAdditionError) GetIpsecError() IPSecError {
	if x != nil {
		return x.IpsecError
	}
	return IPSecError_INVALID_KEY
}

func (x *TunnelAdditionError) GetGeneveError() GeneveError {
	if x != nil {
		return x.GeneveError
	}
	return GeneveError_INVALID_OPTION
}

type MatchCriteria struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// In case it's not present, untagged traffic will be matched
	IngressInterface string   `protobuf:"bytes,1,opt,name=ingress_interface,json=ingressInterface,proto3" json:"ingress_interface,omitempty"`
	MacMatch         *MacPair `protobuf:"bytes,2,opt,name=mac_match,json=macMatch,proto3" json:"mac_match,omitempty"` // MAC of the packet itself
	// Types that are assignable to IpMatch:
	//	*MatchCriteria_Ipv4Match
	//	*MatchCriteria_Ipv6Match
	IpMatch  isMatchCriteria_IpMatch `protobuf_oneof:"ip_match"`
	TunnelId uint64                  `protobuf:"varint,5,opt,name=tunnel_id,json=tunnelId,proto3" json:"tunnel_id,omitempty"` // Match on specific tunnel
	// Tunnel Matching
	//
	// Types that are assignable to Match:
	//	*MatchCriteria_IpsecMatch
	//	*MatchCriteria_GeneveMatch_
	//	*MatchCriteria_VxlanMatch
	Match isMatchCriteria_Match `protobuf_oneof:"match"`
}

func (x *MatchCriteria) Reset() {
	*x = MatchCriteria{}
	if protoimpl.UnsafeEnabled {
		mi := &file_tunneloffload_proto_msgTypes[3]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MatchCriteria) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MatchCriteria) ProtoMessage() {}

func (x *MatchCriteria) ProtoReflect() protoreflect.Message {
	mi := &file_tunneloffload_proto_msgTypes[3]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MatchCriteria.ProtoReflect.Descriptor instead.
func (*MatchCriteria) Descriptor() ([]byte, []int) {
	return file_tunneloffload_proto_rawDescGZIP(), []int{3}
}

func (x *MatchCriteria) GetIngressInterface() string {
	if x != nil {
		return x.IngressInterface
	}
	return ""
}

func (x *MatchCriteria) GetMacMatch() *MacPair {
	if x != nil {
		return x.MacMatch
	}
	return nil
}

func (m *MatchCriteria) GetIpMatch() isMatchCriteria_IpMatch {
	if m != nil {
		return m.IpMatch
	}
	return nil
}

func (x *MatchCriteria) GetIpv4Match() *IPV4Match {
	if x, ok := x.GetIpMatch().(*MatchCriteria_Ipv4Match); ok {
		return x.Ipv4Match
	}
	return nil
}

func (x *MatchCriteria) GetIpv6Match() *IPV6Match {
	if x, ok := x.GetIpMatch().(*MatchCriteria_Ipv6Match); ok {
		return x.Ipv6Match
	}
	return nil
}

func (x *MatchCriteria) GetTunnelId() uint64 {
	if x != nil {
		return x.TunnelId
	}
	return 0
}

func (m *MatchCriteria) GetMatch() isMatchCriteria_Match {
	if m != nil {
		return m.Match
	}
	return nil
}

func (x *MatchCriteria) GetIpsecMatch() *MatchCriteria_IPSecMatch {
	if x, ok := x.GetMatch().(*MatchCriteria_IpsecMatch); ok {
		return x.IpsecMatch
	}
	return nil
}

func (x *MatchCriteria) GetGeneveMatch() *MatchCriteria_GeneveMatch {
	if x, ok := x.GetMatch().(*MatchCriteria_GeneveMatch_); ok {
		return x.GeneveMatch
	}
	return nil
}

func (x *MatchCriteria) GetVxlanMatch() *MatchCriteria_VXLanMatch {
	if x, ok := x.GetMatch().(*MatchCriteria_VxlanMatch); ok {
		return x.VxlanMatch
	}
	return nil
}

type isMatchCriteria_IpMatch interface {
	isMatchCriteria_IpMatch()
}

type MatchCriteria_Ipv4Match struct {
	Ipv4Match *IPV4Match `protobuf:"bytes,3,opt,name=ipv4_match,json=ipv4Match,proto3,oneof"`
}

type MatchCriteria_Ipv6Match struct {
	Ipv6Match *IPV6Match `protobuf:"bytes,4,opt,name=ipv6_match,json=ipv6Match,proto3,oneof"`
}

func (*MatchCriteria_Ipv4Match) isMatchCriteria_IpMatch() {}

func (*MatchCriteria_Ipv6Match) isMatchCriteria_IpMatch() {}

type isMatchCriteria_Match interface {
	isMatchCriteria_Match()
}

type MatchCriteria_IpsecMatch struct {
	IpsecMatch *MatchCriteria_IPSecMatch `protobuf:"bytes,6,opt,name=ipsec_match,json=ipsecMatch,proto3,oneof"`
}

type MatchCriteria_GeneveMatch_ struct {
	GeneveMatch *MatchCriteria_GeneveMatch `protobuf:"bytes,7,opt,name=geneve_match,json=geneveMatch,proto3,oneof"`
}

type MatchCriteria_VxlanMatch struct {
	VxlanMatch *MatchCriteria_VXLanMatch `protobuf:"bytes,8,opt,name=vxlan_match,json=vxlanMatch,proto3,oneof"`
}

func (*MatchCriteria_IpsecMatch) isMatchCriteria_Match() {}

func (*MatchCriteria_GeneveMatch_) isMatchCriteria_Match() {}

func (*MatchCriteria_VxlanMatch) isMatchCriteria_Match() {}

type IpTunnelRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	TunnelId      uint64         `protobuf:"varint,1,opt,name=tunnel_id,json=tunnelId,proto3" json:"tunnel_id,omitempty"`
	Operation     Operation      `protobuf:"varint,2,opt,name=operation,proto3,enum=tunneloffload.v2.Operation" json:"operation,omitempty"`
	MatchCriteria *MatchCriteria `protobuf:"bytes,3,opt,name=match_criteria,json=matchCriteria,proto3" json:"match_criteria,omitempty"`                      // When hitting this match,
	NextAction    Action         `protobuf:"varint,4,opt,name=next_action,json=nextAction,proto3,enum=tunneloffload.v2.Action" json:"next_action,omitempty"` // What we'll do after matching the packet, should we
	// Types that are assignable to Tunnel:
	//	*IpTunnelRequest_IpsecTunnel
	//	*IpTunnelRequest_Geneve
	//	*IpTunnelRequest_Nat
	Tunnel isIpTunnelRequest_Tunnel `protobuf_oneof:"tunnel"`
}

func (x *IpTunnelRequest) Reset() {
	*x = IpTunnelRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_tunneloffload_proto_msgTypes[4]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *IpTunnelRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IpTunnelRequest) ProtoMessage() {}

func (x *IpTunnelRequest) ProtoReflect() protoreflect.Message {
	mi := &file_tunneloffload_proto_msgTypes[4]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IpTunnelRequest.ProtoReflect.Descriptor instead.
func (*IpTunnelRequest) Descriptor() ([]byte, []int) {
	return file_tunneloffload_proto_rawDescGZIP(), []int{4}
}

func (x *IpTunnelRequest) GetTunnelId() uint64 {
	if x != nil {
		return x.TunnelId
	}
	return 0
}

func (x *IpTunnelRequest) GetOperation() Operation {
	if x != nil {
		return x.Operation
	}
	return Operation__NONE
}

func (x *IpTunnelRequest) GetMatchCriteria() *MatchCriteria {
	if x != nil {
		return x.MatchCriteria
	}
	return nil
}

func (x *IpTunnelRequest) GetNextAction() Action {
	if x != nil {
		return x.NextAction
	}
	return Action_NONE
}

func (m *IpTunnelRequest) GetTunnel() isIpTunnelRequest_Tunnel {
	if m != nil {
		return m.Tunnel
	}
	return nil
}

func (x *IpTunnelRequest) GetIpsecTunnel() *IPSecTunnel {
	if x, ok := x.GetTunnel().(*IpTunnelRequest_IpsecTunnel); ok {
		return x.IpsecTunnel
	}
	return nil
}

func (x *IpTunnelRequest) GetGeneve() *Geneve {
	if x, ok := x.GetTunnel().(*IpTunnelRequest_Geneve); ok {
		return x.Geneve
	}
	return nil
}

func (x *IpTunnelRequest) GetNat() *Nat {
	if x, ok := x.GetTunnel().(*IpTunnelRequest_Nat); ok {
		return x.Nat
	}
	return nil
}

type isIpTunnelRequest_Tunnel interface {
	isIpTunnelRequest_Tunnel()
}

type IpTunnelRequest_IpsecTunnel struct {
	IpsecTunnel *IPSecTunnel `protobuf:"bytes,5,opt,name=ipsec_tunnel,json=ipsecTunnel,proto3,oneof"` // Tunnel that will be used for encapsulation, can be both
}

type IpTunnelRequest_Geneve struct {
	Geneve *Geneve `protobuf:"bytes,6,opt,name=geneve,proto3,oneof"`
}

type IpTunnelRequest_Nat struct {
	Nat *Nat `protobuf:"bytes,7,opt,name=nat,proto3,oneof"`
}

func (*IpTunnelRequest_IpsecTunnel) isIpTunnelRequest_Tunnel() {}

func (*IpTunnelRequest_Geneve) isIpTunnelRequest_Tunnel() {}

func (*IpTunnelRequest_Nat) isIpTunnelRequest_Tunnel() {}

type Geneve struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Types that are assignable to EncapDecap:
	//	*Geneve_GeneveEncap
	//	*Geneve_GeneveDecap
	EncapDecap isGeneve_EncapDecap `protobuf_oneof:"encap_decap"`
}

func (x *Geneve) Reset() {
	*x = Geneve{}
	if protoimpl.UnsafeEnabled {
		mi := &file_tunneloffload_proto_msgTypes[5]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Geneve) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Geneve) ProtoMessage() {}

func (x *Geneve) ProtoReflect() protoreflect.Message {
	mi := &file_tunneloffload_proto_msgTypes[5]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Geneve.ProtoReflect.Descriptor instead.
func (*Geneve) Descriptor() ([]byte, []int) {
	return file_tunneloffload_proto_rawDescGZIP(), []int{5}
}

func (m *Geneve) GetEncapDecap() isGeneve_EncapDecap {
	if m != nil {
		return m.EncapDecap
	}
	return nil
}

func (x *Geneve) GetGeneveEncap() *GeneveEncap {
	if x, ok := x.GetEncapDecap().(*Geneve_GeneveEncap); ok {
		return x.GeneveEncap
	}
	return nil
}

func (x *Geneve) GetGeneveDecap() *GeneveDecap {
	if x, ok := x.GetEncapDecap().(*Geneve_GeneveDecap); ok {
		return x.GeneveDecap
	}
	return nil
}

type isGeneve_EncapDecap interface {
	isGeneve_EncapDecap()
}

type Geneve_GeneveEncap struct {
	GeneveEncap *GeneveEncap `protobuf:"bytes,1,opt,name=geneve_encap,json=geneveEncap,proto3,oneof"`
}

type Geneve_GeneveDecap struct {
	GeneveDecap *GeneveDecap `protobuf:"bytes,2,opt,name=geneve_decap,json=geneveDecap,proto3,oneof"`
}

func (*Geneve_GeneveEncap) isGeneve_EncapDecap() {}

func (*Geneve_GeneveDecap) isGeneve_EncapDecap() {}

type GeneveOption struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	OptionClass uint32 `protobuf:"varint,1,opt,name=option_class,json=optionClass,proto3" json:"option_class,omitempty"` // 16 bits
	Type        uint32 `protobuf:"varint,2,opt,name=type,proto3" json:"type,omitempty"`                                  // 8 bits
	Length      uint32 `protobuf:"varint,3,opt,name=length,proto3" json:"length,omitempty"`                              // Only 5 bits used
	// Length is multiple of 4 bytes (see https://datatracker.ietf.org/doc/html/rfc8926#section-3.5)
	Data []byte `protobuf:"bytes,4,opt,name=data,proto3" json:"data,omitempty"` // Only 4-128 bytes are acceptable,
}

func (x *GeneveOption) Reset() {
	*x = GeneveOption{}
	if protoimpl.UnsafeEnabled {
		mi := &file_tunneloffload_proto_msgTypes[6]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *GeneveOption) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GeneveOption) ProtoMessage() {}

func (x *GeneveOption) ProtoReflect() protoreflect.Message {
	mi := &file_tunneloffload_proto_msgTypes[6]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GeneveOption.ProtoReflect.Descriptor instead.
func (*GeneveOption) Descriptor() ([]byte, []int) {
	return file_tunneloffload_proto_rawDescGZIP(), []int{6}
}

func (x *GeneveOption) GetOptionClass() uint32 {
	if x != nil {
		return x.OptionClass
	}
	return 0
}

func (x *GeneveOption) GetType() uint32 {
	if x != nil {
		return x.Type
	}
	return 0
}

func (x *GeneveOption) GetLength() uint32 {
	if x != nil {
		return x.Length
	}
	return 0
}

func (x *GeneveOption) GetData() []byte {
	if x != nil {
		return x.Data
	}
	return nil
}

type GeneveEncap struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// IP's that will be in the outer IP of encapsulated packet
	//
	// Types that are assignable to Ip:
	//	*GeneveEncap_OuterIpv4Pair
	//	*GeneveEncap_OuterIpv6Pair
	Ip isGeneveEncap_Ip `protobuf_oneof:"ip"`
	// Source & Dest mac of inner Geneve packet
	InnerMacPair          *MacPair        `protobuf:"bytes,3,opt,name=inner_mac_pair,json=innerMacPair,proto3" json:"inner_mac_pair,omitempty"`
	OptionLength          uint32          `protobuf:"varint,4,opt,name=option_length,json=optionLength,proto3" json:"option_length,omitempty"`                              // 6 bits - Multiply of 4 bytes
	ControlPacket         bool            `protobuf:"varint,5,opt,name=control_packet,json=controlPacket,proto3" json:"control_packet,omitempty"`                           // O bit at rfc. True is '1', False is '0'. Default is False.
	CriticalOptionPresent bool            `protobuf:"varint,6,opt,name=critical_option_present,json=criticalOptionPresent,proto3" json:"critical_option_present,omitempty"` // C bit at rfc. True is '1', False is '0'. Default is False.
	Vni                   uint32          `protobuf:"varint,7,opt,name=vni,proto3" json:"vni,omitempty"`                                                                    // Virtual Network Identifier - 24 bits
	ProtocolType          uint32          `protobuf:"varint,8,opt,name=protocol_type,json=protocolType,proto3" json:"protocol_type,omitempty"`                              // Currently only "Trans Ether Bridging" is supported (0x6558)
	GeneveOption          []*GeneveOption `protobuf:"bytes,9,rep,name=geneve_option,json=geneveOption,proto3" json:"geneve_option,omitempty"`
}

func (x *GeneveEncap) Reset() {
	*x = GeneveEncap{}
	if protoimpl.UnsafeEnabled {
		mi := &file_tunneloffload_proto_msgTypes[7]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *GeneveEncap) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GeneveEncap) ProtoMessage() {}

func (x *GeneveEncap) ProtoReflect() protoreflect.Message {
	mi := &file_tunneloffload_proto_msgTypes[7]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GeneveEncap.ProtoReflect.Descriptor instead.
func (*GeneveEncap) Descriptor() ([]byte, []int) {
	return file_tunneloffload_proto_rawDescGZIP(), []int{7}
}

func (m *GeneveEncap) GetIp() isGeneveEncap_Ip {
	if m != nil {
		return m.Ip
	}
	return nil
}

func (x *GeneveEncap) GetOuterIpv4Pair() *IPV4Pair {
	if x, ok := x.GetIp().(*GeneveEncap_OuterIpv4Pair); ok {
		return x.OuterIpv4Pair
	}
	return nil
}

func (x *GeneveEncap) GetOuterIpv6Pair() *IPV6Pair {
	if x, ok := x.GetIp().(*GeneveEncap_OuterIpv6Pair); ok {
		return x.OuterIpv6Pair
	}
	return nil
}

func (x *GeneveEncap) GetInnerMacPair() *MacPair {
	if x != nil {
		return x.InnerMacPair
	}
	return nil
}

func (x *GeneveEncap) GetOptionLength() uint32 {
	if x != nil {
		return x.OptionLength
	}
	return 0
}

func (x *GeneveEncap) GetControlPacket() bool {
	if x != nil {
		return x.ControlPacket
	}
	return false
}

func (x *GeneveEncap) GetCriticalOptionPresent() bool {
	if x != nil {
		return x.CriticalOptionPresent
	}
	return false
}

func (x *GeneveEncap) GetVni() uint32 {
	if x != nil {
		return x.Vni
	}
	return 0
}

func (x *GeneveEncap) GetProtocolType() uint32 {
	if x != nil {
		return x.ProtocolType
	}
	return 0
}

func (x *GeneveEncap) GetGeneveOption() []*GeneveOption {
	if x != nil {
		return x.GeneveOption
	}
	return nil
}

type isGeneveEncap_Ip interface {
	isGeneveEncap_Ip()
}

type GeneveEncap_OuterIpv4Pair struct {
	OuterIpv4Pair *IPV4Pair `protobuf:"bytes,1,opt,name=outer_ipv4_pair,json=outerIpv4Pair,proto3,oneof"`
}

type GeneveEncap_OuterIpv6Pair struct {
	OuterIpv6Pair *IPV6Pair `protobuf:"bytes,2,opt,name=outer_ipv6_pair,json=outerIpv6Pair,proto3,oneof"`
}

func (*GeneveEncap_OuterIpv4Pair) isGeneveEncap_Ip() {}

func (*GeneveEncap_OuterIpv6Pair) isGeneveEncap_Ip() {}

type GeneveDecap struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields
}

func (x *GeneveDecap) Reset() {
	*x = GeneveDecap{}
	if protoimpl.UnsafeEnabled {
		mi := &file_tunneloffload_proto_msgTypes[8]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *GeneveDecap) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GeneveDecap) ProtoMessage() {}

func (x *GeneveDecap) ProtoReflect() protoreflect.Message {
	mi := &file_tunneloffload_proto_msgTypes[8]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GeneveDecap.ProtoReflect.Descriptor instead.
func (*GeneveDecap) Descriptor() ([]byte, []int) {
	return file_tunneloffload_proto_rawDescGZIP(), []int{8}
}

type MacPair struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	DestinationMac []byte `protobuf:"bytes,1,opt,name=destination_mac,json=destinationMac,proto3" json:"destination_mac,omitempty"`
	SourceMac      []byte `protobuf:"bytes,2,opt,name=source_mac,json=sourceMac,proto3" json:"source_mac,omitempty"`
}

func (x *MacPair) Reset() {
	*x = MacPair{}
	if protoimpl.UnsafeEnabled {
		mi := &file_tunneloffload_proto_msgTypes[9]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MacPair) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MacPair) ProtoMessage() {}

func (x *MacPair) ProtoReflect() protoreflect.Message {
	mi := &file_tunneloffload_proto_msgTypes[9]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MacPair.ProtoReflect.Descriptor instead.
func (*MacPair) Descriptor() ([]byte, []int) {
	return file_tunneloffload_proto_rawDescGZIP(), []int{9}
}

func (x *MacPair) GetDestinationMac() []byte {
	if x != nil {
		return x.DestinationMac
	}
	return nil
}

func (x *MacPair) GetSourceMac() []byte {
	if x != nil {
		return x.SourceMac
	}
	return nil
}

type IPV4Pair struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	SourceIp      uint32 `protobuf:"fixed32,1,opt,name=source_ip,json=sourceIp,proto3" json:"source_ip,omitempty"`
	DestinationIp uint32 `protobuf:"fixed32,2,opt,name=destination_ip,json=destinationIp,proto3" json:"destination_ip,omitempty"`
}

func (x *IPV4Pair) Reset() {
	*x = IPV4Pair{}
	if protoimpl.UnsafeEnabled {
		mi := &file_tunneloffload_proto_msgTypes[10]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *IPV4Pair) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IPV4Pair) ProtoMessage() {}

func (x *IPV4Pair) ProtoReflect() protoreflect.Message {
	mi := &file_tunneloffload_proto_msgTypes[10]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IPV4Pair.ProtoReflect.Descriptor instead.
func (*IPV4Pair) Descriptor() ([]byte, []int) {
	return file_tunneloffload_proto_rawDescGZIP(), []int{10}
}

func (x *IPV4Pair) GetSourceIp() uint32 {
	if x != nil {
		return x.SourceIp
	}
	return 0
}

func (x *IPV4Pair) GetDestinationIp() uint32 {
	if x != nil {
		return x.DestinationIp
	}
	return 0
}

type IPV6Pair struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	SourceIp      []byte `protobuf:"bytes,1,opt,name=source_ip,json=sourceIp,proto3" json:"source_ip,omitempty"`
	DestinationIp []byte `protobuf:"bytes,2,opt,name=destination_ip,json=destinationIp,proto3" json:"destination_ip,omitempty"`
}

func (x *IPV6Pair) Reset() {
	*x = IPV6Pair{}
	if protoimpl.UnsafeEnabled {
		mi := &file_tunneloffload_proto_msgTypes[11]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *IPV6Pair) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IPV6Pair) ProtoMessage() {}

func (x *IPV6Pair) ProtoReflect() protoreflect.Message {
	mi := &file_tunneloffload_proto_msgTypes[11]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IPV6Pair.ProtoReflect.Descriptor instead.
func (*IPV6Pair) Descriptor() ([]byte, []int) {
	return file_tunneloffload_proto_rawDescGZIP(), []int{11}
}

func (x *IPV6Pair) GetSourceIp() []byte {
	if x != nil {
		return x.SourceIp
	}
	return nil
}

func (x *IPV6Pair) GetDestinationIp() []byte {
	if x != nil {
		return x.DestinationIp
	}
	return nil
}

type IPV4Match struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	SourceIp            uint32 `protobuf:"fixed32,1,opt,name=source_ip,json=sourceIp,proto3" json:"source_ip,omitempty"`
	SourceIpPrefix      uint32 `protobuf:"varint,2,opt,name=source_ip_prefix,json=sourceIpPrefix,proto3" json:"source_ip_prefix,omitempty"`
	DestinationIp       uint32 `protobuf:"fixed32,3,opt,name=destination_ip,json=destinationIp,proto3" json:"destination_ip,omitempty"`
	DestinationIpPrefix uint32 `protobuf:"varint,4,opt,name=destination_ip_prefix,json=destinationIpPrefix,proto3" json:"destination_ip_prefix,omitempty"`
}

func (x *IPV4Match) Reset() {
	*x = IPV4Match{}
	if protoimpl.UnsafeEnabled {
		mi := &file_tunneloffload_proto_msgTypes[12]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *IPV4Match) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IPV4Match) ProtoMessage() {}

func (x *IPV4Match) ProtoReflect() protoreflect.Message {
	mi := &file_tunneloffload_proto_msgTypes[12]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IPV4Match.ProtoReflect.Descriptor instead.
func (*IPV4Match) Descriptor() ([]byte, []int) {
	return file_tunneloffload_proto_rawDescGZIP(), []int{12}
}

func (x *IPV4Match) GetSourceIp() uint32 {
	if x != nil {
		return x.SourceIp
	}
	return 0
}

func (x *IPV4Match) GetSourceIpPrefix() uint32 {
	if x != nil {
		return x.SourceIpPrefix
	}
	return 0
}

func (x *IPV4Match) GetDestinationIp() uint32 {
	if x != nil {
		return x.DestinationIp
	}
	return 0
}

func (x *IPV4Match) GetDestinationIpPrefix() uint32 {
	if x != nil {
		return x.DestinationIpPrefix
	}
	return 0
}

type IPV6Match struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	SourceIp            []byte `protobuf:"bytes,1,opt,name=source_ip,json=sourceIp,proto3" json:"source_ip,omitempty"`
	SourceIpPrefix      uint32 `protobuf:"varint,2,opt,name=source_ip_prefix,json=sourceIpPrefix,proto3" json:"source_ip_prefix,omitempty"`
	DestinationIp       []byte `protobuf:"bytes,3,opt,name=destination_ip,json=destinationIp,proto3" json:"destination_ip,omitempty"`
	DestinationIpPrefix uint32 `protobuf:"varint,4,opt,name=destination_ip_prefix,json=destinationIpPrefix,proto3" json:"destination_ip_prefix,omitempty"`
}

func (x *IPV6Match) Reset() {
	*x = IPV6Match{}
	if protoimpl.UnsafeEnabled {
		mi := &file_tunneloffload_proto_msgTypes[13]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *IPV6Match) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IPV6Match) ProtoMessage() {}

func (x *IPV6Match) ProtoReflect() protoreflect.Message {
	mi := &file_tunneloffload_proto_msgTypes[13]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IPV6Match.ProtoReflect.Descriptor instead.
func (*IPV6Match) Descriptor() ([]byte, []int) {
	return file_tunneloffload_proto_rawDescGZIP(), []int{13}
}

func (x *IPV6Match) GetSourceIp() []byte {
	if x != nil {
		return x.SourceIp
	}
	return nil
}

func (x *IPV6Match) GetSourceIpPrefix() uint32 {
	if x != nil {
		return x.SourceIpPrefix
	}
	return 0
}

func (x *IPV6Match) GetDestinationIp() []byte {
	if x != nil {
		return x.DestinationIp
	}
	return nil
}

func (x *IPV6Match) GetDestinationIpPrefix() uint32 {
	if x != nil {
		return x.DestinationIpPrefix
	}
	return 0
}

type Nat struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	SourceIp uint32 `protobuf:"varint,1,opt,name=source_ip,json=sourceIp,proto3" json:"source_ip,omitempty"`
}

func (x *Nat) Reset() {
	*x = Nat{}
	if protoimpl.UnsafeEnabled {
		mi := &file_tunneloffload_proto_msgTypes[14]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Nat) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Nat) ProtoMessage() {}

func (x *Nat) ProtoReflect() protoreflect.Message {
	mi := &file_tunneloffload_proto_msgTypes[14]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Nat.ProtoReflect.Descriptor instead.
func (*Nat) Descriptor() ([]byte, []int) {
	return file_tunneloffload_proto_rawDescGZIP(), []int{14}
}

func (x *Nat) GetSourceIp() uint32 {
	if x != nil {
		return x.SourceIp
	}
	return 0
}

type IPSecEnc struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	TunnelType     IPSecTunnelType `protobuf:"varint,1,opt,name=tunnel_type,json=tunnelType,proto3,enum=tunneloffload.v2.IPSecTunnelType" json:"tunnel_type,omitempty"`
	EncryptionType EncType         `protobuf:"varint,2,opt,name=encryption_type,json=encryptionType,proto3,enum=tunneloffload.v2.EncType" json:"encryption_type,omitempty"`
	IpsecSa        *IPSecSAParams  `protobuf:"bytes,3,opt,name=ipsec_sa,json=ipsecSa,proto3" json:"ipsec_sa,omitempty"`
	// In case the ipsec tunnel is with tunnel mode,
	// one of the messages below should present
	//
	// Types that are assignable to TunnelIps:
	//	*IPSecEnc_Ipv4Tunnel
	//	*IPSecEnc_Ipv6Tunnel
	TunnelIps isIPSecEnc_TunnelIps `protobuf_oneof:"tunnelIps"`
}

func (x *IPSecEnc) Reset() {
	*x = IPSecEnc{}
	if protoimpl.UnsafeEnabled {
		mi := &file_tunneloffload_proto_msgTypes[15]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *IPSecEnc) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IPSecEnc) ProtoMessage() {}

func (x *IPSecEnc) ProtoReflect() protoreflect.Message {
	mi := &file_tunneloffload_proto_msgTypes[15]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IPSecEnc.ProtoReflect.Descriptor instead.
func (*IPSecEnc) Descriptor() ([]byte, []int) {
	return file_tunneloffload_proto_rawDescGZIP(), []int{15}
}

func (x *IPSecEnc) GetTunnelType() IPSecTunnelType {
	if x != nil {
		return x.TunnelType
	}
	return IPSecTunnelType_TRANSPORT
}

func (x *IPSecEnc) GetEncryptionType() EncType {
	if x != nil {
		return x.EncryptionType
	}
	return EncType__AES256GCM64
}

func (x *IPSecEnc) GetIpsecSa() *IPSecSAParams {
	if x != nil {
		return x.IpsecSa
	}
	return nil
}

func (m *IPSecEnc) GetTunnelIps() isIPSecEnc_TunnelIps {
	if m != nil {
		return m.TunnelIps
	}
	return nil
}

func (x *IPSecEnc) GetIpv4Tunnel() *IPV4Pair {
	if x, ok := x.GetTunnelIps().(*IPSecEnc_Ipv4Tunnel); ok {
		return x.Ipv4Tunnel
	}
	return nil
}

func (x *IPSecEnc) GetIpv6Tunnel() *IPV6Pair {
	if x, ok := x.GetTunnelIps().(*IPSecEnc_Ipv6Tunnel); ok {
		return x.Ipv6Tunnel
	}
	return nil
}

type isIPSecEnc_TunnelIps interface {
	isIPSecEnc_TunnelIps()
}

type IPSecEnc_Ipv4Tunnel struct {
	Ipv4Tunnel *IPV4Pair `protobuf:"bytes,4,opt,name=ipv4_tunnel,json=ipv4Tunnel,proto3,oneof"`
}

type IPSecEnc_Ipv6Tunnel struct {
	Ipv6Tunnel *IPV6Pair `protobuf:"bytes,5,opt,name=ipv6_tunnel,json=ipv6Tunnel,proto3,oneof"`
}

func (*IPSecEnc_Ipv4Tunnel) isIPSecEnc_TunnelIps() {}

func (*IPSecEnc_Ipv6Tunnel) isIPSecEnc_TunnelIps() {}

type IPSecDec struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	TunnelType     IPSecTunnelType  `protobuf:"varint,1,opt,name=tunnel_type,json=tunnelType,proto3,enum=tunneloffload.v2.IPSecTunnelType" json:"tunnel_type,omitempty"`     // Transport / Tunnel...
	EncryptionType EncType          `protobuf:"varint,2,opt,name=encryption_type,json=encryptionType,proto3,enum=tunneloffload.v2.EncType" json:"encryption_type,omitempty"` // AES-256GCM
	IpsecSas       []*IPSecSAParams `protobuf:"bytes,3,rep,name=ipsec_sas,json=ipsecSas,proto3" json:"ipsec_sas,omitempty"`
}

func (x *IPSecDec) Reset() {
	*x = IPSecDec{}
	if protoimpl.UnsafeEnabled {
		mi := &file_tunneloffload_proto_msgTypes[16]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *IPSecDec) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IPSecDec) ProtoMessage() {}

func (x *IPSecDec) ProtoReflect() protoreflect.Message {
	mi := &file_tunneloffload_proto_msgTypes[16]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IPSecDec.ProtoReflect.Descriptor instead.
func (*IPSecDec) Descriptor() ([]byte, []int) {
	return file_tunneloffload_proto_rawDescGZIP(), []int{16}
}

func (x *IPSecDec) GetTunnelType() IPSecTunnelType {
	if x != nil {
		return x.TunnelType
	}
	return IPSecTunnelType_TRANSPORT
}

func (x *IPSecDec) GetEncryptionType() EncType {
	if x != nil {
		return x.EncryptionType
	}
	return EncType__AES256GCM64
}

func (x *IPSecDec) GetIpsecSas() []*IPSecSAParams {
	if x != nil {
		return x.IpsecSas
	}
	return nil
}

type IPSecSAParams struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Spi           uint32    `protobuf:"varint,1,opt,name=spi,proto3" json:"spi,omitempty"`
	EncryptionKey []byte    `protobuf:"bytes,2,opt,name=encryption_key,json=encryptionKey,proto3" json:"encryption_key,omitempty"`
	Operation     Operation `protobuf:"varint,3,opt,name=operation,proto3,enum=tunneloffload.v2.Operation" json:"operation,omitempty"` // Indicates if removing / updating / creating SA
}

func (x *IPSecSAParams) Reset() {
	*x = IPSecSAParams{}
	if protoimpl.UnsafeEnabled {
		mi := &file_tunneloffload_proto_msgTypes[17]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *IPSecSAParams) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IPSecSAParams) ProtoMessage() {}

func (x *IPSecSAParams) ProtoReflect() protoreflect.Message {
	mi := &file_tunneloffload_proto_msgTypes[17]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IPSecSAParams.ProtoReflect.Descriptor instead.
func (*IPSecSAParams) Descriptor() ([]byte, []int) {
	return file_tunneloffload_proto_rawDescGZIP(), []int{17}
}

func (x *IPSecSAParams) GetSpi() uint32 {
	if x != nil {
		return x.Spi
	}
	return 0
}

func (x *IPSecSAParams) GetEncryptionKey() []byte {
	if x != nil {
		return x.EncryptionKey
	}
	return nil
}

func (x *IPSecSAParams) GetOperation() Operation {
	if x != nil {
		return x.Operation
	}
	return Operation__NONE
}

type IPSecTunnel struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Types that are assignable to Ipsec:
	//	*IPSecTunnel_IpsecEnc
	//	*IPSecTunnel_IpsecDec
	Ipsec isIPSecTunnel_Ipsec `protobuf_oneof:"ipsec"`
}

func (x *IPSecTunnel) Reset() {
	*x = IPSecTunnel{}
	if protoimpl.UnsafeEnabled {
		mi := &file_tunneloffload_proto_msgTypes[18]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *IPSecTunnel) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IPSecTunnel) ProtoMessage() {}

func (x *IPSecTunnel) ProtoReflect() protoreflect.Message {
	mi := &file_tunneloffload_proto_msgTypes[18]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IPSecTunnel.ProtoReflect.Descriptor instead.
func (*IPSecTunnel) Descriptor() ([]byte, []int) {
	return file_tunneloffload_proto_rawDescGZIP(), []int{18}
}

func (m *IPSecTunnel) GetIpsec() isIPSecTunnel_Ipsec {
	if m != nil {
		return m.Ipsec
	}
	return nil
}

func (x *IPSecTunnel) GetIpsecEnc() *IPSecEnc {
	if x, ok := x.GetIpsec().(*IPSecTunnel_IpsecEnc); ok {
		return x.IpsecEnc
	}
	return nil
}

func (x *IPSecTunnel) GetIpsecDec() *IPSecDec {
	if x, ok := x.GetIpsec().(*IPSecTunnel_IpsecDec); ok {
		return x.IpsecDec
	}
	return nil
}

type isIPSecTunnel_Ipsec interface {
	isIPSecTunnel_Ipsec()
}

type IPSecTunnel_IpsecEnc struct {
	IpsecEnc *IPSecEnc `protobuf:"bytes,1,opt,name=ipsec_enc,json=ipsecEnc,proto3,oneof"`
}

type IPSecTunnel_IpsecDec struct {
	IpsecDec *IPSecDec `protobuf:"bytes,2,opt,name=ipsec_dec,json=ipsecDec,proto3,oneof"`
}

func (*IPSecTunnel_IpsecEnc) isIPSecTunnel_Ipsec() {}

func (*IPSecTunnel_IpsecDec) isIPSecTunnel_Ipsec() {}

type TunnelId struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	TunnelId uint64 `protobuf:"varint,1,opt,name=tunnel_id,json=tunnelId,proto3" json:"tunnel_id,omitempty"`
}

func (x *TunnelId) Reset() {
	*x = TunnelId{}
	if protoimpl.UnsafeEnabled {
		mi := &file_tunneloffload_proto_msgTypes[19]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *TunnelId) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TunnelId) ProtoMessage() {}

func (x *TunnelId) ProtoReflect() protoreflect.Message {
	mi := &file_tunneloffload_proto_msgTypes[19]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TunnelId.ProtoReflect.Descriptor instead.
func (*TunnelId) Descriptor() ([]byte, []int) {
	return file_tunneloffload_proto_rawDescGZIP(), []int{19}
}

func (x *TunnelId) GetTunnelId() uint64 {
	if x != nil {
		return x.TunnelId
	}
	return 0
}

type Counters struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	InPackets       uint64 `protobuf:"varint,1,opt,name=in_packets,json=inPackets,proto3" json:"in_packets,omitempty"`
	OutPackets      uint64 `protobuf:"varint,2,opt,name=out_packets,json=outPackets,proto3" json:"out_packets,omitempty"`
	InBytes         uint64 `protobuf:"varint,3,opt,name=in_bytes,json=inBytes,proto3" json:"in_bytes,omitempty"`
	OutBytes        uint64 `protobuf:"varint,4,opt,name=out_bytes,json=outBytes,proto3" json:"out_bytes,omitempty"`
	InPacketsDrops  uint64 `protobuf:"varint,5,opt,name=in_packets_drops,json=inPacketsDrops,proto3" json:"in_packets_drops,omitempty"`
	OutPacketsDrops uint64 `protobuf:"varint,6,opt,name=out_packets_drops,json=outPacketsDrops,proto3" json:"out_packets_drops,omitempty"`
	InBytesDrops    uint64 `protobuf:"varint,7,opt,name=in_bytes_drops,json=inBytesDrops,proto3" json:"in_bytes_drops,omitempty"`
	OutBytesDrops   uint64 `protobuf:"varint,8,opt,name=out_bytes_drops,json=outBytesDrops,proto3" json:"out_bytes_drops,omitempty"`
}

func (x *Counters) Reset() {
	*x = Counters{}
	if protoimpl.UnsafeEnabled {
		mi := &file_tunneloffload_proto_msgTypes[20]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Counters) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Counters) ProtoMessage() {}

func (x *Counters) ProtoReflect() protoreflect.Message {
	mi := &file_tunneloffload_proto_msgTypes[20]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Counters.ProtoReflect.Descriptor instead.
func (*Counters) Descriptor() ([]byte, []int) {
	return file_tunneloffload_proto_rawDescGZIP(), []int{20}
}

func (x *Counters) GetInPackets() uint64 {
	if x != nil {
		return x.InPackets
	}
	return 0
}

func (x *Counters) GetOutPackets() uint64 {
	if x != nil {
		return x.OutPackets
	}
	return 0
}

func (x *Counters) GetInBytes() uint64 {
	if x != nil {
		return x.InBytes
	}
	return 0
}

func (x *Counters) GetOutBytes() uint64 {
	if x != nil {
		return x.OutBytes
	}
	return 0
}

func (x *Counters) GetInPacketsDrops() uint64 {
	if x != nil {
		return x.InPacketsDrops
	}
	return 0
}

func (x *Counters) GetOutPacketsDrops() uint64 {
	if x != nil {
		return x.OutPacketsDrops
	}
	return 0
}

func (x *Counters) GetInBytesDrops() uint64 {
	if x != nil {
		return x.InBytesDrops
	}
	return 0
}

func (x *Counters) GetOutBytesDrops() uint64 {
	if x != nil {
		return x.OutBytesDrops
	}
	return 0
}

type CreateIpTunnelResponses struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	RequestStatus AddTunnelStatus           `protobuf:"varint,1,opt,name=request_status,json=requestStatus,proto3,enum=tunneloffload.v2.AddTunnelStatus" json:"request_status,omitempty"`
	ErrorStatus   uint64                    `protobuf:"varint,2,opt,name=error_status,json=errorStatus,proto3" json:"error_status,omitempty"` // bitmask of errors for each of the sesssions sent in a stream (max 64).
	Responses     []*CreateIpTunnelResponse `protobuf:"bytes,3,rep,name=responses,proto3" json:"responses,omitempty"`
}

func (x *CreateIpTunnelResponses) Reset() {
	*x = CreateIpTunnelResponses{}
	if protoimpl.UnsafeEnabled {
		mi := &file_tunneloffload_proto_msgTypes[21]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *CreateIpTunnelResponses) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CreateIpTunnelResponses) ProtoMessage() {}

func (x *CreateIpTunnelResponses) ProtoReflect() protoreflect.Message {
	mi := &file_tunneloffload_proto_msgTypes[21]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CreateIpTunnelResponses.ProtoReflect.Descriptor instead.
func (*CreateIpTunnelResponses) Descriptor() ([]byte, []int) {
	return file_tunneloffload_proto_rawDescGZIP(), []int{21}
}

func (x *CreateIpTunnelResponses) GetRequestStatus() AddTunnelStatus {
	if x != nil {
		return x.RequestStatus
	}
	return AddTunnelStatus__TUNNEL_ACCEPTED
}

func (x *CreateIpTunnelResponses) GetErrorStatus() uint64 {
	if x != nil {
		return x.ErrorStatus
	}
	return 0
}

func (x *CreateIpTunnelResponses) GetResponses() []*CreateIpTunnelResponse {
	if x != nil {
		return x.Responses
	}
	return nil
}

type CreateIpTunnelResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Tunnel ID assigned to this tunnel
	TunnelId uint64 `protobuf:"varint,1,opt,name=tunnel_id,json=tunnelId,proto3" json:"tunnel_id,omitempty"`
	// Message appears only if there's error in the response
	Error *Error `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
}

func (x *CreateIpTunnelResponse) Reset() {
	*x = CreateIpTunnelResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_tunneloffload_proto_msgTypes[22]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *CreateIpTunnelResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CreateIpTunnelResponse) ProtoMessage() {}

func (x *CreateIpTunnelResponse) ProtoReflect() protoreflect.Message {
	mi := &file_tunneloffload_proto_msgTypes[22]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CreateIpTunnelResponse.ProtoReflect.Descriptor instead.
func (*CreateIpTunnelResponse) Descriptor() ([]byte, []int) {
	return file_tunneloffload_proto_rawDescGZIP(), []int{22}
}

func (x *CreateIpTunnelResponse) GetTunnelId() uint64 {
	if x != nil {
		return x.TunnelId
	}
	return 0
}

func (x *CreateIpTunnelResponse) GetError() *Error {
	if x != nil {
		return x.Error
	}
	return nil
}

type Error struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Error code describing the error with the request
	ErrorMessage *TunnelAdditionError `protobuf:"bytes,1,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
	// Error string indicating the error
	ErrorString string `protobuf:"bytes,2,opt,name=error_string,json=errorString,proto3" json:"error_string,omitempty"`
}

func (x *Error) Reset() {
	*x = Error{}
	if protoimpl.UnsafeEnabled {
		mi := &file_tunneloffload_proto_msgTypes[23]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Error) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Error) ProtoMessage() {}

func (x *Error) ProtoReflect() protoreflect.Message {
	mi := &file_tunneloffload_proto_msgTypes[23]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Error.ProtoReflect.Descriptor instead.
func (*Error) Descriptor() ([]byte, []int) {
	return file_tunneloffload_proto_rawDescGZIP(), []int{23}
}

func (x *Error) GetErrorMessage() *TunnelAdditionError {
	if x != nil {
		return x.ErrorMessage
	}
	return nil
}

func (x *Error) GetErrorString() string {
	if x != nil {
		return x.ErrorString
	}
	return ""
}

type IpTunnelResponses struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Responses []*IpTunnelResponse `protobuf:"bytes,1,rep,name=responses,proto3" json:"responses,omitempty"`
}

func (x *IpTunnelResponses) Reset() {
	*x = IpTunnelResponses{}
	if protoimpl.UnsafeEnabled {
		mi := &file_tunneloffload_proto_msgTypes[24]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *IpTunnelResponses) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IpTunnelResponses) ProtoMessage() {}

func (x *IpTunnelResponses) ProtoReflect() protoreflect.Message {
	mi := &file_tunneloffload_proto_msgTypes[24]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IpTunnelResponses.ProtoReflect.Descriptor instead.
func (*IpTunnelResponses) Descriptor() ([]byte, []int) {
	return file_tunneloffload_proto_rawDescGZIP(), []int{24}
}

func (x *IpTunnelResponses) GetResponses() []*IpTunnelResponse {
	if x != nil {
		return x.Responses
	}
	return nil
}

type IpTunnelResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Tunnel ID assigned to this tunnel
	TunnelId uint64 `protobuf:"varint,1,opt,name=tunnel_id,json=tunnelId,proto3" json:"tunnel_id,omitempty"`
	// Information regards the ipTunnel (including match, tunnel information)
	IpTunnel *IpTunnelRequest `protobuf:"bytes,2,opt,name=ip_tunnel,json=ipTunnel,proto3" json:"ip_tunnel,omitempty"`
	// Counters of the session
	TunnelCounters *Counters `protobuf:"bytes,3,opt,name=tunnel_counters,json=tunnelCounters,proto3" json:"tunnel_counters,omitempty"`
	// Message that appears only if there's a problem in the request
	Error *Error `protobuf:"bytes,4,opt,name=error,proto3" json:"error,omitempty"`
}

func (x *IpTunnelResponse) Reset() {
	*x = IpTunnelResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_tunneloffload_proto_msgTypes[25]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *IpTunnelResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IpTunnelResponse) ProtoMessage() {}

func (x *IpTunnelResponse) ProtoReflect() protoreflect.Message {
	mi := &file_tunneloffload_proto_msgTypes[25]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IpTunnelResponse.ProtoReflect.Descriptor instead.
func (*IpTunnelResponse) Descriptor() ([]byte, []int) {
	return file_tunneloffload_proto_rawDescGZIP(), []int{25}
}

func (x *IpTunnelResponse) GetTunnelId() uint64 {
	if x != nil {
		return x.TunnelId
	}
	return 0
}

func (x *IpTunnelResponse) GetIpTunnel() *IpTunnelRequest {
	if x != nil {
		return x.IpTunnel
	}
	return nil
}

func (x *IpTunnelResponse) GetTunnelCounters() *Counters {
	if x != nil {
		return x.TunnelCounters
	}
	return nil
}

func (x *IpTunnelResponse) GetError() *Error {
	if x != nil {
		return x.Error
	}
	return nil
}

type IpTunnelStatsResponses struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Responses []*IpTunnelStatsResponse `protobuf:"bytes,1,rep,name=responses,proto3" json:"responses,omitempty"`
}

func (x *IpTunnelStatsResponses) Reset() {
	*x = IpTunnelStatsResponses{}
	if protoimpl.UnsafeEnabled {
		mi := &file_tunneloffload_proto_msgTypes[26]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *IpTunnelStatsResponses) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IpTunnelStatsResponses) ProtoMessage() {}

func (x *IpTunnelStatsResponses) ProtoReflect() protoreflect.Message {
	mi := &file_tunneloffload_proto_msgTypes[26]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IpTunnelStatsResponses.ProtoReflect.Descriptor instead.
func (*IpTunnelStatsResponses) Descriptor() ([]byte, []int) {
	return file_tunneloffload_proto_rawDescGZIP(), []int{26}
}

func (x *IpTunnelStatsResponses) GetResponses() []*IpTunnelStatsResponse {
	if x != nil {
		return x.Responses
	}
	return nil
}

type IpTunnelStatsResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Tunnel ID assigned to this tunnel
	TunnelId uint64 `protobuf:"varint,1,opt,name=tunnel_id,json=tunnelId,proto3" json:"tunnel_id,omitempty"`
	// Counters of the session
	TunnelCounters *Counters `protobuf:"bytes,2,opt,name=tunnel_counters,json=tunnelCounters,proto3" json:"tunnel_counters,omitempty"`
	// Message that appears only if there's a problem in the request
	Error *Error `protobuf:"bytes,3,opt,name=error,proto3" json:"error,omitempty"`
}

func (x *IpTunnelStatsResponse) Reset() {
	*x = IpTunnelStatsResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_tunneloffload_proto_msgTypes[27]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *IpTunnelStatsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IpTunnelStatsResponse) ProtoMessage() {}

func (x *IpTunnelStatsResponse) ProtoReflect() protoreflect.Message {
	mi := &file_tunneloffload_proto_msgTypes[27]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IpTunnelStatsResponse.ProtoReflect.Descriptor instead.
func (*IpTunnelStatsResponse) Descriptor() ([]byte, []int) {
	return file_tunneloffload_proto_rawDescGZIP(), []int{27}
}

func (x *IpTunnelStatsResponse) GetTunnelId() uint64 {
	if x != nil {
		return x.TunnelId
	}
	return 0
}

func (x *IpTunnelStatsResponse) GetTunnelCounters() *Counters {
	if x != nil {
		return x.TunnelCounters
	}
	return nil
}

func (x *IpTunnelStatsResponse) GetError() *Error {
	if x != nil {
		return x.Error
	}
	return nil
}

type TunnelRequestArgs struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	TunnelsPerRequest uint32 `protobuf:"varint,1,opt,name=tunnels_per_request,json=tunnelsPerRequest,proto3" json:"tunnels_per_request,omitempty"` // How many tunnels will be returned per request
}

func (x *TunnelRequestArgs) Reset() {
	*x = TunnelRequestArgs{}
	if protoimpl.UnsafeEnabled {
		mi := &file_tunneloffload_proto_msgTypes[28]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *TunnelRequestArgs) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TunnelRequestArgs) ProtoMessage() {}

func (x *TunnelRequestArgs) ProtoReflect() protoreflect.Message {
	mi := &file_tunneloffload_proto_msgTypes[28]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TunnelRequestArgs.ProtoReflect.Descriptor instead.
func (*TunnelRequestArgs) Descriptor() ([]byte, []int) {
	return file_tunneloffload_proto_rawDescGZIP(), []int{28}
}

func (x *TunnelRequestArgs) GetTunnelsPerRequest() uint32 {
	if x != nil {
		return x.TunnelsPerRequest
	}
	return 0
}

type CapabilityResponse_MatchCapabilities struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	IngressInterfaceMatching bool `protobuf:"varint,1,opt,name=ingress_interface_matching,json=ingressInterfaceMatching,proto3" json:"ingress_interface_matching,omitempty"` // Is interface can be matched for encapsulation / decapsulation
	VxlanMatching            bool `protobuf:"varint,2,opt,name=vxlan_matching,json=vxlanMatching,proto3" json:"vxlan_matching,omitempty"`                                    // Match with VXLAN VNI
	GeneveMatching           bool `protobuf:"varint,3,opt,name=geneve_matching,json=geneveMatching,proto3" json:"geneve_matching,omitempty"`                                 // Match with geneve can happen
	TunnelMatching           bool `protobuf:"varint,4,opt,name=tunnel_matching,json=tunnelMatching,proto3" json:"tunnel_matching,omitempty"`                                 // Matching on tunnel ID
	SpiMatching              bool `protobuf:"varint,5,opt,name=spi_matching,json=spiMatching,proto3" json:"spi_matching,omitempty"`                                          // Can match on IPSec
}

func (x *CapabilityResponse_MatchCapabilities) Reset() {
	*x = CapabilityResponse_MatchCapabilities{}
	if protoimpl.UnsafeEnabled {
		mi := &file_tunneloffload_proto_msgTypes[29]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *CapabilityResponse_MatchCapabilities) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CapabilityResponse_MatchCapabilities) ProtoMessage() {}

func (x *CapabilityResponse_MatchCapabilities) ProtoReflect() protoreflect.Message {
	mi := &file_tunneloffload_proto_msgTypes[29]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CapabilityResponse_MatchCapabilities.ProtoReflect.Descriptor instead.
func (*CapabilityResponse_MatchCapabilities) Descriptor() ([]byte, []int) {
	return file_tunneloffload_proto_rawDescGZIP(), []int{1, 0}
}

func (x *CapabilityResponse_MatchCapabilities) GetIngressInterfaceMatching() bool {
	if x != nil {
		return x.IngressInterfaceMatching
	}
	return false
}

func (x *CapabilityResponse_MatchCapabilities) GetVxlanMatching() bool {
	if x != nil {
		return x.VxlanMatching
	}
	return false
}

func (x *CapabilityResponse_MatchCapabilities) GetGeneveMatching() bool {
	if x != nil {
		return x.GeneveMatching
	}
	return false
}

func (x *CapabilityResponse_MatchCapabilities) GetTunnelMatching() bool {
	if x != nil {
		return x.TunnelMatching
	}
	return false
}

func (x *CapabilityResponse_MatchCapabilities) GetSpiMatching() bool {
	if x != nil {
		return x.SpiMatching
	}
	return false
}

type CapabilityResponse_IPSecCapabilities struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	TunnelTypeSupported []IPSecTunnelType `protobuf:"varint,1,rep,packed,name=tunnel_type_supported,json=tunnelTypeSupported,proto3,enum=tunneloffload.v2.IPSecTunnelType" json:"tunnel_type_supported,omitempty"`
	EncryptionSupported []EncType         `protobuf:"varint,2,rep,packed,name=encryption_supported,json=encryptionSupported,proto3,enum=tunneloffload.v2.EncType" json:"encryption_supported,omitempty"`
}

func (x *CapabilityResponse_IPSecCapabilities) Reset() {
	*x = CapabilityResponse_IPSecCapabilities{}
	if protoimpl.UnsafeEnabled {
		mi := &file_tunneloffload_proto_msgTypes[30]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *CapabilityResponse_IPSecCapabilities) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CapabilityResponse_IPSecCapabilities) ProtoMessage() {}

func (x *CapabilityResponse_IPSecCapabilities) ProtoReflect() protoreflect.Message {
	mi := &file_tunneloffload_proto_msgTypes[30]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CapabilityResponse_IPSecCapabilities.ProtoReflect.Descriptor instead.
func (*CapabilityResponse_IPSecCapabilities) Descriptor() ([]byte, []int) {
	return file_tunneloffload_proto_rawDescGZIP(), []int{1, 1}
}

func (x *CapabilityResponse_IPSecCapabilities) GetTunnelTypeSupported() []IPSecTunnelType {
	if x != nil {
		return x.TunnelTypeSupported
	}
	return nil
}

func (x *CapabilityResponse_IPSecCapabilities) GetEncryptionSupported() []EncType {
	if x != nil {
		return x.EncryptionSupported
	}
	return nil
}

type CapabilityResponse_GeneveCapabilities struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	NumberGeneveOptionsSupported uint32 `protobuf:"varint,1,opt,name=number_geneve_options_supported,json=numberGeneveOptionsSupported,proto3" json:"number_geneve_options_supported,omitempty"` // Number of options geneve is supporting in encap
}

func (x *CapabilityResponse_GeneveCapabilities) Reset() {
	*x = CapabilityResponse_GeneveCapabilities{}
	if protoimpl.UnsafeEnabled {
		mi := &file_tunneloffload_proto_msgTypes[31]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *CapabilityResponse_GeneveCapabilities) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CapabilityResponse_GeneveCapabilities) ProtoMessage() {}

func (x *CapabilityResponse_GeneveCapabilities) ProtoReflect() protoreflect.Message {
	mi := &file_tunneloffload_proto_msgTypes[31]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CapabilityResponse_GeneveCapabilities.ProtoReflect.Descriptor instead.
func (*CapabilityResponse_GeneveCapabilities) Descriptor() ([]byte, []int) {
	return file_tunneloffload_proto_rawDescGZIP(), []int{1, 2}
}

func (x *CapabilityResponse_GeneveCapabilities) GetNumberGeneveOptionsSupported() uint32 {
	if x != nil {
		return x.NumberGeneveOptionsSupported
	}
	return 0
}

type MatchCriteria_IPSecMatch struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Spi uint32 `protobuf:"varint,1,opt,name=spi,proto3" json:"spi,omitempty"`
	Sn  uint32 `protobuf:"varint,2,opt,name=sn,proto3" json:"sn,omitempty"`
}

func (x *MatchCriteria_IPSecMatch) Reset() {
	*x = MatchCriteria_IPSecMatch{}
	if protoimpl.UnsafeEnabled {
		mi := &file_tunneloffload_proto_msgTypes[32]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MatchCriteria_IPSecMatch) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MatchCriteria_IPSecMatch) ProtoMessage() {}

func (x *MatchCriteria_IPSecMatch) ProtoReflect() protoreflect.Message {
	mi := &file_tunneloffload_proto_msgTypes[32]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MatchCriteria_IPSecMatch.ProtoReflect.Descriptor instead.
func (*MatchCriteria_IPSecMatch) Descriptor() ([]byte, []int) {
	return file_tunneloffload_proto_rawDescGZIP(), []int{3, 0}
}

func (x *MatchCriteria_IPSecMatch) GetSpi() uint32 {
	if x != nil {
		return x.Spi
	}
	return 0
}

func (x *MatchCriteria_IPSecMatch) GetSn() uint32 {
	if x != nil {
		return x.Sn
	}
	return 0
}

type MatchCriteria_GeneveMatch struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Vni          uint32   `protobuf:"varint,1,opt,name=vni,proto3" json:"vni,omitempty"`
	MacMatch     *MacPair `protobuf:"bytes,2,opt,name=mac_match,json=macMatch,proto3" json:"mac_match,omitempty"`              // Inner Match of Geneve Packet
	ProtocolType uint32   `protobuf:"varint,3,opt,name=protocol_type,json=protocolType,proto3" json:"protocol_type,omitempty"` // Currently only "Trans Ether Bridging" is supported (0x6558)
	// Types that are assignable to IpMatch:
	//	*MatchCriteria_GeneveMatch_Ipv4Match
	//	*MatchCriteria_GeneveMatch_Ipv6Match
	IpMatch isMatchCriteria_GeneveMatch_IpMatch `protobuf_oneof:"ip_match"`
}

func (x *MatchCriteria_GeneveMatch) Reset() {
	*x = MatchCriteria_GeneveMatch{}
	if protoimpl.UnsafeEnabled {
		mi := &file_tunneloffload_proto_msgTypes[33]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MatchCriteria_GeneveMatch) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MatchCriteria_GeneveMatch) ProtoMessage() {}

func (x *MatchCriteria_GeneveMatch) ProtoReflect() protoreflect.Message {
	mi := &file_tunneloffload_proto_msgTypes[33]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MatchCriteria_GeneveMatch.ProtoReflect.Descriptor instead.
func (*MatchCriteria_GeneveMatch) Descriptor() ([]byte, []int) {
	return file_tunneloffload_proto_rawDescGZIP(), []int{3, 1}
}

func (x *MatchCriteria_GeneveMatch) GetVni() uint32 {
	if x != nil {
		return x.Vni
	}
	return 0
}

func (x *MatchCriteria_GeneveMatch) GetMacMatch() *MacPair {
	if x != nil {
		return x.MacMatch
	}
	return nil
}

func (x *MatchCriteria_GeneveMatch) GetProtocolType() uint32 {
	if x != nil {
		return x.ProtocolType
	}
	return 0
}

func (m *MatchCriteria_GeneveMatch) GetIpMatch() isMatchCriteria_GeneveMatch_IpMatch {
	if m != nil {
		return m.IpMatch
	}
	return nil
}

func (x *MatchCriteria_GeneveMatch) GetIpv4Match() *IPV4Match {
	if x, ok := x.GetIpMatch().(*MatchCriteria_GeneveMatch_Ipv4Match); ok {
		return x.Ipv4Match
	}
	return nil
}

func (x *MatchCriteria_GeneveMatch) GetIpv6Match() *IPV6Match {
	if x, ok := x.GetIpMatch().(*MatchCriteria_GeneveMatch_Ipv6Match); ok {
		return x.Ipv6Match
	}
	return nil
}

type isMatchCriteria_GeneveMatch_IpMatch interface {
	isMatchCriteria_GeneveMatch_IpMatch()
}

type MatchCriteria_GeneveMatch_Ipv4Match struct {
	Ipv4Match *IPV4Match `protobuf:"bytes,4,opt,name=ipv4_match,json=ipv4Match,proto3,oneof"`
}

type MatchCriteria_GeneveMatch_Ipv6Match struct {
	Ipv6Match *IPV6Match `protobuf:"bytes,5,opt,name=ipv6_match,json=ipv6Match,proto3,oneof"`
}

func (*MatchCriteria_GeneveMatch_Ipv4Match) isMatchCriteria_GeneveMatch_IpMatch() {}

func (*MatchCriteria_GeneveMatch_Ipv6Match) isMatchCriteria_GeneveMatch_IpMatch() {}

type MatchCriteria_VXLanMatch struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Vni      uint32   `protobuf:"varint,1,opt,name=vni,proto3" json:"vni,omitempty"`
	MacMatch *MacPair `protobuf:"bytes,2,opt,name=mac_match,json=macMatch,proto3" json:"mac_match,omitempty"`
	// Types that are assignable to IpMatch:
	//	*MatchCriteria_VXLanMatch_Ipv4Match
	//	*MatchCriteria_VXLanMatch_Ipv6Match
	IpMatch isMatchCriteria_VXLanMatch_IpMatch `protobuf_oneof:"ip_match"`
}

func (x *MatchCriteria_VXLanMatch) Reset() {
	*x = MatchCriteria_VXLanMatch{}
	if protoimpl.UnsafeEnabled {
		mi := &file_tunneloffload_proto_msgTypes[34]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MatchCriteria_VXLanMatch) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MatchCriteria_VXLanMatch) ProtoMessage() {}

func (x *MatchCriteria_VXLanMatch) ProtoReflect() protoreflect.Message {
	mi := &file_tunneloffload_proto_msgTypes[34]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MatchCriteria_VXLanMatch.ProtoReflect.Descriptor instead.
func (*MatchCriteria_VXLanMatch) Descriptor() ([]byte, []int) {
	return file_tunneloffload_proto_rawDescGZIP(), []int{3, 2}
}

func (x *MatchCriteria_VXLanMatch) GetVni() uint32 {
	if x != nil {
		return x.Vni
	}
	return 0
}

func (x *MatchCriteria_VXLanMatch) GetMacMatch() *MacPair {
	if x != nil {
		return x.MacMatch
	}
	return nil
}

func (m *MatchCriteria_VXLanMatch) GetIpMatch() isMatchCriteria_VXLanMatch_IpMatch {
	if m != nil {
		return m.IpMatch
	}
	return nil
}

func (x *MatchCriteria_VXLanMatch) GetIpv4Match() *IPV4Match {
	if x, ok := x.GetIpMatch().(*MatchCriteria_VXLanMatch_Ipv4Match); ok {
		return x.Ipv4Match
	}
	return nil
}

func (x *MatchCriteria_VXLanMatch) GetIpv6Match() *IPV6Match {
	if x, ok := x.GetIpMatch().(*MatchCriteria_VXLanMatch_Ipv6Match); ok {
		return x.Ipv6Match
	}
	return nil
}

type isMatchCriteria_VXLanMatch_IpMatch interface {
	isMatchCriteria_VXLanMatch_IpMatch()
}

type MatchCriteria_VXLanMatch_Ipv4Match struct {
	Ipv4Match *IPV4Match `protobuf:"bytes,3,opt,name=ipv4_match,json=ipv4Match,proto3,oneof"`
}

type MatchCriteria_VXLanMatch_Ipv6Match struct {
	Ipv6Match *IPV6Match `protobuf:"bytes,4,opt,name=ipv6_match,json=ipv6Match,proto3,oneof"`
}

func (*MatchCriteria_VXLanMatch_Ipv4Match) isMatchCriteria_VXLanMatch_IpMatch() {}

func (*MatchCriteria_VXLanMatch_Ipv6Match) isMatchCriteria_VXLanMatch_IpMatch() {}

var File_tunneloffload_proto protoreflect.FileDescriptor

var file_tunneloffload_proto_rawDesc = []byte{
	0x0a, 0x13, 0x74, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x6f, 0x66, 0x66, 0x6c, 0x6f, 0x61, 0x64, 0x2e,
	0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x10, 0x74, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x6f, 0x66, 0x66,
	0x6c, 0x6f, 0x61, 0x64, 0x2e, 0x76, 0x32, 0x22, 0x13, 0x0a, 0x11, 0x43, 0x61, 0x70, 0x61, 0x62,
	0x69, 0x6c, 0x69, 0x74, 0x79, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x22, 0xd4, 0x06, 0x0a,
	0x12, 0x43, 0x61, 0x70, 0x61, 0x62, 0x69, 0x6c, 0x69, 0x74, 0x79, 0x52, 0x65, 0x73, 0x70, 0x6f,
	0x6e, 0x73, 0x65, 0x12, 0x65, 0x0a, 0x12, 0x6d, 0x61, 0x74, 0x63, 0x68, 0x5f, 0x63, 0x61, 0x70,
	0x61, 0x62, 0x69, 0x6c, 0x69, 0x74, 0x69, 0x65, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x36, 0x2e, 0x74, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x6f, 0x66, 0x66, 0x6c, 0x6f, 0x61, 0x64, 0x2e,
	0x76, 0x32, 0x2e, 0x43, 0x61, 0x70, 0x61, 0x62, 0x69, 0x6c, 0x69, 0x74, 0x79, 0x52, 0x65, 0x73,
	0x70, 0x6f, 0x6e, 0x73, 0x65, 0x2e, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x43, 0x61, 0x70, 0x61, 0x62,
	0x69, 0x6c, 0x69, 0x74, 0x69, 0x65, 0x73, 0x52, 0x11, 0x6d, 0x61, 0x74, 0x63, 0x68, 0x43, 0x61,
	0x70, 0x61, 0x62, 0x69, 0x6c, 0x69, 0x74, 0x69, 0x65, 0x73, 0x12, 0x65, 0x0a, 0x12, 0x69, 0x70,
	0x73, 0x65, 0x63, 0x5f, 0x63, 0x61, 0x70, 0x61, 0x62, 0x69, 0x6c, 0x69, 0x74, 0x69, 0x65, 0x73,
	0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x36, 0x2e, 0x74, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x6f,
	0x66, 0x66, 0x6c, 0x6f, 0x61, 0x64, 0x2e, 0x76, 0x32, 0x2e, 0x43, 0x61, 0x70, 0x61, 0x62, 0x69,
	0x6c, 0x69, 0x74, 0x79, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x2e, 0x49, 0x50, 0x53,
	0x65, 0x63, 0x43, 0x61, 0x70, 0x61, 0x62, 0x69, 0x6c, 0x69, 0x74, 0x69, 0x65, 0x73, 0x52, 0x11,
	0x69, 0x70, 0x73, 0x65, 0x63, 0x43, 0x61, 0x70, 0x61, 0x62, 0x69, 0x6c, 0x69, 0x74, 0x69, 0x65,
	0x73, 0x12, 0x68, 0x0a, 0x13, 0x67, 0x65, 0x6e, 0x65, 0x76, 0x65, 0x5f, 0x63, 0x61, 0x70, 0x61,
	0x62, 0x69, 0x6c, 0x69, 0x74, 0x69, 0x65, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x37,
	0x2e, 0x74, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x6f, 0x66, 0x66, 0x6c, 0x6f, 0x61, 0x64, 0x2e, 0x76,
	0x32, 0x2e, 0x43, 0x61, 0x70, 0x61, 0x62, 0x69, 0x6c, 0x69, 0x74, 0x79, 0x52, 0x65, 0x73, 0x70,
	0x6f, 0x6e, 0x73, 0x65, 0x2e, 0x47, 0x65, 0x6e, 0x65, 0x76, 0x65, 0x43, 0x61, 0x70, 0x61, 0x62,
	0x69, 0x6c, 0x69, 0x74, 0x69, 0x65, 0x73, 0x52, 0x12, 0x67, 0x65, 0x6e, 0x65, 0x76, 0x65, 0x43,
	0x61, 0x70, 0x61, 0x62, 0x69, 0x6c, 0x69, 0x74, 0x69, 0x65, 0x73, 0x1a, 0xed, 0x01, 0x0a, 0x11,
	0x4d, 0x61, 0x74, 0x63, 0x68, 0x43, 0x61, 0x70, 0x61, 0x62, 0x69, 0x6c, 0x69, 0x74, 0x69, 0x65,
	0x73, 0x12, 0x3c, 0x0a, 0x1a, 0x69, 0x6e, 0x67, 0x72, 0x65, 0x73, 0x73, 0x5f, 0x69, 0x6e, 0x74,
	0x65, 0x72, 0x66, 0x61, 0x63, 0x65, 0x5f, 0x6d, 0x61, 0x74, 0x63, 0x68, 0x69, 0x6e, 0x67, 0x18,
	0x01, 0x20, 0x01, 0x28, 0x08, 0x52, 0x18, 0x69, 0x6e, 0x67, 0x72, 0x65, 0x73, 0x73, 0x49, 0x6e,
	0x74, 0x65, 0x72, 0x66, 0x61, 0x63, 0x65, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x69, 0x6e, 0x67, 0x12,
	0x25, 0x0a, 0x0e, 0x76, 0x78, 0x6c, 0x61, 0x6e, 0x5f, 0x6d, 0x61, 0x74, 0x63, 0x68, 0x69, 0x6e,
	0x67, 0x18, 0x02, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0d, 0x76, 0x78, 0x6c, 0x61, 0x6e, 0x4d, 0x61,
	0x74, 0x63, 0x68, 0x69, 0x6e, 0x67, 0x12, 0x27, 0x0a, 0x0f, 0x67, 0x65, 0x6e, 0x65, 0x76, 0x65,
	0x5f, 0x6d, 0x61, 0x74, 0x63, 0x68, 0x69, 0x6e, 0x67, 0x18, 0x03, 0x20, 0x01, 0x28, 0x08, 0x52,
	0x0e, 0x67, 0x65, 0x6e, 0x65, 0x76, 0x65, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x69, 0x6e, 0x67, 0x12,
	0x27, 0x0a, 0x0f, 0x74, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x5f, 0x6d, 0x61, 0x74, 0x63, 0x68, 0x69,
	0x6e, 0x67, 0x18, 0x04, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0e, 0x74, 0x75, 0x6e, 0x6e, 0x65, 0x6c,
	0x4d, 0x61, 0x74, 0x63, 0x68, 0x69, 0x6e, 0x67, 0x12, 0x21, 0x0a, 0x0c, 0x73, 0x70, 0x69, 0x5f,
	0x6d, 0x61, 0x74, 0x63, 0x68, 0x69, 0x6e, 0x67, 0x18, 0x05, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0b,
	0x73, 0x70, 0x69, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x69, 0x6e, 0x67, 0x1a, 0xb8, 0x01, 0x0a, 0x11,
	0x49, 0x50, 0x53, 0x65, 0x63, 0x43, 0x61, 0x70, 0x61, 0x62, 0x69, 0x6c, 0x69, 0x74, 0x69, 0x65,
	0x73, 0x12, 0x55, 0x0a, 0x15, 0x74, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x5f, 0x74, 0x79, 0x70, 0x65,
	0x5f, 0x73, 0x75, 0x70, 0x70, 0x6f, 0x72, 0x74, 0x65, 0x64, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0e,
	0x32, 0x21, 0x2e, 0x74, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x6f, 0x66, 0x66, 0x6c, 0x6f, 0x61, 0x64,
	0x2e, 0x76, 0x32, 0x2e, 0x49, 0x50, 0x53, 0x65, 0x63, 0x54, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x54,
	0x79, 0x70, 0x65, 0x52, 0x13, 0x74, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x54, 0x79, 0x70, 0x65, 0x53,
	0x75, 0x70, 0x70, 0x6f, 0x72, 0x74, 0x65, 0x64, 0x12, 0x4c, 0x0a, 0x14, 0x65, 0x6e, 0x63, 0x72,
	0x79, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x73, 0x75, 0x70, 0x70, 0x6f, 0x72, 0x74, 0x65, 0x64,
	0x18, 0x02, 0x20, 0x03, 0x28, 0x0e, 0x32, 0x19, 0x2e, 0x74, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x6f,
	0x66, 0x66, 0x6c, 0x6f, 0x61, 0x64, 0x2e, 0x76, 0x32, 0x2e, 0x45, 0x6e, 0x63, 0x54, 0x79, 0x70,
	0x65, 0x52, 0x13, 0x65, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x53, 0x75, 0x70,
	0x70, 0x6f, 0x72, 0x74, 0x65, 0x64, 0x1a, 0x5b, 0x0a, 0x12, 0x47, 0x65, 0x6e, 0x65, 0x76, 0x65,
	0x43, 0x61, 0x70, 0x61, 0x62, 0x69, 0x6c, 0x69, 0x74, 0x69, 0x65, 0x73, 0x12, 0x45, 0x0a, 0x1f,
	0x6e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x5f, 0x67, 0x65, 0x6e, 0x65, 0x76, 0x65, 0x5f, 0x6f, 0x70,
	0x74, 0x69, 0x6f, 0x6e, 0x73, 0x5f, 0x73, 0x75, 0x70, 0x70, 0x6f, 0x72, 0x74, 0x65, 0x64, 0x18,
	0x01, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x1c, 0x6e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x47, 0x65, 0x6e,
	0x65, 0x76, 0x65, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x53, 0x75, 0x70, 0x70, 0x6f, 0x72,
	0x74, 0x65, 0x64, 0x22, 0x97, 0x02, 0x0a, 0x13, 0x54, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x41, 0x64,
	0x64, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x45, 0x72, 0x72, 0x6f, 0x72, 0x12, 0x3d, 0x0a, 0x0b, 0x6d,
	0x61, 0x74, 0x63, 0x68, 0x5f, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0e,
	0x32, 0x1c, 0x2e, 0x74, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x6f, 0x66, 0x66, 0x6c, 0x6f, 0x61, 0x64,
	0x2e, 0x76, 0x32, 0x2e, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x45, 0x72, 0x72, 0x6f, 0x72, 0x52, 0x0a,
	0x6d, 0x61, 0x74, 0x63, 0x68, 0x45, 0x72, 0x72, 0x6f, 0x72, 0x12, 0x40, 0x0a, 0x0c, 0x74, 0x75,
	0x6e, 0x6e, 0x65, 0x6c, 0x5f, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0e,
	0x32, 0x1d, 0x2e, 0x74, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x6f, 0x66, 0x66, 0x6c, 0x6f, 0x61, 0x64,
	0x2e, 0x76, 0x32, 0x2e, 0x54, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x45, 0x72, 0x72, 0x6f, 0x72, 0x52,
	0x0b, 0x74, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x45, 0x72, 0x72, 0x6f, 0x72, 0x12, 0x3d, 0x0a, 0x0b,
	0x69, 0x70, 0x73, 0x65, 0x63, 0x5f, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x18, 0x03, 0x20, 0x01, 0x28,
	0x0e, 0x32, 0x1c, 0x2e, 0x74, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x6f, 0x66, 0x66, 0x6c, 0x6f, 0x61,
	0x64, 0x2e, 0x76, 0x32, 0x2e, 0x49, 0x50, 0x53, 0x65, 0x63, 0x45, 0x72, 0x72, 0x6f, 0x72, 0x52,
	0x0a, 0x69, 0x70, 0x73, 0x65, 0x63, 0x45, 0x72, 0x72, 0x6f, 0x72, 0x12, 0x40, 0x0a, 0x0c, 0x67,
	0x65, 0x6e, 0x65, 0x76, 0x65, 0x5f, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x18, 0x04, 0x20, 0x01, 0x28,
	0x0e, 0x32, 0x1d, 0x2e, 0x74, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x6f, 0x66, 0x66, 0x6c, 0x6f, 0x61,
	0x64, 0x2e, 0x76, 0x32, 0x2e, 0x47, 0x65, 0x6e, 0x65, 0x76, 0x65, 0x45, 0x72, 0x72, 0x6f, 0x72,
	0x52, 0x0b, 0x67, 0x65, 0x6e, 0x65, 0x76, 0x65, 0x45, 0x72, 0x72, 0x6f, 0x72, 0x22, 0xaa, 0x08,
	0x0a, 0x0d, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x43, 0x72, 0x69, 0x74, 0x65, 0x72, 0x69, 0x61, 0x12,
	0x2b, 0x0a, 0x11, 0x69, 0x6e, 0x67, 0x72, 0x65, 0x73, 0x73, 0x5f, 0x69, 0x6e, 0x74, 0x65, 0x72,
	0x66, 0x61, 0x63, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x10, 0x69, 0x6e, 0x67, 0x72,
	0x65, 0x73, 0x73, 0x49, 0x6e, 0x74, 0x65, 0x72, 0x66, 0x61, 0x63, 0x65, 0x12, 0x36, 0x0a, 0x09,
	0x6d, 0x61, 0x63, 0x5f, 0x6d, 0x61, 0x74, 0x63, 0x68, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x19, 0x2e, 0x74, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x6f, 0x66, 0x66, 0x6c, 0x6f, 0x61, 0x64, 0x2e,
	0x76, 0x32, 0x2e, 0x4d, 0x61, 0x63, 0x50, 0x61, 0x69, 0x72, 0x52, 0x08, 0x6d, 0x61, 0x63, 0x4d,
	0x61, 0x74, 0x63, 0x68, 0x12, 0x3c, 0x0a, 0x0a, 0x69, 0x70, 0x76, 0x34, 0x5f, 0x6d, 0x61, 0x74,
	0x63, 0x68, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1b, 0x2e, 0x74, 0x75, 0x6e, 0x6e, 0x65,
	0x6c, 0x6f, 0x66, 0x66, 0x6c, 0x6f, 0x61, 0x64, 0x2e, 0x76, 0x32, 0x2e, 0x49, 0x50, 0x56, 0x34,
	0x4d, 0x61, 0x74, 0x63, 0x68, 0x48, 0x00, 0x52, 0x09, 0x69, 0x70, 0x76, 0x34, 0x4d, 0x61, 0x74,
	0x63, 0x68, 0x12, 0x3c, 0x0a, 0x0a, 0x69, 0x70, 0x76, 0x36, 0x5f, 0x6d, 0x61, 0x74, 0x63, 0x68,
	0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1b, 0x2e, 0x74, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x6f,
	0x66, 0x66, 0x6c, 0x6f, 0x61, 0x64, 0x2e, 0x76, 0x32, 0x2e, 0x49, 0x50, 0x56, 0x36, 0x4d, 0x61,
	0x74, 0x63, 0x68, 0x48, 0x00, 0x52, 0x09, 0x69, 0x70, 0x76, 0x36, 0x4d, 0x61, 0x74, 0x63, 0x68,
	0x12, 0x1b, 0x0a, 0x09, 0x74, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x5f, 0x69, 0x64, 0x18, 0x05, 0x20,
	0x01, 0x28, 0x04, 0x52, 0x08, 0x74, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x49, 0x64, 0x12, 0x4d, 0x0a,
	0x0b, 0x69, 0x70, 0x73, 0x65, 0x63, 0x5f, 0x6d, 0x61, 0x74, 0x63, 0x68, 0x18, 0x06, 0x20, 0x01,
	0x28, 0x0b, 0x32, 0x2a, 0x2e, 0x74, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x6f, 0x66, 0x66, 0x6c, 0x6f,
	0x61, 0x64, 0x2e, 0x76, 0x32, 0x2e, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x43, 0x72, 0x69, 0x74, 0x65,
	0x72, 0x69, 0x61, 0x2e, 0x49, 0x50, 0x53, 0x65, 0x63, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x48, 0x01,
	0x52, 0x0a, 0x69, 0x70, 0x73, 0x65, 0x63, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x12, 0x50, 0x0a, 0x0c,
	0x67, 0x65, 0x6e, 0x65, 0x76, 0x65, 0x5f, 0x6d, 0x61, 0x74, 0x63, 0x68, 0x18, 0x07, 0x20, 0x01,
	0x28, 0x0b, 0x32, 0x2b, 0x2e, 0x74, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x6f, 0x66, 0x66, 0x6c, 0x6f,
	0x61, 0x64, 0x2e, 0x76, 0x32, 0x2e, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x43, 0x72, 0x69, 0x74, 0x65,
	0x72, 0x69, 0x61, 0x2e, 0x47, 0x65, 0x6e, 0x65, 0x76, 0x65, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x48,
	0x01, 0x52, 0x0b, 0x67, 0x65, 0x6e, 0x65, 0x76, 0x65, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x12, 0x4d,
	0x0a, 0x0b, 0x76, 0x78, 0x6c, 0x61, 0x6e, 0x5f, 0x6d, 0x61, 0x74, 0x63, 0x68, 0x18, 0x08, 0x20,
	0x01, 0x28, 0x0b, 0x32, 0x2a, 0x2e, 0x74, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x6f, 0x66, 0x66, 0x6c,
	0x6f, 0x61, 0x64, 0x2e, 0x76, 0x32, 0x2e, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x43, 0x72, 0x69, 0x74,
	0x65, 0x72, 0x69, 0x61, 0x2e, 0x56, 0x58, 0x4c, 0x61, 0x6e, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x48,
	0x01, 0x52, 0x0a, 0x76, 0x78, 0x6c, 0x61, 0x6e, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x1a, 0x2e, 0x0a,
	0x0a, 0x49, 0x50, 0x53, 0x65, 0x63, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x12, 0x10, 0x0a, 0x03, 0x73,
	0x70, 0x69, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x03, 0x73, 0x70, 0x69, 0x12, 0x0e, 0x0a,
	0x02, 0x73, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x02, 0x73, 0x6e, 0x1a, 0x84, 0x02,
	0x0a, 0x0b, 0x47, 0x65, 0x6e, 0x65, 0x76, 0x65, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x12, 0x10, 0x0a,
	0x03, 0x76, 0x6e, 0x69, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x03, 0x76, 0x6e, 0x69, 0x12,
	0x36, 0x0a, 0x09, 0x6d, 0x61, 0x63, 0x5f, 0x6d, 0x61, 0x74, 0x63, 0x68, 0x18, 0x02, 0x20, 0x01,
	0x28, 0x0b, 0x32, 0x19, 0x2e, 0x74, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x6f, 0x66, 0x66, 0x6c, 0x6f,
	0x61, 0x64, 0x2e, 0x76, 0x32, 0x2e, 0x4d, 0x61, 0x63, 0x50, 0x61, 0x69, 0x72, 0x52, 0x08, 0x6d,
	0x61, 0x63, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x12, 0x23, 0x0a, 0x0d, 0x70, 0x72, 0x6f, 0x74, 0x6f,
	0x63, 0x6f, 0x6c, 0x5f, 0x74, 0x79, 0x70, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x0c,
	0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x54, 0x79, 0x70, 0x65, 0x12, 0x3c, 0x0a, 0x0a,
	0x69, 0x70, 0x76, 0x34, 0x5f, 0x6d, 0x61, 0x74, 0x63, 0x68, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b,
	0x32, 0x1b, 0x2e, 0x74, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x6f, 0x66, 0x66, 0x6c, 0x6f, 0x61, 0x64,
	0x2e, 0x76, 0x32, 0x2e, 0x49, 0x50, 0x56, 0x34, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x48, 0x00, 0x52,
	0x09, 0x69, 0x70, 0x76, 0x34, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x12, 0x3c, 0x0a, 0x0a, 0x69, 0x70,
	0x76, 0x36, 0x5f, 0x6d, 0x61, 0x74, 0x63, 0x68, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1b,
	0x2e, 0x74, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x6f, 0x66, 0x66, 0x6c, 0x6f, 0x61, 0x64, 0x2e, 0x76,
	0x32, 0x2e, 0x49, 0x50, 0x56, 0x36, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x48, 0x00, 0x52, 0x09, 0x69,
	0x70, 0x76, 0x36, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x42, 0x0a, 0x0a, 0x08, 0x69, 0x70, 0x5f, 0x6d,
	0x61, 0x74, 0x63, 0x68, 0x1a, 0xde, 0x01, 0x0a, 0x0a, 0x56, 0x58, 0x4c, 0x61, 0x6e, 0x4d, 0x61,
	0x74, 0x63, 0x68, 0x12, 0x10, 0x0a, 0x03, 0x76, 0x6e, 0x69, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d,
	0x52, 0x03, 0x76, 0x6e, 0x69, 0x12, 0x36, 0x0a, 0x09, 0x6d, 0x61, 0x63, 0x5f, 0x6d, 0x61, 0x74,
	0x63, 0x68, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x19, 0x2e, 0x74, 0x75, 0x6e, 0x6e, 0x65,
	0x6c, 0x6f, 0x66, 0x66, 0x6c, 0x6f, 0x61, 0x64, 0x2e, 0x76, 0x32, 0x2e, 0x4d, 0x61, 0x63, 0x50,
	0x61, 0x69, 0x72, 0x52, 0x08, 0x6d, 0x61, 0x63, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x12, 0x3c, 0x0a,
	0x0a, 0x69, 0x70, 0x76, 0x34, 0x5f, 0x6d, 0x61, 0x74, 0x63, 0x68, 0x18, 0x03, 0x20, 0x01, 0x28,
	0x0b, 0x32, 0x1b, 0x2e, 0x74, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x6f, 0x66, 0x66, 0x6c, 0x6f, 0x61,
	0x64, 0x2e, 0x76, 0x32, 0x2e, 0x49, 0x50, 0x56, 0x34, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x48, 0x00,
	0x52, 0x09, 0x69, 0x70, 0x76, 0x34, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x12, 0x3c, 0x0a, 0x0a, 0x69,
	0x70, 0x76, 0x36, 0x5f, 0x6d, 0x61, 0x74, 0x63, 0x68, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x1b, 0x2e, 0x74, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x6f, 0x66, 0x66, 0x6c, 0x6f, 0x61, 0x64, 0x2e,
	0x76, 0x32, 0x2e, 0x49, 0x50, 0x56, 0x36, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x48, 0x00, 0x52, 0x09,
	0x69, 0x70, 0x76, 0x36, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x42, 0x0a, 0x0a, 0x08, 0x69, 0x70, 0x5f,
	0x6d, 0x61, 0x74, 0x63, 0x68, 0x42, 0x0a, 0x0a, 0x08, 0x69, 0x70, 0x5f, 0x6d, 0x61, 0x74, 0x63,
	0x68, 0x42, 0x07, 0x0a, 0x05, 0x6d, 0x61, 0x74, 0x63, 0x68, 0x22, 0x99, 0x03, 0x0a, 0x0f, 0x49,
	0x70, 0x54, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x1b,
	0x0a, 0x09, 0x74, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28,
	0x04, 0x52, 0x08, 0x74, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x49, 0x64, 0x12, 0x39, 0x0a, 0x09, 0x6f,
	0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x1b,
	0x2e, 0x74, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x6f, 0x66, 0x66, 0x6c, 0x6f, 0x61, 0x64, 0x2e, 0x76,
	0x32, 0x2e, 0x4f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x09, 0x6f, 0x70, 0x65,
	0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x46, 0x0a, 0x0e, 0x6d, 0x61, 0x74, 0x63, 0x68, 0x5f,
	0x63, 0x72, 0x69, 0x74, 0x65, 0x72, 0x69, 0x61, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1f,
	0x2e, 0x74, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x6f, 0x66, 0x66, 0x6c, 0x6f, 0x61, 0x64, 0x2e, 0x76,
	0x32, 0x2e, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x43, 0x72, 0x69, 0x74, 0x65, 0x72, 0x69, 0x61, 0x52,
	0x0d, 0x6d, 0x61, 0x74, 0x63, 0x68, 0x43, 0x72, 0x69, 0x74, 0x65, 0x72, 0x69, 0x61, 0x12, 0x39,
	0x0a, 0x0b, 0x6e, 0x65, 0x78, 0x74, 0x5f, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x04, 0x20,
	0x01, 0x28, 0x0e, 0x32, 0x18, 0x2e, 0x74, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x6f, 0x66, 0x66, 0x6c,
	0x6f, 0x61, 0x64, 0x2e, 0x76, 0x32, 0x2e, 0x41, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x0a, 0x6e,
	0x65, 0x78, 0x74, 0x41, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x42, 0x0a, 0x0c, 0x69, 0x70, 0x73,
	0x65, 0x63, 0x5f, 0x74, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x1d, 0x2e, 0x74, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x6f, 0x66, 0x66, 0x6c, 0x6f, 0x61, 0x64, 0x2e,
	0x76, 0x32, 0x2e, 0x49, 0x50, 0x53, 0x65, 0x63, 0x54, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x48, 0x00,
	0x52, 0x0b, 0x69, 0x70, 0x73, 0x65, 0x63, 0x54, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x12, 0x32, 0x0a,
	0x06, 0x67, 0x65, 0x6e, 0x65, 0x76, 0x65, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x18, 0x2e,
	0x74, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x6f, 0x66, 0x66, 0x6c, 0x6f, 0x61, 0x64, 0x2e, 0x76, 0x32,
	0x2e, 0x47, 0x65, 0x6e, 0x65, 0x76, 0x65, 0x48, 0x00, 0x52, 0x06, 0x67, 0x65, 0x6e, 0x65, 0x76,
	0x65, 0x12, 0x29, 0x0a, 0x03, 0x6e, 0x61, 0x74, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x15,
	0x2e, 0x74, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x6f, 0x66, 0x66, 0x6c, 0x6f, 0x61, 0x64, 0x2e, 0x76,
	0x32, 0x2e, 0x4e, 0x61, 0x74, 0x48, 0x00, 0x52, 0x03, 0x6e, 0x61, 0x74, 0x42, 0x08, 0x0a, 0x06,
	0x74, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x22, 0x9f, 0x01, 0x0a, 0x06, 0x47, 0x65, 0x6e, 0x65, 0x76,
	0x65, 0x12, 0x42, 0x0a, 0x0c, 0x67, 0x65, 0x6e, 0x65, 0x76, 0x65, 0x5f, 0x65, 0x6e, 0x63, 0x61,
	0x70, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1d, 0x2e, 0x74, 0x75, 0x6e, 0x6e, 0x65, 0x6c,
	0x6f, 0x66, 0x66, 0x6c, 0x6f, 0x61, 0x64, 0x2e, 0x76, 0x32, 0x2e, 0x47, 0x65, 0x6e, 0x65, 0x76,
	0x65, 0x45, 0x6e, 0x63, 0x61, 0x70, 0x48, 0x00, 0x52, 0x0b, 0x67, 0x65, 0x6e, 0x65, 0x76, 0x65,
	0x45, 0x6e, 0x63, 0x61, 0x70, 0x12, 0x42, 0x0a, 0x0c, 0x67, 0x65, 0x6e, 0x65, 0x76, 0x65, 0x5f,
	0x64, 0x65, 0x63, 0x61, 0x70, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1d, 0x2e, 0x74, 0x75,
	0x6e, 0x6e, 0x65, 0x6c, 0x6f, 0x66, 0x66, 0x6c, 0x6f, 0x61, 0x64, 0x2e, 0x76, 0x32, 0x2e, 0x47,
	0x65, 0x6e, 0x65, 0x76, 0x65, 0x44, 0x65, 0x63, 0x61, 0x70, 0x48, 0x00, 0x52, 0x0b, 0x67, 0x65,
	0x6e, 0x65, 0x76, 0x65, 0x44, 0x65, 0x63, 0x61, 0x70, 0x42, 0x0d, 0x0a, 0x0b, 0x65, 0x6e, 0x63,
	0x61, 0x70, 0x5f, 0x64, 0x65, 0x63, 0x61, 0x70, 0x22, 0x71, 0x0a, 0x0c, 0x47, 0x65, 0x6e, 0x65,
	0x76, 0x65, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x21, 0x0a, 0x0c, 0x6f, 0x70, 0x74, 0x69,
	0x6f, 0x6e, 0x5f, 0x63, 0x6c, 0x61, 0x73, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x0b,
	0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x43, 0x6c, 0x61, 0x73, 0x73, 0x12, 0x12, 0x0a, 0x04, 0x74,
	0x79, 0x70, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x04, 0x74, 0x79, 0x70, 0x65, 0x12,
	0x16, 0x0a, 0x06, 0x6c, 0x65, 0x6e, 0x67, 0x74, 0x68, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0d, 0x52,
	0x06, 0x6c, 0x65, 0x6e, 0x67, 0x74, 0x68, 0x12, 0x12, 0x0a, 0x04, 0x64, 0x61, 0x74, 0x61, 0x18,
	0x04, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x04, 0x64, 0x61, 0x74, 0x61, 0x22, 0xe0, 0x03, 0x0a, 0x0b,
	0x47, 0x65, 0x6e, 0x65, 0x76, 0x65, 0x45, 0x6e, 0x63, 0x61, 0x70, 0x12, 0x44, 0x0a, 0x0f, 0x6f,
	0x75, 0x74, 0x65, 0x72, 0x5f, 0x69, 0x70, 0x76, 0x34, 0x5f, 0x70, 0x61, 0x69, 0x72, 0x18, 0x01,
	0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x74, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x6f, 0x66, 0x66,
	0x6c, 0x6f, 0x61, 0x64, 0x2e, 0x76, 0x32, 0x2e, 0x49, 0x50, 0x56, 0x34, 0x50, 0x61, 0x69, 0x72,
	0x48, 0x00, 0x52, 0x0d, 0x6f, 0x75, 0x74, 0x65, 0x72, 0x49, 0x70, 0x76, 0x34, 0x50, 0x61, 0x69,
	0x72, 0x12, 0x44, 0x0a, 0x0f, 0x6f, 0x75, 0x74, 0x65, 0x72, 0x5f, 0x69, 0x70, 0x76, 0x36, 0x5f,
	0x70, 0x61, 0x69, 0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x74, 0x75, 0x6e,
	0x6e, 0x65, 0x6c, 0x6f, 0x66, 0x66, 0x6c, 0x6f, 0x61, 0x64, 0x2e, 0x76, 0x32, 0x2e, 0x49, 0x50,
	0x56, 0x36, 0x50, 0x61, 0x69, 0x72, 0x48, 0x00, 0x52, 0x0d, 0x6f, 0x75, 0x74, 0x65, 0x72, 0x49,
	0x70, 0x76, 0x36, 0x50, 0x61, 0x69, 0x72, 0x12, 0x3f, 0x0a, 0x0e, 0x69, 0x6e, 0x6e, 0x65, 0x72,
	0x5f, 0x6d, 0x61, 0x63, 0x5f, 0x70, 0x61, 0x69, 0x72, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x19, 0x2e, 0x74, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x6f, 0x66, 0x66, 0x6c, 0x6f, 0x61, 0x64, 0x2e,
	0x76, 0x32, 0x2e, 0x4d, 0x61, 0x63, 0x50, 0x61, 0x69, 0x72, 0x52, 0x0c, 0x69, 0x6e, 0x6e, 0x65,
	0x72, 0x4d, 0x61, 0x63, 0x50, 0x61, 0x69, 0x72, 0x12, 0x23, 0x0a, 0x0d, 0x6f, 0x70, 0x74, 0x69,
	0x6f, 0x6e, 0x5f, 0x6c, 0x65, 0x6e, 0x67, 0x74, 0x68, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0d, 0x52,
	0x0c, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x4c, 0x65, 0x6e, 0x67, 0x74, 0x68, 0x12, 0x25, 0x0a,
	0x0e, 0x63, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x5f, 0x70, 0x61, 0x63, 0x6b, 0x65, 0x74, 0x18,
	0x05, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0d, 0x63, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x50, 0x61,
	0x63, 0x6b, 0x65, 0x74, 0x12, 0x36, 0x0a, 0x17, 0x63, 0x72, 0x69, 0x74, 0x69, 0x63, 0x61, 0x6c,
	0x5f, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x70, 0x72, 0x65, 0x73, 0x65, 0x6e, 0x74, 0x18,
	0x06, 0x20, 0x01, 0x28, 0x08, 0x52, 0x15, 0x63, 0x72, 0x69, 0x74, 0x69, 0x63, 0x61, 0x6c, 0x4f,
	0x70, 0x74, 0x69, 0x6f, 0x6e, 0x50, 0x72, 0x65, 0x73, 0x65, 0x6e, 0x74, 0x12, 0x10, 0x0a, 0x03,
	0x76, 0x6e, 0x69, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x03, 0x76, 0x6e, 0x69, 0x12, 0x23,
	0x0a, 0x0d, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x5f, 0x74, 0x79, 0x70, 0x65, 0x18,
	0x08, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x0c, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x54,
	0x79, 0x70, 0x65, 0x12, 0x43, 0x0a, 0x0d, 0x67, 0x65, 0x6e, 0x65, 0x76, 0x65, 0x5f, 0x6f, 0x70,
	0x74, 0x69, 0x6f, 0x6e, 0x18, 0x09, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1e, 0x2e, 0x74, 0x75, 0x6e,
	0x6e, 0x65, 0x6c, 0x6f, 0x66, 0x66, 0x6c, 0x6f, 0x61, 0x64, 0x2e, 0x76, 0x32, 0x2e, 0x47, 0x65,
	0x6e, 0x65, 0x76, 0x65, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x0c, 0x67, 0x65, 0x6e, 0x65,
	0x76, 0x65, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x42, 0x04, 0x0a, 0x02, 0x69, 0x70, 0x22, 0x0d,
	0x0a, 0x0b, 0x47, 0x65, 0x6e, 0x65, 0x76, 0x65, 0x44, 0x65, 0x63, 0x61, 0x70, 0x22, 0x51, 0x0a,
	0x07, 0x4d, 0x61, 0x63, 0x50, 0x61, 0x69, 0x72, 0x12, 0x27, 0x0a, 0x0f, 0x64, 0x65, 0x73, 0x74,
	0x69, 0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x6d, 0x61, 0x63, 0x18, 0x01, 0x20, 0x01, 0x28,
	0x0c, 0x52, 0x0e, 0x64, 0x65, 0x73, 0x74, 0x69, 0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x4d, 0x61,
	0x63, 0x12, 0x1d, 0x0a, 0x0a, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x5f, 0x6d, 0x61, 0x63, 0x18,
	0x02, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x09, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x4d, 0x61, 0x63,
	0x22, 0x4e, 0x0a, 0x08, 0x49, 0x50, 0x56, 0x34, 0x50, 0x61, 0x69, 0x72, 0x12, 0x1b, 0x0a, 0x09,
	0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x5f, 0x69, 0x70, 0x18, 0x01, 0x20, 0x01, 0x28, 0x07, 0x52,
	0x08, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x49, 0x70, 0x12, 0x25, 0x0a, 0x0e, 0x64, 0x65, 0x73,
	0x74, 0x69, 0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x69, 0x70, 0x18, 0x02, 0x20, 0x01, 0x28,
	0x07, 0x52, 0x0d, 0x64, 0x65, 0x73, 0x74, 0x69, 0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x49, 0x70,
	0x22, 0x4e, 0x0a, 0x08, 0x49, 0x50, 0x56, 0x36, 0x50, 0x61, 0x69, 0x72, 0x12, 0x1b, 0x0a, 0x09,
	0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x5f, 0x69, 0x70, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0c, 0x52,
	0x08, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x49, 0x70, 0x12, 0x25, 0x0a, 0x0e, 0x64, 0x65, 0x73,
	0x74, 0x69, 0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x69, 0x70, 0x18, 0x02, 0x20, 0x01, 0x28,
	0x0c, 0x52, 0x0d, 0x64, 0x65, 0x73, 0x74, 0x69, 0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x49, 0x70,
	0x22, 0xad, 0x01, 0x0a, 0x09, 0x49, 0x50, 0x56, 0x34, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x12, 0x1b,
	0x0a, 0x09, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x5f, 0x69, 0x70, 0x18, 0x01, 0x20, 0x01, 0x28,
	0x07, 0x52, 0x08, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x49, 0x70, 0x12, 0x28, 0x0a, 0x10, 0x73,
	0x6f, 0x75, 0x72, 0x63, 0x65, 0x5f, 0x69, 0x70, 0x5f, 0x70, 0x72, 0x65, 0x66, 0x69, 0x78, 0x18,
	0x02, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x0e, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x49, 0x70, 0x50,
	0x72, 0x65, 0x66, 0x69, 0x78, 0x12, 0x25, 0x0a, 0x0e, 0x64, 0x65, 0x73, 0x74, 0x69, 0x6e, 0x61,
	0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x69, 0x70, 0x18, 0x03, 0x20, 0x01, 0x28, 0x07, 0x52, 0x0d, 0x64,
	0x65, 0x73, 0x74, 0x69, 0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x49, 0x70, 0x12, 0x32, 0x0a, 0x15,
	0x64, 0x65, 0x73, 0x74, 0x69, 0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x69, 0x70, 0x5f, 0x70,
	0x72, 0x65, 0x66, 0x69, 0x78, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x13, 0x64, 0x65, 0x73,
	0x74, 0x69, 0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x49, 0x70, 0x50, 0x72, 0x65, 0x66, 0x69, 0x78,
	0x22, 0xad, 0x01, 0x0a, 0x09, 0x49, 0x50, 0x56, 0x36, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x12, 0x1b,
	0x0a, 0x09, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x5f, 0x69, 0x70, 0x18, 0x01, 0x20, 0x01, 0x28,
	0x0c, 0x52, 0x08, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x49, 0x70, 0x12, 0x28, 0x0a, 0x10, 0x73,
	0x6f, 0x75, 0x72, 0x63, 0x65, 0x5f, 0x69, 0x70, 0x5f, 0x70, 0x72, 0x65, 0x66, 0x69, 0x78, 0x18,
	0x02, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x0e, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x49, 0x70, 0x50,
	0x72, 0x65, 0x66, 0x69, 0x78, 0x12, 0x25, 0x0a, 0x0e, 0x64, 0x65, 0x73, 0x74, 0x69, 0x6e, 0x61,
	0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x69, 0x70, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x0d, 0x64,
	0x65, 0x73, 0x74, 0x69, 0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x49, 0x70, 0x12, 0x32, 0x0a, 0x15,
	0x64, 0x65, 0x73, 0x74, 0x69, 0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x69, 0x70, 0x5f, 0x70,
	0x72, 0x65, 0x66, 0x69, 0x78, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x13, 0x64, 0x65, 0x73,
	0x74, 0x69, 0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x49, 0x70, 0x50, 0x72, 0x65, 0x66, 0x69, 0x78,
	0x22, 0x22, 0x0a, 0x03, 0x4e, 0x61, 0x74, 0x12, 0x1b, 0x0a, 0x09, 0x73, 0x6f, 0x75, 0x72, 0x63,
	0x65, 0x5f, 0x69, 0x70, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x08, 0x73, 0x6f, 0x75, 0x72,
	0x63, 0x65, 0x49, 0x70, 0x22, 0xd9, 0x02, 0x0a, 0x08, 0x49, 0x50, 0x53, 0x65, 0x63, 0x45, 0x6e,
	0x63, 0x12, 0x42, 0x0a, 0x0b, 0x74, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x5f, 0x74, 0x79, 0x70, 0x65,
	0x18, 0x01, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x21, 0x2e, 0x74, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x6f,
	0x66, 0x66, 0x6c, 0x6f, 0x61, 0x64, 0x2e, 0x76, 0x32, 0x2e, 0x49, 0x50, 0x53, 0x65, 0x63, 0x54,
	0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x54, 0x79, 0x70, 0x65, 0x52, 0x0a, 0x74, 0x75, 0x6e, 0x6e, 0x65,
	0x6c, 0x54, 0x79, 0x70, 0x65, 0x12, 0x42, 0x0a, 0x0f, 0x65, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74,
	0x69, 0x6f, 0x6e, 0x5f, 0x74, 0x79, 0x70, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x19,
	0x2e, 0x74, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x6f, 0x66, 0x66, 0x6c, 0x6f, 0x61, 0x64, 0x2e, 0x76,
	0x32, 0x2e, 0x45, 0x6e, 0x63, 0x54, 0x79, 0x70, 0x65, 0x52, 0x0e, 0x65, 0x6e, 0x63, 0x72, 0x79,
	0x70, 0x74, 0x69, 0x6f, 0x6e, 0x54, 0x79, 0x70, 0x65, 0x12, 0x3a, 0x0a, 0x08, 0x69, 0x70, 0x73,
	0x65, 0x63, 0x5f, 0x73, 0x61, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1f, 0x2e, 0x74, 0x75,
	0x6e, 0x6e, 0x65, 0x6c, 0x6f, 0x66, 0x66, 0x6c, 0x6f, 0x61, 0x64, 0x2e, 0x76, 0x32, 0x2e, 0x49,
	0x50, 0x53, 0x65, 0x63, 0x53, 0x41, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x73, 0x52, 0x07, 0x69, 0x70,
	0x73, 0x65, 0x63, 0x53, 0x61, 0x12, 0x3d, 0x0a, 0x0b, 0x69, 0x70, 0x76, 0x34, 0x5f, 0x74, 0x75,
	0x6e, 0x6e, 0x65, 0x6c, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x74, 0x75, 0x6e,
	0x6e, 0x65, 0x6c, 0x6f, 0x66, 0x66, 0x6c, 0x6f, 0x61, 0x64, 0x2e, 0x76, 0x32, 0x2e, 0x49, 0x50,
	0x56, 0x34, 0x50, 0x61, 0x69, 0x72, 0x48, 0x00, 0x52, 0x0a, 0x69, 0x70, 0x76, 0x34, 0x54, 0x75,
	0x6e, 0x6e, 0x65, 0x6c, 0x12, 0x3d, 0x0a, 0x0b, 0x69, 0x70, 0x76, 0x36, 0x5f, 0x74, 0x75, 0x6e,
	0x6e, 0x65, 0x6c, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x74, 0x75, 0x6e, 0x6e,
	0x65, 0x6c, 0x6f, 0x66, 0x66, 0x6c, 0x6f, 0x61, 0x64, 0x2e, 0x76, 0x32, 0x2e, 0x49, 0x50, 0x56,
	0x36, 0x50, 0x61, 0x69, 0x72, 0x48, 0x00, 0x52, 0x0a, 0x69, 0x70, 0x76, 0x36, 0x54, 0x75, 0x6e,
	0x6e, 0x65, 0x6c, 0x42, 0x0b, 0x0a, 0x09, 0x74, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x49, 0x70, 0x73,
	0x22, 0xd0, 0x01, 0x0a, 0x08, 0x49, 0x50, 0x53, 0x65, 0x63, 0x44, 0x65, 0x63, 0x12, 0x42, 0x0a,
	0x0b, 0x74, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x5f, 0x74, 0x79, 0x70, 0x65, 0x18, 0x01, 0x20, 0x01,
	0x28, 0x0e, 0x32, 0x21, 0x2e, 0x74, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x6f, 0x66, 0x66, 0x6c, 0x6f,
	0x61, 0x64, 0x2e, 0x76, 0x32, 0x2e, 0x49, 0x50, 0x53, 0x65, 0x63, 0x54, 0x75, 0x6e, 0x6e, 0x65,
	0x6c, 0x54, 0x79, 0x70, 0x65, 0x52, 0x0a, 0x74, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x54, 0x79, 0x70,
	0x65, 0x12, 0x42, 0x0a, 0x0f, 0x65, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x5f,
	0x74, 0x79, 0x70, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x19, 0x2e, 0x74, 0x75, 0x6e,
	0x6e, 0x65, 0x6c, 0x6f, 0x66, 0x66, 0x6c, 0x6f, 0x61, 0x64, 0x2e, 0x76, 0x32, 0x2e, 0x45, 0x6e,
	0x63, 0x54, 0x79, 0x70, 0x65, 0x52, 0x0e, 0x65, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x69, 0x6f,
	0x6e, 0x54, 0x79, 0x70, 0x65, 0x12, 0x3c, 0x0a, 0x09, 0x69, 0x70, 0x73, 0x65, 0x63, 0x5f, 0x73,
	0x61, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1f, 0x2e, 0x74, 0x75, 0x6e, 0x6e, 0x65,
	0x6c, 0x6f, 0x66, 0x66, 0x6c, 0x6f, 0x61, 0x64, 0x2e, 0x76, 0x32, 0x2e, 0x49, 0x50, 0x53, 0x65,
	0x63, 0x53, 0x41, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x73, 0x52, 0x08, 0x69, 0x70, 0x73, 0x65, 0x63,
	0x53, 0x61, 0x73, 0x22, 0x83, 0x01, 0x0a, 0x0d, 0x49, 0x50, 0x53, 0x65, 0x63, 0x53, 0x41, 0x50,
	0x61, 0x72, 0x61, 0x6d, 0x73, 0x12, 0x10, 0x0a, 0x03, 0x73, 0x70, 0x69, 0x18, 0x01, 0x20, 0x01,
	0x28, 0x0d, 0x52, 0x03, 0x73, 0x70, 0x69, 0x12, 0x25, 0x0a, 0x0e, 0x65, 0x6e, 0x63, 0x72, 0x79,
	0x70, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x6b, 0x65, 0x79, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0c, 0x52,
	0x0d, 0x65, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x4b, 0x65, 0x79, 0x12, 0x39,
	0x0a, 0x09, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x03, 0x20, 0x01, 0x28,
	0x0e, 0x32, 0x1b, 0x2e, 0x74, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x6f, 0x66, 0x66, 0x6c, 0x6f, 0x61,
	0x64, 0x2e, 0x76, 0x32, 0x2e, 0x4f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x09,
	0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x22, 0x8c, 0x01, 0x0a, 0x0b, 0x49, 0x50,
	0x53, 0x65, 0x63, 0x54, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x12, 0x39, 0x0a, 0x09, 0x69, 0x70, 0x73,
	0x65, 0x63, 0x5f, 0x65, 0x6e, 0x63, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x74,
	0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x6f, 0x66, 0x66, 0x6c, 0x6f, 0x61, 0x64, 0x2e, 0x76, 0x32, 0x2e,
	0x49, 0x50, 0x53, 0x65, 0x63, 0x45, 0x6e, 0x63, 0x48, 0x00, 0x52, 0x08, 0x69, 0x70, 0x73, 0x65,
	0x63, 0x45, 0x6e, 0x63, 0x12, 0x39, 0x0a, 0x09, 0x69, 0x70, 0x73, 0x65, 0x63, 0x5f, 0x64, 0x65,
	0x63, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x74, 0x75, 0x6e, 0x6e, 0x65, 0x6c,
	0x6f, 0x66, 0x66, 0x6c, 0x6f, 0x61, 0x64, 0x2e, 0x76, 0x32, 0x2e, 0x49, 0x50, 0x53, 0x65, 0x63,
	0x44, 0x65, 0x63, 0x48, 0x00, 0x52, 0x08, 0x69, 0x70, 0x73, 0x65, 0x63, 0x44, 0x65, 0x63, 0x42,
	0x07, 0x0a, 0x05, 0x69, 0x70, 0x73, 0x65, 0x63, 0x22, 0x27, 0x0a, 0x08, 0x54, 0x75, 0x6e, 0x6e,
	0x65, 0x6c, 0x49, 0x64, 0x12, 0x1b, 0x0a, 0x09, 0x74, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x5f, 0x69,
	0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x04, 0x52, 0x08, 0x74, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x49,
	0x64, 0x22, 0xa6, 0x02, 0x0a, 0x08, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x65, 0x72, 0x73, 0x12, 0x1d,
	0x0a, 0x0a, 0x69, 0x6e, 0x5f, 0x70, 0x61, 0x63, 0x6b, 0x65, 0x74, 0x73, 0x18, 0x01, 0x20, 0x01,
	0x28, 0x04, 0x52, 0x09, 0x69, 0x6e, 0x50, 0x61, 0x63, 0x6b, 0x65, 0x74, 0x73, 0x12, 0x1f, 0x0a,
	0x0b, 0x6f, 0x75, 0x74, 0x5f, 0x70, 0x61, 0x63, 0x6b, 0x65, 0x74, 0x73, 0x18, 0x02, 0x20, 0x01,
	0x28, 0x04, 0x52, 0x0a, 0x6f, 0x75, 0x74, 0x50, 0x61, 0x63, 0x6b, 0x65, 0x74, 0x73, 0x12, 0x19,
	0x0a, 0x08, 0x69, 0x6e, 0x5f, 0x62, 0x79, 0x74, 0x65, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x04,
	0x52, 0x07, 0x69, 0x6e, 0x42, 0x79, 0x74, 0x65, 0x73, 0x12, 0x1b, 0x0a, 0x09, 0x6f, 0x75, 0x74,
	0x5f, 0x62, 0x79, 0x74, 0x65, 0x73, 0x18, 0x04, 0x20, 0x01, 0x28, 0x04, 0x52, 0x08, 0x6f, 0x75,
	0x74, 0x42, 0x79, 0x74, 0x65, 0x73, 0x12, 0x28, 0x0a, 0x10, 0x69, 0x6e, 0x5f, 0x70, 0x61, 0x63,
	0x6b, 0x65, 0x74, 0x73, 0x5f, 0x64, 0x72, 0x6f, 0x70, 0x73, 0x18, 0x05, 0x20, 0x01, 0x28, 0x04,
	0x52, 0x0e, 0x69, 0x6e, 0x50, 0x61, 0x63, 0x6b, 0x65, 0x74, 0x73, 0x44, 0x72, 0x6f, 0x70, 0x73,
	0x12, 0x2a, 0x0a, 0x11, 0x6f, 0x75, 0x74, 0x5f, 0x70, 0x61, 0x63, 0x6b, 0x65, 0x74, 0x73, 0x5f,
	0x64, 0x72, 0x6f, 0x70, 0x73, 0x18, 0x06, 0x20, 0x01, 0x28, 0x04, 0x52, 0x0f, 0x6f, 0x75, 0x74,
	0x50, 0x61, 0x63, 0x6b, 0x65, 0x74, 0x73, 0x44, 0x72, 0x6f, 0x70, 0x73, 0x12, 0x24, 0x0a, 0x0e,
	0x69, 0x6e, 0x5f, 0x62, 0x79, 0x74, 0x65, 0x73, 0x5f, 0x64, 0x72, 0x6f, 0x70, 0x73, 0x18, 0x07,
	0x20, 0x01, 0x28, 0x04, 0x52, 0x0c, 0x69, 0x6e, 0x42, 0x79, 0x74, 0x65, 0x73, 0x44, 0x72, 0x6f,
	0x70, 0x73, 0x12, 0x26, 0x0a, 0x0f, 0x6f, 0x75, 0x74, 0x5f, 0x62, 0x79, 0x74, 0x65, 0x73, 0x5f,
	0x64, 0x72, 0x6f, 0x70, 0x73, 0x18, 0x08, 0x20, 0x01, 0x28, 0x04, 0x52, 0x0d, 0x6f, 0x75, 0x74,
	0x42, 0x79, 0x74, 0x65, 0x73, 0x44, 0x72, 0x6f, 0x70, 0x73, 0x22, 0xce, 0x01, 0x0a, 0x17, 0x43,
	0x72, 0x65, 0x61, 0x74, 0x65, 0x49, 0x70, 0x54, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x52, 0x65, 0x73,
	0x70, 0x6f, 0x6e, 0x73, 0x65, 0x73, 0x12, 0x48, 0x0a, 0x0e, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73,
	0x74, 0x5f, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x21,
	0x2e, 0x74, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x6f, 0x66, 0x66, 0x6c, 0x6f, 0x61, 0x64, 0x2e, 0x76,
	0x32, 0x2e, 0x41, 0x64, 0x64, 0x54, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x53, 0x74, 0x61, 0x74, 0x75,
	0x73, 0x52, 0x0d, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73,
	0x12, 0x21, 0x0a, 0x0c, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x5f, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73,
	0x18, 0x02, 0x20, 0x01, 0x28, 0x04, 0x52, 0x0b, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x53, 0x74, 0x61,
	0x74, 0x75, 0x73, 0x12, 0x46, 0x0a, 0x09, 0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x73,
	0x18, 0x03, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x28, 0x2e, 0x74, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x6f,
	0x66, 0x66, 0x6c, 0x6f, 0x61, 0x64, 0x2e, 0x76, 0x32, 0x2e, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65,
	0x49, 0x70, 0x54, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65,
	0x52, 0x09, 0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x73, 0x22, 0x64, 0x0a, 0x16, 0x43,
	0x72, 0x65, 0x61, 0x74, 0x65, 0x49, 0x70, 0x54, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x52, 0x65, 0x73,
	0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x1b, 0x0a, 0x09, 0x74, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x5f,
	0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x04, 0x52, 0x08, 0x74, 0x75, 0x6e, 0x6e, 0x65, 0x6c,
	0x49, 0x64, 0x12, 0x2d, 0x0a, 0x05, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x18, 0x02, 0x20, 0x01, 0x28,
	0x0b, 0x32, 0x17, 0x2e, 0x74, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x6f, 0x66, 0x66, 0x6c, 0x6f, 0x61,
	0x64, 0x2e, 0x76, 0x32, 0x2e, 0x45, 0x72, 0x72, 0x6f, 0x72, 0x52, 0x05, 0x65, 0x72, 0x72, 0x6f,
	0x72, 0x22, 0x76, 0x0a, 0x05, 0x45, 0x72, 0x72, 0x6f, 0x72, 0x12, 0x4a, 0x0a, 0x0d, 0x65, 0x72,
	0x72, 0x6f, 0x72, 0x5f, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28,
	0x0b, 0x32, 0x25, 0x2e, 0x74, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x6f, 0x66, 0x66, 0x6c, 0x6f, 0x61,
	0x64, 0x2e, 0x76, 0x32, 0x2e, 0x54, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x41, 0x64, 0x64, 0x69, 0x74,
	0x69, 0x6f, 0x6e, 0x45, 0x72, 0x72, 0x6f, 0x72, 0x52, 0x0c, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x4d,
	0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x12, 0x21, 0x0a, 0x0c, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x5f,
	0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x65, 0x72,
	0x72, 0x6f, 0x72, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x22, 0x55, 0x0a, 0x11, 0x49, 0x70, 0x54,
	0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x73, 0x12, 0x40,
	0x0a, 0x09, 0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28,
	0x0b, 0x32, 0x22, 0x2e, 0x74, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x6f, 0x66, 0x66, 0x6c, 0x6f, 0x61,
	0x64, 0x2e, 0x76, 0x32, 0x2e, 0x49, 0x70, 0x54, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x52, 0x65, 0x73,
	0x70, 0x6f, 0x6e, 0x73, 0x65, 0x52, 0x09, 0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x73,
	0x22, 0xe3, 0x01, 0x0a, 0x10, 0x49, 0x70, 0x54, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x52, 0x65, 0x73,
	0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x1b, 0x0a, 0x09, 0x74, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x5f,
	0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x04, 0x52, 0x08, 0x74, 0x75, 0x6e, 0x6e, 0x65, 0x6c,
	0x49, 0x64, 0x12, 0x3e, 0x0a, 0x09, 0x69, 0x70, 0x5f, 0x74, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x18,
	0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x21, 0x2e, 0x74, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x6f, 0x66,
	0x66, 0x6c, 0x6f, 0x61, 0x64, 0x2e, 0x76, 0x32, 0x2e, 0x49, 0x70, 0x54, 0x75, 0x6e, 0x6e, 0x65,
	0x6c, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x52, 0x08, 0x69, 0x70, 0x54, 0x75, 0x6e, 0x6e,
	0x65, 0x6c, 0x12, 0x43, 0x0a, 0x0f, 0x74, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x5f, 0x63, 0x6f, 0x75,
	0x6e, 0x74, 0x65, 0x72, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x74, 0x75,
	0x6e, 0x6e, 0x65, 0x6c, 0x6f, 0x66, 0x66, 0x6c, 0x6f, 0x61, 0x64, 0x2e, 0x76, 0x32, 0x2e, 0x43,
	0x6f, 0x75, 0x6e, 0x74, 0x65, 0x72, 0x73, 0x52, 0x0e, 0x74, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x43,
	0x6f, 0x75, 0x6e, 0x74, 0x65, 0x72, 0x73, 0x12, 0x2d, 0x0a, 0x05, 0x65, 0x72, 0x72, 0x6f, 0x72,
	0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x17, 0x2e, 0x74, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x6f,
	0x66, 0x66, 0x6c, 0x6f, 0x61, 0x64, 0x2e, 0x76, 0x32, 0x2e, 0x45, 0x72, 0x72, 0x6f, 0x72, 0x52,
	0x05, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x22, 0x5f, 0x0a, 0x16, 0x49, 0x70, 0x54, 0x75, 0x6e, 0x6e,
	0x65, 0x6c, 0x53, 0x74, 0x61, 0x74, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x73,
	0x12, 0x45, 0x0a, 0x09, 0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x73, 0x18, 0x01, 0x20,
	0x03, 0x28, 0x0b, 0x32, 0x27, 0x2e, 0x74, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x6f, 0x66, 0x66, 0x6c,
	0x6f, 0x61, 0x64, 0x2e, 0x76, 0x32, 0x2e, 0x49, 0x70, 0x54, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x53,
	0x74, 0x61, 0x74, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x52, 0x09, 0x72, 0x65,
	0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x73, 0x22, 0xa8, 0x01, 0x0a, 0x15, 0x49, 0x70, 0x54, 0x75,
	0x6e, 0x6e, 0x65, 0x6c, 0x53, 0x74, 0x61, 0x74, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73,
	0x65, 0x12, 0x1b, 0x0a, 0x09, 0x74, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x5f, 0x69, 0x64, 0x18, 0x01,
	0x20, 0x01, 0x28, 0x04, 0x52, 0x08, 0x74, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x49, 0x64, 0x12, 0x43,
	0x0a, 0x0f, 0x74, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x5f, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x65, 0x72,
	0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x74, 0x75, 0x6e, 0x6e, 0x65, 0x6c,
	0x6f, 0x66, 0x66, 0x6c, 0x6f, 0x61, 0x64, 0x2e, 0x76, 0x32, 0x2e, 0x43, 0x6f, 0x75, 0x6e, 0x74,
	0x65, 0x72, 0x73, 0x52, 0x0e, 0x74, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x43, 0x6f, 0x75, 0x6e, 0x74,
	0x65, 0x72, 0x73, 0x12, 0x2d, 0x0a, 0x05, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x18, 0x03, 0x20, 0x01,
	0x28, 0x0b, 0x32, 0x17, 0x2e, 0x74, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x6f, 0x66, 0x66, 0x6c, 0x6f,
	0x61, 0x64, 0x2e, 0x76, 0x32, 0x2e, 0x45, 0x72, 0x72, 0x6f, 0x72, 0x52, 0x05, 0x65, 0x72, 0x72,
	0x6f, 0x72, 0x22, 0x43, 0x0a, 0x11, 0x54, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x52, 0x65, 0x71, 0x75,
	0x65, 0x73, 0x74, 0x41, 0x72, 0x67, 0x73, 0x12, 0x2e, 0x0a, 0x13, 0x74, 0x75, 0x6e, 0x6e, 0x65,
	0x6c, 0x73, 0x5f, 0x70, 0x65, 0x72, 0x5f, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x18, 0x01,
	0x20, 0x01, 0x28, 0x0d, 0x52, 0x11, 0x74, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x73, 0x50, 0x65, 0x72,
	0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x2a, 0x90, 0x01, 0x0a, 0x0f, 0x41, 0x64, 0x64, 0x54,
	0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x14, 0x0a, 0x10, 0x5f,
	0x54, 0x55, 0x4e, 0x4e, 0x45, 0x4c, 0x5f, 0x41, 0x43, 0x43, 0x45, 0x50, 0x54, 0x45, 0x44, 0x10,
	0x00, 0x12, 0x14, 0x0a, 0x10, 0x5f, 0x54, 0x55, 0x4e, 0x4e, 0x45, 0x4c, 0x5f, 0x52, 0x45, 0x4a,
	0x45, 0x43, 0x54, 0x45, 0x44, 0x10, 0x01, 0x12, 0x16, 0x0a, 0x12, 0x5f, 0x54, 0x55, 0x4e, 0x4e,
	0x45, 0x4c, 0x5f, 0x54, 0x41, 0x42, 0x4c, 0x45, 0x5f, 0x46, 0x55, 0x4c, 0x4c, 0x10, 0x02, 0x12,
	0x1d, 0x0a, 0x19, 0x5f, 0x54, 0x55, 0x4e, 0x4e, 0x45, 0x4c, 0x5f, 0x54, 0x41, 0x42, 0x4c, 0x45,
	0x5f, 0x55, 0x4e, 0x41, 0x56, 0x41, 0x49, 0x4c, 0x41, 0x42, 0x4c, 0x45, 0x10, 0x03, 0x12, 0x1a,
	0x0a, 0x16, 0x5f, 0x54, 0x55, 0x4e, 0x4e, 0x45, 0x4c, 0x5f, 0x41, 0x4c, 0x52, 0x45, 0x41, 0x44,
	0x59, 0x5f, 0x45, 0x58, 0x49, 0x53, 0x54, 0x53, 0x10, 0x04, 0x2a, 0x3d, 0x0a, 0x09, 0x4f, 0x70,
	0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x09, 0x0a, 0x05, 0x5f, 0x4e, 0x4f, 0x4e, 0x45,
	0x10, 0x00, 0x12, 0x0b, 0x0a, 0x07, 0x5f, 0x43, 0x52, 0x45, 0x41, 0x54, 0x45, 0x10, 0x01, 0x12,
	0x0b, 0x0a, 0x07, 0x5f, 0x55, 0x50, 0x44, 0x41, 0x54, 0x45, 0x10, 0x02, 0x12, 0x0b, 0x0a, 0x07,
	0x5f, 0x44, 0x45, 0x4c, 0x45, 0x54, 0x45, 0x10, 0x03, 0x2a, 0xe5, 0x01, 0x0a, 0x07, 0x45, 0x6e,
	0x63, 0x54, 0x79, 0x70, 0x65, 0x12, 0x10, 0x0a, 0x0c, 0x5f, 0x41, 0x45, 0x53, 0x32, 0x35, 0x36,
	0x47, 0x43, 0x4d, 0x36, 0x34, 0x10, 0x00, 0x12, 0x10, 0x0a, 0x0c, 0x5f, 0x41, 0x45, 0x53, 0x32,
	0x35, 0x36, 0x47, 0x43, 0x4d, 0x39, 0x36, 0x10, 0x01, 0x12, 0x11, 0x0a, 0x0d, 0x5f, 0x41, 0x45,
	0x53, 0x32, 0x35, 0x36, 0x47, 0x43, 0x4d, 0x31, 0x32, 0x38, 0x10, 0x02, 0x12, 0x10, 0x0a, 0x0c,
	0x5f, 0x41, 0x45, 0x53, 0x31, 0x32, 0x38, 0x47, 0x43, 0x4d, 0x36, 0x34, 0x10, 0x03, 0x12, 0x10,
	0x0a, 0x0c, 0x5f, 0x41, 0x45, 0x53, 0x31, 0x32, 0x38, 0x47, 0x43, 0x4d, 0x39, 0x36, 0x10, 0x04,
	0x12, 0x11, 0x0a, 0x0d, 0x5f, 0x41, 0x45, 0x53, 0x31, 0x32, 0x38, 0x47, 0x43, 0x4d, 0x31, 0x32,
	0x38, 0x10, 0x05, 0x12, 0x10, 0x0a, 0x0c, 0x5f, 0x41, 0x45, 0x53, 0x32, 0x35, 0x36, 0x43, 0x43,
	0x4d, 0x36, 0x34, 0x10, 0x06, 0x12, 0x10, 0x0a, 0x0c, 0x5f, 0x41, 0x45, 0x53, 0x32, 0x35, 0x36,
	0x43, 0x43, 0x4d, 0x39, 0x36, 0x10, 0x07, 0x12, 0x11, 0x0a, 0x0d, 0x5f, 0x41, 0x45, 0x53, 0x32,
	0x35, 0x36, 0x43, 0x43, 0x4d, 0x31, 0x32, 0x38, 0x10, 0x08, 0x12, 0x10, 0x0a, 0x0c, 0x5f, 0x41,
	0x45, 0x53, 0x31, 0x32, 0x38, 0x43, 0x43, 0x4d, 0x36, 0x34, 0x10, 0x09, 0x12, 0x10, 0x0a, 0x0c,
	0x5f, 0x41, 0x45, 0x53, 0x31, 0x32, 0x38, 0x43, 0x43, 0x4d, 0x39, 0x36, 0x10, 0x0a, 0x12, 0x11,
	0x0a, 0x0d, 0x5f, 0x41, 0x45, 0x53, 0x31, 0x32, 0x38, 0x43, 0x43, 0x4d, 0x31, 0x32, 0x38, 0x10,
	0x0b, 0x2a, 0x30, 0x0a, 0x06, 0x41, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x08, 0x0a, 0x04, 0x4e,
	0x4f, 0x4e, 0x45, 0x10, 0x00, 0x12, 0x0b, 0x0a, 0x07, 0x46, 0x4f, 0x52, 0x57, 0x41, 0x52, 0x44,
	0x10, 0x01, 0x12, 0x0f, 0x0a, 0x0b, 0x52, 0x45, 0x43, 0x49, 0x52, 0x43, 0x55, 0x4c, 0x41, 0x54,
	0x45, 0x10, 0x02, 0x2a, 0x63, 0x0a, 0x0a, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x45, 0x72, 0x72, 0x6f,
	0x72, 0x12, 0x11, 0x0a, 0x0d, 0x4d, 0x49, 0x53, 0x49, 0x4e, 0x47, 0x5f, 0x46, 0x49, 0x45, 0x4c,
	0x44, 0x53, 0x10, 0x00, 0x12, 0x15, 0x0a, 0x11, 0x49, 0x4e, 0x56, 0x41, 0x4c, 0x49, 0x44, 0x5f,
	0x54, 0x55, 0x4e, 0x4e, 0x45, 0x4c, 0x5f, 0x49, 0x44, 0x10, 0x01, 0x12, 0x18, 0x0a, 0x14, 0x49,
	0x4e, 0x56, 0x41, 0x4c, 0x49, 0x44, 0x5f, 0x43, 0x41, 0x50, 0x41, 0x42, 0x49, 0x4c, 0x49, 0x54,
	0x49, 0x45, 0x53, 0x10, 0x02, 0x12, 0x11, 0x0a, 0x0d, 0x49, 0x4e, 0x56, 0x41, 0x4c, 0x49, 0x44,
	0x5f, 0x46, 0x49, 0x45, 0x4c, 0x44, 0x10, 0x03, 0x2a, 0x27, 0x0a, 0x0b, 0x54, 0x75, 0x6e, 0x6e,
	0x65, 0x6c, 0x45, 0x72, 0x72, 0x6f, 0x72, 0x12, 0x18, 0x0a, 0x14, 0x4e, 0x4f, 0x54, 0x5f, 0x53,
	0x55, 0x50, 0x50, 0x4f, 0x52, 0x54, 0x45, 0x44, 0x5f, 0x54, 0x55, 0x4e, 0x4e, 0x45, 0x4c, 0x10,
	0x00, 0x2a, 0x74, 0x0a, 0x0a, 0x49, 0x50, 0x53, 0x65, 0x63, 0x45, 0x72, 0x72, 0x6f, 0x72, 0x12,
	0x0f, 0x0a, 0x0b, 0x49, 0x4e, 0x56, 0x41, 0x4c, 0x49, 0x44, 0x5f, 0x4b, 0x45, 0x59, 0x10, 0x00,
	0x12, 0x1c, 0x0a, 0x18, 0x4e, 0x4f, 0x4e, 0x5f, 0x53, 0x55, 0x50, 0x50, 0x4f, 0x52, 0x54, 0x45,
	0x44, 0x5f, 0x45, 0x4e, 0x43, 0x52, 0x59, 0x50, 0x54, 0x49, 0x4f, 0x4e, 0x10, 0x01, 0x12, 0x1d,
	0x0a, 0x19, 0x4e, 0x4f, 0x4e, 0x5f, 0x53, 0x55, 0x50, 0x50, 0x4f, 0x52, 0x54, 0x45, 0x44, 0x5f,
	0x54, 0x55, 0x4e, 0x4e, 0x45, 0x4c, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x10, 0x02, 0x12, 0x18, 0x0a,
	0x14, 0x49, 0x50, 0x53, 0x45, 0x43, 0x5f, 0x4d, 0x49, 0x53, 0x53, 0x49, 0x4e, 0x47, 0x5f, 0x46,
	0x49, 0x45, 0x4c, 0x44, 0x53, 0x10, 0x03, 0x2a, 0x51, 0x0a, 0x0b, 0x47, 0x65, 0x6e, 0x65, 0x76,
	0x65, 0x45, 0x72, 0x72, 0x6f, 0x72, 0x12, 0x12, 0x0a, 0x0e, 0x49, 0x4e, 0x56, 0x41, 0x4c, 0x49,
	0x44, 0x5f, 0x4f, 0x50, 0x54, 0x49, 0x4f, 0x4e, 0x10, 0x00, 0x12, 0x14, 0x0a, 0x10, 0x54, 0x4f,
	0x4f, 0x5f, 0x4d, 0x41, 0x4e, 0x59, 0x5f, 0x4f, 0x50, 0x54, 0x49, 0x4f, 0x4e, 0x53, 0x10, 0x01,
	0x12, 0x18, 0x0a, 0x14, 0x49, 0x4e, 0x56, 0x41, 0x4c, 0x49, 0x44, 0x5f, 0x47, 0x45, 0x4e, 0x45,
	0x56, 0x45, 0x5f, 0x46, 0x49, 0x45, 0x4c, 0x44, 0x10, 0x02, 0x2a, 0x63, 0x0a, 0x0f, 0x49, 0x50,
	0x53, 0x65, 0x63, 0x54, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x54, 0x79, 0x70, 0x65, 0x12, 0x0d, 0x0a,
	0x09, 0x54, 0x52, 0x41, 0x4e, 0x53, 0x50, 0x4f, 0x52, 0x54, 0x10, 0x00, 0x12, 0x0a, 0x0a, 0x06,
	0x54, 0x55, 0x4e, 0x4e, 0x45, 0x4c, 0x10, 0x01, 0x12, 0x1b, 0x0a, 0x17, 0x54, 0x52, 0x41, 0x4e,
	0x53, 0x50, 0x4f, 0x52, 0x54, 0x5f, 0x4e, 0x41, 0x54, 0x5f, 0x54, 0x52, 0x41, 0x56, 0x45, 0x52,
	0x53, 0x41, 0x4c, 0x10, 0x02, 0x12, 0x18, 0x0a, 0x14, 0x54, 0x55, 0x4e, 0x4e, 0x45, 0x4c, 0x5f,
	0x4e, 0x41, 0x54, 0x5f, 0x54, 0x52, 0x41, 0x56, 0x45, 0x52, 0x53, 0x41, 0x4c, 0x10, 0x03, 0x32,
	0xc8, 0x04, 0x0a, 0x0f, 0x49, 0x70, 0x54, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x53, 0x65, 0x72, 0x76,
	0x69, 0x63, 0x65, 0x12, 0x59, 0x0a, 0x0c, 0x43, 0x61, 0x70, 0x61, 0x62, 0x69, 0x6c, 0x69, 0x74,
	0x69, 0x65, 0x73, 0x12, 0x23, 0x2e, 0x74, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x6f, 0x66, 0x66, 0x6c,
	0x6f, 0x61, 0x64, 0x2e, 0x76, 0x32, 0x2e, 0x43, 0x61, 0x70, 0x61, 0x62, 0x69, 0x6c, 0x69, 0x74,
	0x79, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x24, 0x2e, 0x74, 0x75, 0x6e, 0x6e, 0x65,
	0x6c, 0x6f, 0x66, 0x66, 0x6c, 0x6f, 0x61, 0x64, 0x2e, 0x76, 0x32, 0x2e, 0x43, 0x61, 0x70, 0x61,
	0x62, 0x69, 0x6c, 0x69, 0x74, 0x79, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x62,
	0x0a, 0x0e, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x49, 0x70, 0x54, 0x75, 0x6e, 0x6e, 0x65, 0x6c,
	0x12, 0x21, 0x2e, 0x74, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x6f, 0x66, 0x66, 0x6c, 0x6f, 0x61, 0x64,
	0x2e, 0x76, 0x32, 0x2e, 0x49, 0x70, 0x54, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x52, 0x65, 0x71, 0x75,
	0x65, 0x73, 0x74, 0x1a, 0x29, 0x2e, 0x74, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x6f, 0x66, 0x66, 0x6c,
	0x6f, 0x61, 0x64, 0x2e, 0x76, 0x32, 0x2e, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x49, 0x70, 0x54,
	0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x73, 0x22, 0x00,
	0x28, 0x01, 0x12, 0x4f, 0x0a, 0x0b, 0x47, 0x65, 0x74, 0x49, 0x70, 0x54, 0x75, 0x6e, 0x6e, 0x65,
	0x6c, 0x12, 0x1a, 0x2e, 0x74, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x6f, 0x66, 0x66, 0x6c, 0x6f, 0x61,
	0x64, 0x2e, 0x76, 0x32, 0x2e, 0x54, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x49, 0x64, 0x1a, 0x22, 0x2e,
	0x74, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x6f, 0x66, 0x66, 0x6c, 0x6f, 0x61, 0x64, 0x2e, 0x76, 0x32,
	0x2e, 0x49, 0x70, 0x54, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73,
	0x65, 0x22, 0x00, 0x12, 0x59, 0x0a, 0x10, 0x47, 0x65, 0x74, 0x49, 0x70, 0x54, 0x75, 0x6e, 0x6e,
	0x65, 0x6c, 0x53, 0x74, 0x61, 0x74, 0x73, 0x12, 0x1a, 0x2e, 0x74, 0x75, 0x6e, 0x6e, 0x65, 0x6c,
	0x6f, 0x66, 0x66, 0x6c, 0x6f, 0x61, 0x64, 0x2e, 0x76, 0x32, 0x2e, 0x54, 0x75, 0x6e, 0x6e, 0x65,
	0x6c, 0x49, 0x64, 0x1a, 0x27, 0x2e, 0x74, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x6f, 0x66, 0x66, 0x6c,
	0x6f, 0x61, 0x64, 0x2e, 0x76, 0x32, 0x2e, 0x49, 0x70, 0x54, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x53,
	0x74, 0x61, 0x74, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x5f,
	0x0a, 0x0f, 0x47, 0x65, 0x74, 0x41, 0x6c, 0x6c, 0x49, 0x70, 0x54, 0x75, 0x6e, 0x6e, 0x65, 0x6c,
	0x73, 0x12, 0x23, 0x2e, 0x74, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x6f, 0x66, 0x66, 0x6c, 0x6f, 0x61,
	0x64, 0x2e, 0x76, 0x32, 0x2e, 0x54, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x52, 0x65, 0x71, 0x75, 0x65,
	0x73, 0x74, 0x41, 0x72, 0x67, 0x73, 0x1a, 0x23, 0x2e, 0x74, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x6f,
	0x66, 0x66, 0x6c, 0x6f, 0x61, 0x64, 0x2e, 0x76, 0x32, 0x2e, 0x49, 0x70, 0x54, 0x75, 0x6e, 0x6e,
	0x65, 0x6c, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x73, 0x22, 0x00, 0x30, 0x01, 0x12,
	0x69, 0x0a, 0x14, 0x47, 0x65, 0x74, 0x41, 0x6c, 0x6c, 0x49, 0x70, 0x54, 0x75, 0x6e, 0x6e, 0x65,
	0x6c, 0x73, 0x53, 0x74, 0x61, 0x74, 0x73, 0x12, 0x23, 0x2e, 0x74, 0x75, 0x6e, 0x6e, 0x65, 0x6c,
	0x6f, 0x66, 0x66, 0x6c, 0x6f, 0x61, 0x64, 0x2e, 0x76, 0x32, 0x2e, 0x54, 0x75, 0x6e, 0x6e, 0x65,
	0x6c, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x41, 0x72, 0x67, 0x73, 0x1a, 0x28, 0x2e, 0x74,
	0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x6f, 0x66, 0x66, 0x6c, 0x6f, 0x61, 0x64, 0x2e, 0x76, 0x32, 0x2e,
	0x49, 0x70, 0x54, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x53, 0x74, 0x61, 0x74, 0x73, 0x52, 0x65, 0x73,
	0x70, 0x6f, 0x6e, 0x73, 0x65, 0x73, 0x22, 0x00, 0x30, 0x01, 0x42, 0x26, 0x5a, 0x24, 0x67, 0x69,
	0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x61, 0x74, 0x74, 0x2f, 0x73, 0x65, 0x73,
	0x73, 0x69, 0x6f, 0x6e, 0x4f, 0x66, 0x66, 0x6c, 0x6f, 0x61, 0x64, 0x2f, 0x70, 0x72, 0x6f, 0x74,
	0x6f, 0x73, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
	file_tunneloffload_proto_rawDescOnce sync.Once
	file_tunneloffload_proto_rawDescData = file_tunneloffload_proto_rawDesc
)

func file_tunneloffload_proto_rawDescGZIP() []byte {
	file_tunneloffload_proto_rawDescOnce.Do(func() {
		file_tunneloffload_proto_rawDescData = protoimpl.X.CompressGZIP(file_tunneloffload_proto_rawDescData)
	})
	return file_tunneloffload_proto_rawDescData
}

var file_tunneloffload_proto_enumTypes = make([]protoimpl.EnumInfo, 9)
var file_tunneloffload_proto_msgTypes = make([]protoimpl.MessageInfo, 35)
var file_tunneloffload_proto_goTypes = []interface{}{
	(AddTunnelStatus)(0),                          // 0: tunneloffload.v2.AddTunnelStatus
	(Operation)(0),                                // 1: tunneloffload.v2.Operation
	(EncType)(0),                                  // 2: tunneloffload.v2.EncType
	(Action)(0),                                   // 3: tunneloffload.v2.Action
	(MatchError)(0),                               // 4: tunneloffload.v2.MatchError
	(TunnelError)(0),                              // 5: tunneloffload.v2.TunnelError
	(IPSecError)(0),                               // 6: tunneloffload.v2.IPSecError
	(GeneveError)(0),                              // 7: tunneloffload.v2.GeneveError
	(IPSecTunnelType)(0),                          // 8: tunneloffload.v2.IPSecTunnelType
	(*CapabilityRequest)(nil),                     // 9: tunneloffload.v2.CapabilityRequest
	(*CapabilityResponse)(nil),                    // 10: tunneloffload.v2.CapabilityResponse
	(*TunnelAdditionError)(nil),                   // 11: tunneloffload.v2.TunnelAdditionError
	(*MatchCriteria)(nil),                         // 12: tunneloffload.v2.MatchCriteria
	(*IpTunnelRequest)(nil),                       // 13: tunneloffload.v2.IpTunnelRequest
	(*Geneve)(nil),                                // 14: tunneloffload.v2.Geneve
	(*GeneveOption)(nil),                          // 15: tunneloffload.v2.GeneveOption
	(*GeneveEncap)(nil),                           // 16: tunneloffload.v2.GeneveEncap
	(*GeneveDecap)(nil),                           // 17: tunneloffload.v2.GeneveDecap
	(*MacPair)(nil),                               // 18: tunneloffload.v2.MacPair
	(*IPV4Pair)(nil),                              // 19: tunneloffload.v2.IPV4Pair
	(*IPV6Pair)(nil),                              // 20: tunneloffload.v2.IPV6Pair
	(*IPV4Match)(nil),                             // 21: tunneloffload.v2.IPV4Match
	(*IPV6Match)(nil),                             // 22: tunneloffload.v2.IPV6Match
	(*Nat)(nil),                                   // 23: tunneloffload.v2.Nat
	(*IPSecEnc)(nil),                              // 24: tunneloffload.v2.IPSecEnc
	(*IPSecDec)(nil),                              // 25: tunneloffload.v2.IPSecDec
	(*IPSecSAParams)(nil),                         // 26: tunneloffload.v2.IPSecSAParams
	(*IPSecTunnel)(nil),                           // 27: tunneloffload.v2.IPSecTunnel
	(*TunnelId)(nil),                              // 28: tunneloffload.v2.TunnelId
	(*Counters)(nil),                              // 29: tunneloffload.v2.Counters
	(*CreateIpTunnelResponses)(nil),               // 30: tunneloffload.v2.CreateIpTunnelResponses
	(*CreateIpTunnelResponse)(nil),                // 31: tunneloffload.v2.CreateIpTunnelResponse
	(*Error)(nil),                                 // 32: tunneloffload.v2.Error
	(*IpTunnelResponses)(nil),                     // 33: tunneloffload.v2.IpTunnelResponses
	(*IpTunnelResponse)(nil),                      // 34: tunneloffload.v2.IpTunnelResponse
	(*IpTunnelStatsResponses)(nil),                // 35: tunneloffload.v2.IpTunnelStatsResponses
	(*IpTunnelStatsResponse)(nil),                 // 36: tunneloffload.v2.IpTunnelStatsResponse
	(*TunnelRequestArgs)(nil),                     // 37: tunneloffload.v2.TunnelRequestArgs
	(*CapabilityResponse_MatchCapabilities)(nil),  // 38: tunneloffload.v2.CapabilityResponse.MatchCapabilities
	(*CapabilityResponse_IPSecCapabilities)(nil),  // 39: tunneloffload.v2.CapabilityResponse.IPSecCapabilities
	(*CapabilityResponse_GeneveCapabilities)(nil), // 40: tunneloffload.v2.CapabilityResponse.GeneveCapabilities
	(*MatchCriteria_IPSecMatch)(nil),              // 41: tunneloffload.v2.MatchCriteria.IPSecMatch
	(*MatchCriteria_GeneveMatch)(nil),             // 42: tunneloffload.v2.MatchCriteria.GeneveMatch
	(*MatchCriteria_VXLanMatch)(nil),              // 43: tunneloffload.v2.MatchCriteria.VXLanMatch
}
var file_tunneloffload_proto_depIdxs = []int32{
	38, // 0: tunneloffload.v2.CapabilityResponse.match_capabilities:type_name -> tunneloffload.v2.CapabilityResponse.MatchCapabilities
	39, // 1: tunneloffload.v2.CapabilityResponse.ipsec_capabilities:type_name -> tunneloffload.v2.CapabilityResponse.IPSecCapabilities
	40, // 2: tunneloffload.v2.CapabilityResponse.geneve_capabilities:type_name -> tunneloffload.v2.CapabilityResponse.GeneveCapabilities
	4,  // 3: tunneloffload.v2.TunnelAdditionError.match_error:type_name -> tunneloffload.v2.MatchError
	5,  // 4: tunneloffload.v2.TunnelAdditionError.tunnel_error:type_name -> tunneloffload.v2.TunnelError
	6,  // 5: tunneloffload.v2.TunnelAdditionError.ipsec_error:type_name -> tunneloffload.v2.IPSecError
	7,  // 6: tunneloffload.v2.TunnelAdditionError.geneve_error:type_name -> tunneloffload.v2.GeneveError
	18, // 7: tunneloffload.v2.MatchCriteria.mac_match:type_name -> tunneloffload.v2.MacPair
	21, // 8: tunneloffload.v2.MatchCriteria.ipv4_match:type_name -> tunneloffload.v2.IPV4Match
	22, // 9: tunneloffload.v2.MatchCriteria.ipv6_match:type_name -> tunneloffload.v2.IPV6Match
	41, // 10: tunneloffload.v2.MatchCriteria.ipsec_match:type_name -> tunneloffload.v2.MatchCriteria.IPSecMatch
	42, // 11: tunneloffload.v2.MatchCriteria.geneve_match:type_name -> tunneloffload.v2.MatchCriteria.GeneveMatch
	43, // 12: tunneloffload.v2.MatchCriteria.vxlan_match:type_name -> tunneloffload.v2.MatchCriteria.VXLanMatch
	1,  // 13: tunneloffload.v2.IpTunnelRequest.operation:type_name -> tunneloffload.v2.Operation
	12, // 14: tunneloffload.v2.IpTunnelRequest.match_criteria:type_name -> tunneloffload.v2.MatchCriteria
	3,  // 15: tunneloffload.v2.IpTunnelRequest.next_action:type_name -> tunneloffload.v2.Action
	27, // 16: tunneloffload.v2.IpTunnelRequest.ipsec_tunnel:type_name -> tunneloffload.v2.IPSecTunnel
	14, // 17: tunneloffload.v2.IpTunnelRequest.geneve:type_name -> tunneloffload.v2.Geneve
	23, // 18: tunneloffload.v2.IpTunnelRequest.nat:type_name -> tunneloffload.v2.Nat
	16, // 19: tunneloffload.v2.Geneve.geneve_encap:type_name -> tunneloffload.v2.GeneveEncap
	17, // 20: tunneloffload.v2.Geneve.geneve_decap:type_name -> tunneloffload.v2.GeneveDecap
	19, // 21: tunneloffload.v2.GeneveEncap.outer_ipv4_pair:type_name -> tunneloffload.v2.IPV4Pair
	20, // 22: tunneloffload.v2.GeneveEncap.outer_ipv6_pair:type_name -> tunneloffload.v2.IPV6Pair
	18, // 23: tunneloffload.v2.GeneveEncap.inner_mac_pair:type_name -> tunneloffload.v2.MacPair
	15, // 24: tunneloffload.v2.GeneveEncap.geneve_option:type_name -> tunneloffload.v2.GeneveOption
	8,  // 25: tunneloffload.v2.IPSecEnc.tunnel_type:type_name -> tunneloffload.v2.IPSecTunnelType
	2,  // 26: tunneloffload.v2.IPSecEnc.encryption_type:type_name -> tunneloffload.v2.EncType
	26, // 27: tunneloffload.v2.IPSecEnc.ipsec_sa:type_name -> tunneloffload.v2.IPSecSAParams
	19, // 28: tunneloffload.v2.IPSecEnc.ipv4_tunnel:type_name -> tunneloffload.v2.IPV4Pair
	20, // 29: tunneloffload.v2.IPSecEnc.ipv6_tunnel:type_name -> tunneloffload.v2.IPV6Pair
	8,  // 30: tunneloffload.v2.IPSecDec.tunnel_type:type_name -> tunneloffload.v2.IPSecTunnelType
	2,  // 31: tunneloffload.v2.IPSecDec.encryption_type:type_name -> tunneloffload.v2.EncType
	26, // 32: tunneloffload.v2.IPSecDec.ipsec_sas:type_name -> tunneloffload.v2.IPSecSAParams
	1,  // 33: tunneloffload.v2.IPSecSAParams.operation:type_name -> tunneloffload.v2.Operation
	24, // 34: tunneloffload.v2.IPSecTunnel.ipsec_enc:type_name -> tunneloffload.v2.IPSecEnc
	25, // 35: tunneloffload.v2.IPSecTunnel.ipsec_dec:type_name -> tunneloffload.v2.IPSecDec
	0,  // 36: tunneloffload.v2.CreateIpTunnelResponses.request_status:type_name -> tunneloffload.v2.AddTunnelStatus
	31, // 37: tunneloffload.v2.CreateIpTunnelResponses.responses:type_name -> tunneloffload.v2.CreateIpTunnelResponse
	32, // 38: tunneloffload.v2.CreateIpTunnelResponse.error:type_name -> tunneloffload.v2.Error
	11, // 39: tunneloffload.v2.Error.error_message:type_name -> tunneloffload.v2.TunnelAdditionError
	34, // 40: tunneloffload.v2.IpTunnelResponses.responses:type_name -> tunneloffload.v2.IpTunnelResponse
	13, // 41: tunneloffload.v2.IpTunnelResponse.ip_tunnel:type_name -> tunneloffload.v2.IpTunnelRequest
	29, // 42: tunneloffload.v2.IpTunnelResponse.tunnel_counters:type_name -> tunneloffload.v2.Counters
	32, // 43: tunneloffload.v2.IpTunnelResponse.error:type_name -> tunneloffload.v2.Error
	36, // 44: tunneloffload.v2.IpTunnelStatsResponses.responses:type_name -> tunneloffload.v2.IpTunnelStatsResponse
	29, // 45: tunneloffload.v2.IpTunnelStatsResponse.tunnel_counters:type_name -> tunneloffload.v2.Counters
	32, // 46: tunneloffload.v2.IpTunnelStatsResponse.error:type_name -> tunneloffload.v2.Error
	8,  // 47: tunneloffload.v2.CapabilityResponse.IPSecCapabilities.tunnel_type_supported:type_name -> tunneloffload.v2.IPSecTunnelType
	2,  // 48: tunneloffload.v2.CapabilityResponse.IPSecCapabilities.encryption_supported:type_name -> tunneloffload.v2.EncType
	18, // 49: tunneloffload.v2.MatchCriteria.GeneveMatch.mac_match:type_name -> tunneloffload.v2.MacPair
	21, // 50: tunneloffload.v2.MatchCriteria.GeneveMatch.ipv4_match:type_name -> tunneloffload.v2.IPV4Match
	22, // 51: tunneloffload.v2.MatchCriteria.GeneveMatch.ipv6_match:type_name -> tunneloffload.v2.IPV6Match
	18, // 52: tunneloffload.v2.MatchCriteria.VXLanMatch.mac_match:type_name -> tunneloffload.v2.MacPair
	21, // 53: tunneloffload.v2.MatchCriteria.VXLanMatch.ipv4_match:type_name -> tunneloffload.v2.IPV4Match
	22, // 54: tunneloffload.v2.MatchCriteria.VXLanMatch.ipv6_match:type_name -> tunneloffload.v2.IPV6Match
	9,  // 55: tunneloffload.v2.IpTunnelService.Capabilities:input_type -> tunneloffload.v2.CapabilityRequest
	13, // 56: tunneloffload.v2.IpTunnelService.CreateIpTunnel:input_type -> tunneloffload.v2.IpTunnelRequest
	28, // 57: tunneloffload.v2.IpTunnelService.GetIpTunnel:input_type -> tunneloffload.v2.TunnelId
	28, // 58: tunneloffload.v2.IpTunnelService.GetIpTunnelStats:input_type -> tunneloffload.v2.TunnelId
	37, // 59: tunneloffload.v2.IpTunnelService.GetAllIpTunnels:input_type -> tunneloffload.v2.TunnelRequestArgs
	37, // 60: tunneloffload.v2.IpTunnelService.GetAllIpTunnelsStats:input_type -> tunneloffload.v2.TunnelRequestArgs
	10, // 61: tunneloffload.v2.IpTunnelService.Capabilities:output_type -> tunneloffload.v2.CapabilityResponse
	30, // 62: tunneloffload.v2.IpTunnelService.CreateIpTunnel:output_type -> tunneloffload.v2.CreateIpTunnelResponses
	34, // 63: tunneloffload.v2.IpTunnelService.GetIpTunnel:output_type -> tunneloffload.v2.IpTunnelResponse
	36, // 64: tunneloffload.v2.IpTunnelService.GetIpTunnelStats:output_type -> tunneloffload.v2.IpTunnelStatsResponse
	33, // 65: tunneloffload.v2.IpTunnelService.GetAllIpTunnels:output_type -> tunneloffload.v2.IpTunnelResponses
	35, // 66: tunneloffload.v2.IpTunnelService.GetAllIpTunnelsStats:output_type -> tunneloffload.v2.IpTunnelStatsResponses
	61, // [61:67] is the sub-list for method output_type
	55, // [55:61] is the sub-list for method input_type
	55, // [55:55] is the sub-list for extension type_name
	55, // [55:55] is the sub-list for extension extendee
	0,  // [0:55] is the sub-list for field type_name
}

func init() { file_tunneloffload_proto_init() }
func file_tunneloffload_proto_init() {
	if File_tunneloffload_proto != nil {
		return
	}
	if !protoimpl.UnsafeEnabled {
		file_tunneloffload_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*CapabilityRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_tunneloffload_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*CapabilityResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_tunneloffload_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*TunnelAdditionError); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_tunneloffload_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MatchCriteria); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_tunneloffload_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*IpTunnelRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_tunneloffload_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Geneve); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_tunneloffload_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*GeneveOption); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_tunneloffload_proto_msgTypes[7].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*GeneveEncap); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_tunneloffload_proto_msgTypes[8].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*GeneveDecap); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_tunneloffload_proto_msgTypes[9].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MacPair); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_tunneloffload_proto_msgTypes[10].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*IPV4Pair); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_tunneloffload_proto_msgTypes[11].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*IPV6Pair); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_tunneloffload_proto_msgTypes[12].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*IPV4Match); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_tunneloffload_proto_msgTypes[13].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*IPV6Match); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_tunneloffload_proto_msgTypes[14].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Nat); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_tunneloffload_proto_msgTypes[15].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*IPSecEnc); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_tunneloffload_proto_msgTypes[16].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*IPSecDec); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_tunneloffload_proto_msgTypes[17].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*IPSecSAParams); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_tunneloffload_proto_msgTypes[18].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*IPSecTunnel); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_tunneloffload_proto_msgTypes[19].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*TunnelId); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_tunneloffload_proto_msgTypes[20].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Counters); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_tunneloffload_proto_msgTypes[21].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*CreateIpTunnelResponses); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_tunneloffload_proto_msgTypes[22].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*CreateIpTunnelResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_tunneloffload_proto_msgTypes[23].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Error); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_tunneloffload_proto_msgTypes[24].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*IpTunnelResponses); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_tunneloffload_proto_msgTypes[25].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*IpTunnelResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_tunneloffload_proto_msgTypes[26].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*IpTunnelStatsResponses); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_tunneloffload_proto_msgTypes[27].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*IpTunnelStatsResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_tunneloffload_proto_msgTypes[28].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*TunnelRequestArgs); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_tunneloffload_proto_msgTypes[29].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*CapabilityResponse_MatchCapabilities); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_tunneloffload_proto_msgTypes[30].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*CapabilityResponse_IPSecCapabilities); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_tunneloffload_proto_msgTypes[31].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*CapabilityResponse_GeneveCapabilities); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_tunneloffload_proto_msgTypes[32].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MatchCriteria_IPSecMatch); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_tunneloffload_proto_msgTypes[33].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MatchCriteria_GeneveMatch); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_tunneloffload_proto_msgTypes[34].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MatchCriteria_VXLanMatch); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	file_tunneloffload_proto_msgTypes[3].OneofWrappers = []interface{}{
		(*MatchCriteria_Ipv4Match)(nil),
		(*MatchCriteria_Ipv6Match)(nil),
		(*MatchCriteria_IpsecMatch)(nil),
		(*MatchCriteria_GeneveMatch_)(nil),
		(*MatchCriteria_VxlanMatch)(nil),
	}
	file_tunneloffload_proto_msgTypes[4].OneofWrappers = []interface{}{
		(*IpTunnelRequest_IpsecTunnel)(nil),
		(*IpTunnelRequest_Geneve)(nil),
		(*IpTunnelRequest_Nat)(nil),
	}
	file_tunneloffload_proto_msgTypes[5].OneofWrappers = []interface{}{
		(*Geneve_GeneveEncap)(nil),
		(*Geneve_GeneveDecap)(nil),
	}
	file_tunneloffload_proto_msgTypes[7].OneofWrappers = []interface{}{
		(*GeneveEncap_OuterIpv4Pair)(nil),
		(*GeneveEncap_OuterIpv6Pair)(nil),
	}
	file_tunneloffload_proto_msgTypes[15].OneofWrappers = []interface{}{
		(*IPSecEnc_Ipv4Tunnel)(nil),
		(*IPSecEnc_Ipv6Tunnel)(nil),
	}
	file_tunneloffload_proto_msgTypes[18].OneofWrappers = []interface{}{
		(*IPSecTunnel_IpsecEnc)(nil),
		(*IPSecTunnel_IpsecDec)(nil),
	}
	file_tunneloffload_proto_msgTypes[33].OneofWrappers = []interface{}{
		(*MatchCriteria_GeneveMatch_Ipv4Match)(nil),
		(*MatchCriteria_GeneveMatch_Ipv6Match)(nil),
	}
	file_tunneloffload_proto_msgTypes[34].OneofWrappers = []interface{}{
		(*MatchCriteria_VXLanMatch_Ipv4Match)(nil),
		(*MatchCriteria_VXLanMatch_Ipv6Match)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_tunneloffload_proto_rawDesc,
			NumEnums:      9,
			NumMessages:   35,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_tunneloffload_proto_goTypes,
		DependencyIndexes: file_tunneloffload_proto_depIdxs,
		EnumInfos:         file_tunneloffload_proto_enumTypes,
		MessageInfos:      file_tunneloffload_proto_msgTypes,
	}.Build()
	File_tunneloffload_proto = out.File
	file_tunneloffload_proto_rawDesc = nil
	file_tunneloffload_proto_goTypes = nil
	file_tunneloffload_proto_depIdxs = nil
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConnInterface

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion6

// IpTunnelServiceClient is the client API for IpTunnelService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type IpTunnelServiceClient interface {
	// Get which capabilities are available while using the
	Capabilities(ctx context.Context, in *CapabilityRequest, opts ...grpc.CallOption) (*CapabilityResponse, error)
	// Creation of IP Tunnel
	// This API should be generic and allow creations of many IP tunnels
	CreateIpTunnel(ctx context.Context, opts ...grpc.CallOption) (IpTunnelService_CreateIpTunnelClient, error)
	// Getting a tunnel by it's ID
	GetIpTunnel(ctx context.Context, in *TunnelId, opts ...grpc.CallOption) (*IpTunnelResponse, error)
	// Getting a tunnel by it's ID
	GetIpTunnelStats(ctx context.Context, in *TunnelId, opts ...grpc.CallOption) (*IpTunnelStatsResponse, error)
	// Getting all the ipTunnels currently configured
	GetAllIpTunnels(ctx context.Context, in *TunnelRequestArgs, opts ...grpc.CallOption) (IpTunnelService_GetAllIpTunnelsClient, error)
	// Get all the iptunnels stats responses
	GetAllIpTunnelsStats(ctx context.Context, in *TunnelRequestArgs, opts ...grpc.CallOption) (IpTunnelService_GetAllIpTunnelsStatsClient, error)
}

type ipTunnelServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewIpTunnelServiceClient(cc grpc.ClientConnInterface) IpTunnelServiceClient {
	return &ipTunnelServiceClient{cc}
}

func (c *ipTunnelServiceClient) Capabilities(ctx context.Context, in *CapabilityRequest, opts ...grpc.CallOption) (*CapabilityResponse, error) {
	out := new(CapabilityResponse)
	err := c.cc.Invoke(ctx, "/tunneloffload.v2.IpTunnelService/Capabilities", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ipTunnelServiceClient) CreateIpTunnel(ctx context.Context, opts ...grpc.CallOption) (IpTunnelService_CreateIpTunnelClient, error) {
	stream, err := c.cc.NewStream(ctx, &_IpTunnelService_serviceDesc.Streams[0], "/tunneloffload.v2.IpTunnelService/CreateIpTunnel", opts...)
	if err != nil {
		return nil, err
	}
	x := &ipTunnelServiceCreateIpTunnelClient{stream}
	return x, nil
}

type IpTunnelService_CreateIpTunnelClient interface {
	Send(*IpTunnelRequest) error
	CloseAndRecv() (*CreateIpTunnelResponses, error)
	grpc.ClientStream
}

type ipTunnelServiceCreateIpTunnelClient struct {
	grpc.ClientStream
}

func (x *ipTunnelServiceCreateIpTunnelClient) Send(m *IpTunnelRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *ipTunnelServiceCreateIpTunnelClient) CloseAndRecv() (*CreateIpTunnelResponses, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(CreateIpTunnelResponses)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *ipTunnelServiceClient) GetIpTunnel(ctx context.Context, in *TunnelId, opts ...grpc.CallOption) (*IpTunnelResponse, error) {
	out := new(IpTunnelResponse)
	err := c.cc.Invoke(ctx, "/tunneloffload.v2.IpTunnelService/GetIpTunnel", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ipTunnelServiceClient) GetIpTunnelStats(ctx context.Context, in *TunnelId, opts ...grpc.CallOption) (*IpTunnelStatsResponse, error) {
	out := new(IpTunnelStatsResponse)
	err := c.cc.Invoke(ctx, "/tunneloffload.v2.IpTunnelService/GetIpTunnelStats", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ipTunnelServiceClient) GetAllIpTunnels(ctx context.Context, in *TunnelRequestArgs, opts ...grpc.CallOption) (IpTunnelService_GetAllIpTunnelsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_IpTunnelService_serviceDesc.Streams[1], "/tunneloffload.v2.IpTunnelService/GetAllIpTunnels", opts...)
	if err != nil {
		return nil, err
	}
	x := &ipTunnelServiceGetAllIpTunnelsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type IpTunnelService_GetAllIpTunnelsClient interface {
	Recv() (*IpTunnelResponses, error)
	grpc.ClientStream
}

type ipTunnelServiceGetAllIpTunnelsClient struct {
	grpc.ClientStream
}

func (x *ipTunnelServiceGetAllIpTunnelsClient) Recv() (*IpTunnelResponses, error) {
	m := new(IpTunnelResponses)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *ipTunnelServiceClient) GetAllIpTunnelsStats(ctx context.Context, in *TunnelRequestArgs, opts ...grpc.CallOption) (IpTunnelService_GetAllIpTunnelsStatsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_IpTunnelService_serviceDesc.Streams[2], "/tunneloffload.v2.IpTunnelService/GetAllIpTunnelsStats", opts...)
	if err != nil {
		return nil, err
	}
	x := &ipTunnelServiceGetAllIpTunnelsStatsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type IpTunnelService_GetAllIpTunnelsStatsClient interface {
	Recv() (*IpTunnelStatsResponses, error)
	grpc.ClientStream
}

type ipTunnelServiceGetAllIpTunnelsStatsClient struct {
	grpc.ClientStream
}

func (x *ipTunnelServiceGetAllIpTunnelsStatsClient) Recv() (*IpTunnelStatsResponses, error) {
	m := new(IpTunnelStatsResponses)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// IpTunnelServiceServer is the server API for IpTunnelService service.
type IpTunnelServiceServer interface {
	// Get which capabilities are available while using the
	Capabilities(context.Context, *CapabilityRequest) (*CapabilityResponse, error)
	// Creation of IP Tunnel
	// This API should be generic and allow creations of many IP tunnels
	CreateIpTunnel(IpTunnelService_CreateIpTunnelServer) error
	// Getting a tunnel by it's ID
	GetIpTunnel(context.Context, *TunnelId) (*IpTunnelResponse, error)
	// Getting a tunnel by it's ID
	GetIpTunnelStats(context.Context, *TunnelId) (*IpTunnelStatsResponse, error)
	// Getting all the ipTunnels currently configured
	GetAllIpTunnels(*TunnelRequestArgs, IpTunnelService_GetAllIpTunnelsServer) error
	// Get all the iptunnels stats responses
	GetAllIpTunnelsStats(*TunnelRequestArgs, IpTunnelService_GetAllIpTunnelsStatsServer) error
}

// UnimplementedIpTunnelServiceServer can be embedded to have forward compatible implementations.
type UnimplementedIpTunnelServiceServer struct {
}

func (*UnimplementedIpTunnelServiceServer) Capabilities(context.Context, *CapabilityRequest) (*CapabilityResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Capabilities not implemented")
}
func (*UnimplementedIpTunnelServiceServer) CreateIpTunnel(IpTunnelService_CreateIpTunnelServer) error {
	return status.Errorf(codes.Unimplemented, "method CreateIpTunnel not implemented")
}
func (*UnimplementedIpTunnelServiceServer) GetIpTunnel(context.Context, *TunnelId) (*IpTunnelResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetIpTunnel not implemented")
}
func (*UnimplementedIpTunnelServiceServer) GetIpTunnelStats(context.Context, *TunnelId) (*IpTunnelStatsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetIpTunnelStats not implemented")
}
func (*UnimplementedIpTunnelServiceServer) GetAllIpTunnels(*TunnelRequestArgs, IpTunnelService_GetAllIpTunnelsServer) error {
	return status.Errorf(codes.Unimplemented, "method GetAllIpTunnels not implemented")
}
func (*UnimplementedIpTunnelServiceServer) GetAllIpTunnelsStats(*TunnelRequestArgs, IpTunnelService_GetAllIpTunnelsStatsServer) error {
	return status.Errorf(codes.Unimplemented, "method GetAllIpTunnelsStats not implemented")
}

func RegisterIpTunnelServiceServer(s *grpc.Server, srv IpTunnelServiceServer) {
	s.RegisterService(&_IpTunnelService_serviceDesc, srv)
}

func _IpTunnelService_Capabilities_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CapabilityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IpTunnelServiceServer).Capabilities(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tunneloffload.v2.IpTunnelService/Capabilities",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IpTunnelServiceServer).Capabilities(ctx, req.(*CapabilityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IpTunnelService_CreateIpTunnel_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(IpTunnelServiceServer).CreateIpTunnel(&ipTunnelServiceCreateIpTunnelServer{stream})
}

type IpTunnelService_CreateIpTunnelServer interface {
	SendAndClose(*CreateIpTunnelResponses) error
	Recv() (*IpTunnelRequest, error)
	grpc.ServerStream
}

type ipTunnelServiceCreateIpTunnelServer struct {
	grpc.ServerStream
}

func (x *ipTunnelServiceCreateIpTunnelServer) SendAndClose(m *CreateIpTunnelResponses) error {
	return x.ServerStream.SendMsg(m)
}

func (x *ipTunnelServiceCreateIpTunnelServer) Recv() (*IpTunnelRequest, error) {
	m := new(IpTunnelRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _IpTunnelService_GetIpTunnel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TunnelId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IpTunnelServiceServer).GetIpTunnel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tunneloffload.v2.IpTunnelService/GetIpTunnel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IpTunnelServiceServer).GetIpTunnel(ctx, req.(*TunnelId))
	}
	return interceptor(ctx, in, info, handler)
}

func _IpTunnelService_GetIpTunnelStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TunnelId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IpTunnelServiceServer).GetIpTunnelStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tunneloffload.v2.IpTunnelService/GetIpTunnelStats",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IpTunnelServiceServer).GetIpTunnelStats(ctx, req.(*TunnelId))
	}
	return interceptor(ctx, in, info, handler)
}

func _IpTunnelService_GetAllIpTunnels_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(TunnelRequestArgs)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(IpTunnelServiceServer).GetAllIpTunnels(m, &ipTunnelServiceGetAllIpTunnelsServer{stream})
}

type IpTunnelService_GetAllIpTunnelsServer interface {
	Send(*IpTunnelResponses) error
	grpc.ServerStream
}

type ipTunnelServiceGetAllIpTunnelsServer struct {
	grpc.ServerStream
}

func (x *ipTunnelServiceGetAllIpTunnelsServer) Send(m *IpTunnelResponses) error {
	return x.ServerStream.SendMsg(m)
}

func _IpTunnelService_GetAllIpTunnelsStats_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(TunnelRequestArgs)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(IpTunnelServiceServer).GetAllIpTunnelsStats(m, &ipTunnelServiceGetAllIpTunnelsStatsServer{stream})
}

type IpTunnelService_GetAllIpTunnelsStatsServer interface {
	Send(*IpTunnelStatsResponses) error
	grpc.ServerStream
}

type ipTunnelServiceGetAllIpTunnelsStatsServer struct {
	grpc.ServerStream
}

func (x *ipTunnelServiceGetAllIpTunnelsStatsServer) Send(m *IpTunnelStatsResponses) error {
	return x.ServerStream.SendMsg(m)
}

var _IpTunnelService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "tunneloffload.v2.IpTunnelService",
	HandlerType: (*IpTunnelServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Capabilities",
			Handler:    _IpTunnelService_Capabilities_Handler,
		},
		{
			MethodName: "GetIpTunnel",
			Handler:    _IpTunnelService_GetIpTunnel_Handler,
		},
		{
			MethodName: "GetIpTunnelStats",
			Handler:    _IpTunnelService_GetIpTunnelStats_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "CreateIpTunnel",
			Handler:       _IpTunnelService_CreateIpTunnel_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "GetAllIpTunnels",
			Handler:       _IpTunnelService_GetAllIpTunnels_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetAllIpTunnelsStats",
			Handler:       _IpTunnelService_GetAllIpTunnelsStats_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "tunneloffload.proto",
}
